<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
	<title>NixOS Planet</title>
	<link>https://planet.nixos.org</link>
	<language>en</language>
	<description>NixOS Planet - https://planet.nixos.org</description>
	<atom:link rel="self" href="https://planet.nixos.org/rss20.xml" type="application/rss+xml"/>

<item>
	<title>Tweag I/O: Nickel: better configuration for less</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-10-22-nickel-open-sourcing/</guid>
	<link>https://tweag.io/blog/2020-10-22-nickel-open-sourcing/</link>
	<description>&lt;p&gt;We are making the &lt;a href=&quot;https://www.github.com/tweag/nickel&quot;&gt;Nickel&lt;/a&gt; repository public. Nickel is an experimental configuration
language developed at Tweag. While this is not the time for the first
release yet, it is an occasion to talk about this project. The goal of this
post is to give a high-level overview of the project. If your curiosity is tickled
but you are left wanting to learn more, fear not, as we will publish
more blog posts on specific aspects of the language in the future. But for
now, let’s have a tour!&lt;/p&gt;
&lt;p&gt;[&lt;strong&gt;Disclaimer&lt;/strong&gt;: the actual syntax of Nickel being still worked on, I’m freely
using as-of-yet non-existing syntax for illustrative purposes. The underlying
features are however already supported.]&lt;/p&gt;
&lt;h2&gt;The inception&lt;/h2&gt;
&lt;p&gt;We, at Tweag, are avid users of the &lt;a href=&quot;https://nixos.org/&quot;&gt;Nix&lt;/a&gt; package manager. As it
happens, the configuration language for Nix (also called Nix) is
a pretty good configuration language, and would be applicable to many
more things than just package management.&lt;/p&gt;
&lt;p&gt;All in all, the Nix language is a lazy JSON with functions. It is
simple yet powerful. It is used to generate Nix’s package descriptions
but would be well
suited to write any kind of configuration (&lt;a href=&quot;https://www.terraform.io/&quot;&gt;Terraform&lt;/a&gt;,
&lt;a href=&quot;https://kubernetes.io/&quot;&gt;Kubernetes&lt;/a&gt;, etc…).&lt;/p&gt;
&lt;p&gt;The rub is that the interpreter for Nix-the-language is tightly
coupled with Nix-the-package manager. So, as it stands, using the
Nix language for anything else than package management is a rather
painful exercise.&lt;/p&gt;
&lt;p&gt;Nickel is our attempt at answering the question: what would
Nix-the-language look like if it was split from the package manager?
While taking the opportunity to improve the language a little,
building on the experience of the Nix community over the years.&lt;/p&gt;
&lt;h2&gt;What’s Nickel, exactly ?&lt;/h2&gt;
&lt;p&gt;Nickel is a lightweight generic configuration language. In that it can
replace YAML as your application’s configuration language. Unlike
YAML, though, it anticipates large configurations by being
programmable. Another way to use Nickel is to generate static
configuration files — &lt;em&gt;e.g.&lt;/em&gt; in JSON, YAML — that are then fed to another system. Like
Nix, it is designed to have a simple, well-understood core: at its
heart, it is JSON with functions.&lt;/p&gt;
&lt;p&gt;But past experience with Nix also brings some insights on which aspects of the
language could be improved. Whatever the initial scope of a language is, it will
almost surely be used in a way that deviates from the original plan: you create
a configuration language to describe software packages, and next thing you know,
somebody needs to implement a &lt;a href=&quot;https://github.com/NixOS/nixpkgs/pull/11484&quot;&gt;topological sort&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Nickel strives to retain the simplicity of Nix, while extending it
according to this feedback.
Though, you can do perfectly fine without the new features and just write Nix-like code.&lt;/p&gt;
&lt;h2&gt;Yet another configuration language&lt;/h2&gt;
&lt;p&gt;At this point you’re probably wondering if this hasn’t already been done elsewhere.
It seems that more and more languages are born every day, and surely there
already exist configuration languages with a similar purpose to Nickel:
&lt;a href=&quot;https://github.com/bazelbuild/starlark&quot;&gt;Starlark&lt;/a&gt;, &lt;a href=&quot;https://jsonnet.org/&quot;&gt;Jsonnet&lt;/a&gt;, &lt;a href=&quot;https://dhall-lang.org/&quot;&gt;Dhall&lt;/a&gt; or &lt;a href=&quot;https://cuelang.org/&quot;&gt;CUE&lt;/a&gt;, to name
a few. So why Nickel?&lt;/p&gt;
&lt;h2&gt;Typing&lt;/h2&gt;
&lt;p&gt;Perhaps the most important difference with other configuration languages is
Nickel’s approach to typing.&lt;/p&gt;
&lt;p&gt;Some languages, such as &lt;a href=&quot;https://jsonnet.org/&quot;&gt;Jsonnet&lt;/a&gt; or &lt;a href=&quot;https://github.com/bazelbuild/starlark&quot;&gt;Starlark&lt;/a&gt;, are not
statically typed. Indeed, static types can be seen as superflous in a configuration
language: if your program is only run once on fixed inputs, any type error will
be reported at run-time anyway. Why bother with a static type system?&lt;/p&gt;
&lt;p&gt;On the other hand, more and more systems rely on complex configurations, such as
cloud infrastructure (&lt;a href=&quot;https://www.terraform.io/&quot;&gt;Terraform&lt;/a&gt;, &lt;a href=&quot;https://kubernetes.io/&quot;&gt;Kubernetes&lt;/a&gt; or
&lt;a href=&quot;https://github.com/NixOS/nixops&quot;&gt;NixOps&lt;/a&gt;), leading the corresponding programs to become increasingly
complex, to the point where static types are beneficial. For reusable code —
that is, library functions — static types add structure, serve as
documentation, and eliminate bugs early.&lt;/p&gt;
&lt;p&gt;Although less common, some configuration languages are statically typed,
including &lt;a href=&quot;https://dhall-lang.org/&quot;&gt;Dhall&lt;/a&gt; and &lt;a href=&quot;https://cuelang.org/&quot;&gt;CUE&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Dhall features a powerful type system that is able to type a wide range of
idioms. But it is complex, requiring some experience to become fluent in.&lt;/p&gt;
&lt;p&gt;CUE is closer to what we are striving for. It has an optional and well-behaved
type system with strong guarantees. In exchange for which, one can’t write nor
type higher-order functions in general, even if some simple functions are
possible to encode.&lt;/p&gt;
&lt;h3&gt;Gradual typing&lt;/h3&gt;
&lt;p&gt;Nickel, features a &lt;a href=&quot;https://en.wikipedia.org/wiki/Gradual_typing&quot;&gt;&lt;em&gt;gradual type system&lt;/em&gt;&lt;/a&gt;.
Gradual types are unobtrusive: they make it possible to statically
type reusable parts of your programs, but you are still free to write
configurations without any types. The
interpreter safely handles the interaction between the typed and untyped worlds.&lt;/p&gt;
&lt;p&gt;Concretely, typed library code like this:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// file: mylib.ncl
{
  numToStr : Num -&amp;gt; Str = fun n =&amp;gt; ...;
  makeURL : Str -&amp;gt; Str -&amp;gt; Num -&amp;gt; Str = fun proto host port =&amp;gt;
    &quot;${proto}://${host}:${numToStr port}/&quot;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;can coexist with untyped configuration code like this:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// file: server.ncl
let mylib = import &quot;mylib.ncl&quot; in
let host = &quot;myproject.com&quot; in
{
  host = host;
  port = 1;
  urls = [
    mylib.makeURL &quot;myproto&quot; host port,
    {protocol = &quot;proto2&quot;; server = &quot;sndserver.net&quot;; port = 4242}
  ];
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the first snippet, the body of &lt;code class=&quot;language-text&quot;&gt;numToStr&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;makeURL&lt;/code&gt; are statically
checked: wrongfully calling &lt;code class=&quot;language-text&quot;&gt;numToStr proto&lt;/code&gt; inside &lt;code class=&quot;language-text&quot;&gt;makeURL&lt;/code&gt; would raise an
error even if &lt;code class=&quot;language-text&quot;&gt;makeURL&lt;/code&gt; is never used. On the other hand, the second snippet is
not annotated, and thus not statically checked. In particular, we mix an URL
represented as a string together with one represented as a record in the same
list. The interpreter rather inserts run-time checks, or &lt;em&gt;contracts&lt;/em&gt;, such
that if &lt;code class=&quot;language-text&quot;&gt;makeURL&lt;/code&gt; is misused then the program fails with an
appropriate error.&lt;/p&gt;
&lt;p&gt;Gradual types also lets us keep the type system simple: even in
statically typed code if you want to write a component that the type
checker doesn’t know how to verify, you don’t have to type-check that
part.&lt;/p&gt;
&lt;h3&gt;Contracts&lt;/h3&gt;
&lt;p&gt;Complementary to the static type system, Nickel offers &lt;em&gt;contracts&lt;/em&gt;. Contracts
offer precise and accurate dynamic type error reporting, even in the
presence of function types. Contracts are used internally by
Nickel’s interpreter to insert guards at the boundary between typed and untyped
chunks. Contracts are available to the programmer as well, to give them the
ability to enforce type assertions at run-time in a simple way.&lt;/p&gt;
&lt;p&gt;One pleasant consequence of this design is that the exposure of the user to the
type system can be progressive:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Users writing configurations can just write Nix-like code while ignoring
(almost) everything about typing, since you can seamlessly call a typed
function from untyped code.&lt;/li&gt;
&lt;li&gt;Users writing consumers or verifiers of these configurations would use
contracts to model data schemas.&lt;/li&gt;
&lt;li&gt;Users writing libraries would instead use the static type
system.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An example of contract is given in the next section.&lt;/p&gt;
&lt;h2&gt;Schemas&lt;/h2&gt;
&lt;p&gt;While the basic computational blocks are functions, the basic data blocks in
Nickel are records (or objects in JSON). Nickel supports writing self-documenting
record schemas, such as:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;{
  host | type: Str
       | description: &quot;The host name of the server.&quot;
       | default: &quot;fallback.myserver.net&quot;
  ;

  port | type: Num
       | description: &quot;The port of the connection.&quot;
       | default: 4242
  ;

  url | type: Url
      | description: &quot;The host name of the server.&quot;
  ;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each field can contain metadata, such as a description or default
value. These aim at being displayed in documentation, or queried by
tools.&lt;/p&gt;
&lt;p&gt;The schema can then be used as a contract. Imagine that a function has
swapped two values in its output and returns:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;{
  host = &quot;myproject.com&quot;,
  port = &quot;myproto://myproject.com:1/&quot;,
  url = 1
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Without types, this is hard to catch. Surely, an error will eventually pop up
downstream in the pipeline, but how and when? Using the schema above
will make sure that, whenever the fields are actually evaluated, the
function will be blamed in the type error.&lt;/p&gt;
&lt;p&gt;Schemas are actually part of a bigger story involving merging records
together, which, in particular, lets the schema instantiate missing
fields with their default values. It is very much inspired by the
&lt;a href=&quot;https://nixos.org/manual/nixos/stable/index.html#sec-configuration-syntax&quot;&gt;NixOs module system&lt;/a&gt; and the &lt;a href=&quot;https://cuelang.org/&quot;&gt;CUE&lt;/a&gt; language, but
it is a story for another time.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I hope that I gave you a sense of what Nickel is trying to achieve. I
only presented its most salient aspects: its gradual type system with
contracts, and built-in record schemas. But there is more to explore!
The language is not ready to be used in real world applications yet, but a good
share of the design presented here is implemented. If you are curious about it,
&lt;a href=&quot;https://www.github.com/tweag/nickel&quot;&gt;check it out&lt;/a&gt;!&lt;/p&gt;</description>
	<pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Sander van der Burg: Transforming Disnix models to graphs and visualizing them</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-6908570302501500296</guid>
	<link>http://sandervanderburg.blogspot.com/2020/10/transforming-disnix-models-to-graphs.html</link>
	<description>In &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/09/assigning-unique-ids-to-services-in.html&quot;&gt;my previous blog post&lt;/a&gt;, I have described a new tool in the Dynamic Disnix toolset that can be used to automatically assign unique numeric IDs to services in a &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/disnix-toolset-for-distributed.html&quot;&gt;Disnix&lt;/a&gt; service model. Unique numeric IDs can represent all kinds of useful resources, such as TCP/UDP port numbers, user IDs (UIDs), and group IDs (GIDs).&lt;br /&gt;&lt;br /&gt;Although I am quite happy to have this tool at my disposal, implementing it was much more difficult and time consuming than I expected. Aside from the fact that the problem is not as obvious as it may sound, the main reason is that the Dynamic Disnix toolset was originally developed as a proof of concept implementation for a research paper under very high time pressure. As a result, it has accumulated quite a bit of &lt;strong&gt;technical debt&lt;/strong&gt;, that as of today, is still at a fairly high level (but much better than it was when I completed the PoC).&lt;br /&gt;&lt;br /&gt;For the ID assigner tool, I needed to make changes to the foundations of the tools, such as the model parsing libraries. As a consequence, all kinds of related aspects in the toolset started to break, such as the deployment planning algorithm implementations.&lt;br /&gt;&lt;br /&gt;Fixing some of these algorithm implementations was much more difficult than I expected -- they were not properly documented, not decomposed into functions, had little to no reuse of common concepts and as a result, were difficult to understand and change. I was forced to re-read the papers that I used as a basis for these algorithms.&lt;br /&gt;&lt;br /&gt;To prevent myself from having to go through such a painful process again, I have decided to &lt;strong&gt;revise&lt;/strong&gt; them in such a way that they are better understandable and maintainable.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Dynamically distributing services&lt;/h2&gt;&lt;br /&gt;The deployment models in the core Disnix toolset are &lt;strong&gt;static&lt;/strong&gt;. For example, the distribution of services to machines in the network is done in a &lt;strong&gt;distribution model&lt;/strong&gt; in which the user has to manually map services in the services model to target machines in the infrastructure model (and optionally to &lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/06/deploying-containers-with-disnix-as.html&quot;&gt;container services&lt;/a&gt; hosted on the target machines).&lt;br /&gt;&lt;br /&gt;Each time a condition changes, e.g. the system needs to scale up or a machine crashes and the system needs to recover, a new distribution model must be configured and the system must be redeployed. For big complex systems that need to be reconfigured frequently, manually specifying new distribution models becomes very impractical.&lt;br /&gt;&lt;br /&gt;As I have already explained in older blog posts, to cope with the limitations of static deployment models (and other static configuration aspects), &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/03/self-adaptive-deployment-with-disnix.html&quot;&gt;I have developed Dynamic Disnix&lt;/a&gt;, in which various configuration aspects can be automated, including the distribution of services to machines.&lt;br /&gt;&lt;br /&gt;A strategy for dynamically distributing services to machines can be specified in a &lt;strong&gt;QoS model&lt;/strong&gt;, that typically consists of two phases:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;First, a &lt;strong&gt;candidate&lt;/strong&gt; target &lt;strong&gt;selection&lt;/strong&gt; must be made, in which for each service the arppropriate candidate target machines are selected.&lt;br /&gt;    &lt;br /&gt;    Not all machines are capable of hosting a certain service for functional and non-functional reasons -- for example, a &lt;i&gt;i686-linux&lt;/i&gt; machine is not capable of running a binary compiled for a &lt;i&gt;x86_64-linux&lt;/i&gt; machine.&lt;br /&gt;    &lt;br /&gt;    A machine can also be exposed to the public internet, and as a result, may not be suitable to host a service that exposes privacy-sensitive information.&lt;/li&gt;  &lt;li&gt;After the suitable candidate target machines are known for each service, we must decide to which candidate machine each service gets &lt;strong&gt;distributed&lt;/strong&gt;.&lt;br /&gt;    &lt;br /&gt;    This can be done in many ways. The strategy that we want to use is typically based on all kinds of non-functional requirements.&lt;br /&gt;    &lt;br /&gt;    For example, we can optimize a system's reliability by minimizing the amount of network links between services, requiring a strategy in which services that depend on each other are mapped to the same machine, as much as possible.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Graph-based optimization problems&lt;/h2&gt;&lt;br /&gt;In the Dynamic Disnix toolset, I have implemented various kinds of distribution algorithms/strategies for all kinds of purposes.&lt;br /&gt;&lt;br /&gt;I did not &quot;invent&quot; most of them -- for some, I got inspiration from papers in the academic literature.&lt;br /&gt;&lt;br /&gt;Two of the more advanced deployment planning algorithms are graph-based, to accomplish the following goals:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;&lt;strong&gt;Reliable deployment&lt;/strong&gt;. Network links are a potential source making a distributed system unreliable -- connections may fail, become slow, or could be interrupted frequently. By minimizing the amount of network links between services (by co-locating them on the same machine), their impact can be reduced. To not make deployments not too expensive, it should be done with a minimal amount of machines.&lt;br /&gt;    &lt;br /&gt;    As described in the paper: &quot;&lt;a href=&quot;https://gsd.uwaterloo.ca/publications/view/266&quot;&gt;Reliable Deployment of Component-based Applications into Distributed Environments&lt;/a&gt;&quot; by A. Heydarnoori and F. Mavaddat, this problem can be transformed into a graph problem: the multiway cut problem (which is &lt;a href=&quot;https://en.wikipedia.org/wiki/NP-hardness&quot;&gt;NP-hard&lt;/a&gt;).&lt;br /&gt;    &lt;br /&gt;    It can only be solved in polynomial time with an approximation algorithm that comes close to the optimal solution, &lt;a href=&quot;https://en.wikipedia.org/wiki/P_versus_NP_problem&quot;&gt;unless a proof that &lt;i&gt;P = NP&lt;/i&gt; exists&lt;/a&gt;.&lt;/li&gt;  &lt;li&gt;&lt;strong&gt;Fragile deployment&lt;/strong&gt;. Inspired by the above deployment problem, I also came up with the opposite problem (as my own &quot;invention&quot;) -- how can we make any connection between a service a true network link (not local), so that we can test a system for robustness, using a minimal amount of machines?&lt;br /&gt;    &lt;br /&gt;    This problem can be modeled as a graph coloring problem (that is a NP-hard problem as well). I used one of approximatation alogithms described in the paper: &quot;&lt;a href=&quot;https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.399.396&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;New Methods to Color the Vertices of a Graph&lt;/a&gt;&quot; by D. Brélaz to implement a solution.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;To work with these graph-based algorithms, I originally did not apply any transformations -- because of time pressure, I directly worked with objects from the Disnix models (e.g. services, target machines) and somewhat &quot;glued&quot; these together with generic data structures, such as lists and hash tables.&lt;br /&gt;&lt;br /&gt;As a result, when looking at the implementation, it is very hard to get an understanding of the process and how an implementation aspect relates to a concept described in the papers shown above.&lt;br /&gt;&lt;br /&gt;In my revised version, I have implemented a &lt;strong&gt;general purpose&lt;/strong&gt; graph library that can be used to solve all kinds of general graph related problems.&lt;br /&gt;&lt;br /&gt;Aside from using a general graph library, I have also separated the graph-based generation processes into the following steps:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;After opening the Disnix input models (such as the services, infrastructure, and distribution models) I &lt;strong&gt;transform&lt;/strong&gt; the models to a graph representing an instance of the problem domain.&lt;/li&gt;  &lt;li&gt;After the graph has been generated, I &lt;strong&gt;apply&lt;/strong&gt; the approximation &lt;strong&gt;algorithm&lt;/strong&gt; to the graph data structure.&lt;/li&gt;  &lt;li&gt;Finally, I &lt;strong&gt;transform&lt;/strong&gt; the resolved graph &lt;strong&gt;back&lt;/strong&gt; to a distribution model that should provide our desired distribution outcome.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;This new organization provides better separation of concerns, common concepts can be reused (such as graph operations), and as a result, the implementations are much closer to the approximation algorithms described in the papers.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Visualizing the generation process&lt;/h2&gt;&lt;br /&gt;Another advantage of having a reusable graph implementation is that we can easily extend it to &lt;strong&gt;visualize&lt;/strong&gt; the problem graphs.&lt;br /&gt;&lt;br /&gt;When I combine these features together with my earlier work that &lt;a href=&quot;https://sandervanderburg.blogspot.com/2019/02/generating-functional-architecture.html&quot;&gt;visualizes services models&lt;/a&gt;, and a new tool that visualizes infrastructure models, I can make the entire generation process transparent.&lt;br /&gt;&lt;br /&gt;For example, the following services model:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{system, pkgs, distribution, invDistribution}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  customPkgs = import ./pkgs { inherit pkgs system; };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  testService1 = {&lt;br /&gt;    name = &quot;testService1&quot;;&lt;br /&gt;    pkg = customPkgs.testService1;&lt;br /&gt;    type = &quot;echo&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  testService2 = {&lt;br /&gt;    name = &quot;testService2&quot;;&lt;br /&gt;    pkg = customPkgs.testService2;&lt;br /&gt;    dependsOn = {&lt;br /&gt;      inherit testService1;&lt;br /&gt;    };&lt;br /&gt;    type = &quot;echo&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  testService3 = {&lt;br /&gt;    name = &quot;testService3&quot;;&lt;br /&gt;    pkg = customPkgs.testService3;&lt;br /&gt;    dependsOn = {&lt;br /&gt;      inherit testService1 testService2;&lt;br /&gt;    };&lt;br /&gt;    type = &quot;echo&quot;;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;can be visualized as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-visualize-services -s services.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-DZodrh7ANOo/X3zZCYfs_CI/AAAAAAAAKnE/cdLxBcW0uBklfyTZW6A339jjT4zEq7nhACLcBGAsYHQ/s0/services.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-DZodrh7ANOo/X3zZCYfs_CI/AAAAAAAAKnE/cdLxBcW0uBklfyTZW6A339jjT4zEq7nhACLcBGAsYHQ/s0/services.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;The above services model and corresponding visualization capture the following properties:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;They describe three &lt;strong&gt;services&lt;/strong&gt; (as denoted by ovals).&lt;/li&gt;  &lt;li&gt;The arrows denote &lt;strong&gt;inter-dependency relationships&lt;/strong&gt; (the &lt;i&gt;dependsOn&lt;/i&gt; attribute in the services model).&lt;br /&gt;    &lt;br /&gt;    When a service has an inter-dependency on another service means that the latter service has to be activated first, and that the dependent service needs to know how to reach the former.&lt;br /&gt;    &lt;br /&gt;    &lt;i&gt;testService2&lt;/i&gt; depends on &lt;i&gt;testService1&lt;/i&gt; and &lt;i&gt;testService3&lt;/i&gt; depends on both the other two services.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;We can also visualize the following infrastructure model:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{&lt;br /&gt;  testtarget1 = {&lt;br /&gt;    properties = {&lt;br /&gt;      hostname = &quot;testtarget1&quot;;&lt;br /&gt;    };&lt;br /&gt;    containers = {&lt;br /&gt;      mysql-database = {&lt;br /&gt;        mysqlPort = 3306;&lt;br /&gt;      };&lt;br /&gt;      echo = {};&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  testtarget2 = {&lt;br /&gt;    properties = {&lt;br /&gt;      hostname = &quot;testtarget2&quot;;&lt;br /&gt;    };&lt;br /&gt;    containers = {&lt;br /&gt;      mysql-database = {&lt;br /&gt;        mysqlPort = 3306;&lt;br /&gt;      };&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  testtarget3 = {&lt;br /&gt;    properties = {&lt;br /&gt;      hostname = &quot;testtarget3&quot;;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;with the following command:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-visualize-infra -i infrastructure.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;resulting in the following visualization:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-75JCRa3nTjI/X3zZIezwY7I/AAAAAAAAKnI/CwvpKQKF4vo4JOJxfSmt5rQrh-uEBy1eACLcBGAsYHQ/s0/infrastructure.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-75JCRa3nTjI/X3zZIezwY7I/AAAAAAAAKnI/CwvpKQKF4vo4JOJxfSmt5rQrh-uEBy1eACLcBGAsYHQ/s0/infrastructure.png&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;The above infrastructure model declares three machines. Each target machine provides a number of container services (such as a MySQL database server, and &lt;i&gt;echo&lt;/i&gt; that acts as a testing container).&lt;br /&gt;&lt;br /&gt;With the following command, we can generate a problem instance for the graph coloring problem using the above services and infrastructure models as inputs:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-graphcol -s services.nix -i infrastructure.nix \&lt;br /&gt;  --output-graph&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;resulting in the following graph:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-K8kNG1TR0oE/X3zZO3f8SfI/AAAAAAAAKnM/vFp8Vu-DEBcoYHFikI1OgBNYmDJ8OKIFgCLcBGAsYHQ/s0/graphcol-instance.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-K8kNG1TR0oE/X3zZO3f8SfI/AAAAAAAAKnM/vFp8Vu-DEBcoYHFikI1OgBNYmDJ8OKIFgCLcBGAsYHQ/s0/graphcol-instance.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;The graph shown above captures the following properties:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Each service translates to a node&lt;/li&gt;  &lt;li&gt;When an inter-dependency relationship exists between services, it gets translated to a (bi-directional) link representing a network connection (the rationale is that a service that has an inter-dependency on another service, interact with each other by using a network connection).&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Each target machine translates to a color, that we can represent with a numeric index -- &lt;i&gt;0&lt;/i&gt; is &lt;i&gt;testtarget1&lt;/i&gt;, &lt;i&gt;1&lt;/i&gt; is &lt;i&gt;testtarget2&lt;/i&gt; and so on.&lt;br /&gt;&lt;br /&gt;The following command generates the resolved problem instance graph in which each vertex has a color assigned:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-graphcol -s services.nix -i infrastructure.nix \&lt;br /&gt;  --output-resolved-graph&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;resulting in the following visualization:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-rHVx-Y5i4ak/X3zaYQ4mbfI/AAAAAAAAKng/yyeewWiz9YIfp11ucd_VICRNsZhd8jCgwCLcBGAsYHQ/s0/graphcol-resolved.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-rHVx-Y5i4ak/X3zaYQ4mbfI/AAAAAAAAKng/yyeewWiz9YIfp11ucd_VICRNsZhd8jCgwCLcBGAsYHQ/s0/graphcol-resolved.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;(As a sidenote: in the above graph, colors are represented by numbers. In theory, I could also use real colors, but if I also want that the graph to remain visually appealing, I need to solve a color picking problem, which is beyond the scope of my refactoring objective).&lt;br /&gt;&lt;br /&gt;The resolved graph can be translated back into the following distribution model:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-graphcol -s services.nix -i infrastructure.nix&lt;br /&gt;{&lt;br /&gt;  &quot;testService2&quot; = [&lt;br /&gt;    &quot;testtarget2&quot;&lt;br /&gt;  ];&lt;br /&gt;  &quot;testService1&quot; = [&lt;br /&gt;    &quot;testtarget1&quot;&lt;br /&gt;  ];&lt;br /&gt;  &quot;testService3&quot; = [&lt;br /&gt;    &quot;testtarget3&quot;&lt;br /&gt;  ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As you may notice, every service is distributed to a separate machine, so that every network link between a service is a real network connection between machines.&lt;br /&gt;&lt;br /&gt;We can also visualize the problem instance of the multiway cut problem. For this, we also need a distribution model that, declares for each service, which target machine is a candidate.&lt;br /&gt;&lt;br /&gt;The following distribution model makes all three target machines in the infrastructure model a candidate for every service:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{infrastructure}:&lt;br /&gt;&lt;br /&gt;{&lt;br /&gt;  testService1 = [ infrastructure.testtarget1 infrastructure.testtarget2 infrastructure.testtarget3 ];&lt;br /&gt;  testService2 = [ infrastructure.testtarget1 infrastructure.testtarget2 infrastructure.testtarget3 ];&lt;br /&gt;  testService3 = [ infrastructure.testtarget1 infrastructure.testtarget2 infrastructure.testtarget3 ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;With the following command we can generate a problem instance representing a host-application graph:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-multiwaycut -s services.nix -i infrastructure.nix \&lt;br /&gt;  -d distribution.nix --output-graph&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;providing me the following output:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-L402YdmM3E0/X315yEtOPnI/AAAAAAAAKoM/Mvt93ilHTQcy6liZx0rOihGufbNsbr3uACLcBGAsYHQ/s0/multiwaycut-instance.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-L402YdmM3E0/X315yEtOPnI/AAAAAAAAKoM/Mvt93ilHTQcy6liZx0rOihGufbNsbr3uACLcBGAsYHQ/s0/multiwaycut-instance.png&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;The above problem graph has the following properties:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Each service translates to an &lt;strong&gt;app node&lt;/strong&gt; (prefixed with &lt;i&gt;app:&lt;/i&gt;) and each candidate target machine to a &lt;strong&gt;host node&lt;/strong&gt; (prefixed with &lt;i&gt;host:&lt;/i&gt;).&lt;/li&gt;  &lt;li&gt;When a network connection between two services exists (implicitly derived from having an inter-dependency relationship), an edge is generated with a weight of &lt;i&gt;1&lt;/i&gt;.&lt;/li&gt;  &lt;li&gt;When a target machine is a candidate target for a service, then an edge is generated with a weight of &lt;i&gt;n&lt;sup&gt;2&lt;/sup&gt;&lt;/i&gt; representing a very large number.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The objective of solving the multiway cut problem is to cut edges in the graph in such a way that each terminal (host node) is disconnected from the other terminals (host nodes), in which the total weight of the cuts is minimized.&lt;br /&gt;&lt;br /&gt;When applying the approximation algorithm in the paper to the above graph:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-multiwaycut -s services.nix -i infrastructure.nix \&lt;br /&gt;  -d distribution.nix --output-resolved-graph&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;we get the following resolved graph:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-LiThHTYMe0c/X32E2yfLfTI/AAAAAAAAKoY/aZvzrtWlhHc0q_IM01BLAB3-BEkArfwzQCLcBGAsYHQ/s0/multiwaycut-resolved.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-LiThHTYMe0c/X32E2yfLfTI/AAAAAAAAKoY/aZvzrtWlhHc0q_IM01BLAB3-BEkArfwzQCLcBGAsYHQ/s0/multiwaycut-resolved.png&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;that can be transformed back into the following distribution model:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix-multiwaycut -s services.nix -i infrastructure.nix \&lt;br /&gt;  -d distribution.nix&lt;br /&gt;{&lt;br /&gt;  &quot;testService2&quot; = [&lt;br /&gt;    &quot;testtarget1&quot;&lt;br /&gt;  ];&lt;br /&gt;  &quot;testService1&quot; = [&lt;br /&gt;    &quot;testtarget1&quot;&lt;br /&gt;  ];&lt;br /&gt;  &quot;testService3&quot; = [&lt;br /&gt;    &quot;testtarget1&quot;&lt;br /&gt;  ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As you may notice by looking at the resolved graph (in which the terminals: &lt;i&gt;testtarget2&lt;/i&gt; and &lt;i&gt;testtarget3&lt;/i&gt; are disconnected) and the distribution model output, all services are distributed to the same machine: &lt;i&gt;testtarget1&lt;/i&gt; making all connections between the services local connections.&lt;br /&gt;&lt;br /&gt;In this particular case, the solution is not only close to the optimal solution, but it is the optimal solution.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;br /&gt;In this blog post, I have described how I have revised the deployment planning algorithm implementations in the Dynamic Disnix toolset. Their concerns are now much better separated, and the graph-based algorithms now use a general purpose graph library, that can also be used for generating visualizations of the intermediate steps in the generation process.&lt;br /&gt;&lt;br /&gt;This revision was not on my short-term planned features list, but I am happy that I did the work. Retrospectively, I regret that I never took the time to finish things up properly after the submission of the paper. Although Dynamic Disnix's quality is still not where I want it to be, it is quite a step forward in making the toolset more usable.&lt;br /&gt;&lt;br /&gt;Sadly, it is almost 10 years ago that I started Dynamic Disnix and still there is no offical release yet and the technical debt in Dynamic Disnix is one of the important reasons that I never did an official release. Hopefully, with this step I can do it some day. :-)&lt;br /&gt;&lt;br /&gt;The good news is that I made the paper submission deadline and that the paper got accepted for presentation. It brought me to the &lt;a href=&quot;https://www.hpi.uni-potsdam.de/giese/public/selfadapt/seams/&quot;&gt;SEAMS 2011&lt;/a&gt; conference (co-located with &lt;a href=&quot;http://2011.icse-conferences.org/&quot;&gt;ICSE 2011&lt;/a&gt;) in Honolulu, Hawaii, allowing me to take pictures such as this one:&lt;br /&gt;&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-9K_pKO-lE2M/X34OOw5OexI/AAAAAAAAKoo/DS1vombgdCEQBokxPDJbvq4ibrs5PStxwCLcBGAsYHQ/s2048/P1040527.JPG&quot; style=&quot;display: block; padding: 1em 0; text-align: center;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-9K_pKO-lE2M/X34OOw5OexI/AAAAAAAAKoo/DS1vombgdCEQBokxPDJbvq4ibrs5PStxwCLcBGAsYHQ/s600/P1040527.JPG&quot; width=&quot;520&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;&lt;h2&gt;Availability&lt;/h2&gt;&lt;br /&gt;The graph library and new implementations of the deployment planning algorithms described in this blog post are part of the current development version of &lt;a href=&quot;https://github.com/svanderburg/dydisnix&quot;&gt;Dynamic Disnix&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;The paper: &quot;A Self-Adaptive Deployment Framework for Service-Oriented Systems&quot; describes the Dynamic Disnix framework (developed 9 years ago) and can be obtained from &lt;a href=&quot;http://sandervanderburg.nl/index.php/publications&quot;&gt;my publications&lt;/a&gt; page.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Acknowledgements&lt;/h2&gt;&lt;br /&gt;To generate the visualizations I used the &lt;a href=&quot;https://graphviz.org/&quot;&gt;Graphviz&lt;/a&gt; toolset.&lt;br /&gt;&lt;br /&gt;</description>
	<pubDate>Thu, 08 Oct 2020 21:29:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Cachix: Changes to Garbage Collection</title>
	<guid isPermaLink="true">https://blog.cachix.org/posts/2020-10-01-changes-to-garbage-collection/</guid>
	<link>https://blog.cachix.org/posts/2020-10-01-changes-to-garbage-collection/</link>
	<description>Based on your feedback, I have made the following two changes:
  When downloading &amp;lt;store-hash&amp;gt;.narinfo the timestamp of last access is updated, previously this would happen only with nar archives.
This change allows tools like nix-build-uncached to prevent unneeded downloads and playing nicely with Cachix garbage collection algorithm!
  Previously, the algorithm ordered paths first by last accessed timestamp and then by creation timestamp.
That worked well until you had all entries with last accessed and all newly created store paths will get deleted first.</description>
	<pubDate>Thu, 01 Oct 2020 09:00:00 +0000</pubDate>
	<author>support@cachix.org (Domen Kožar)</author>
</item>
<item>
	<title>Tweag I/O: Fully statically linked Haskell binaries with Bazel</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-09-30-bazel-static-haskell/</guid>
	<link>https://tweag.io/blog/2020-09-30-bazel-static-haskell/</link>
	<description>&lt;p&gt;Deploying and packaging Haskell applications can be challenging at times, and
runtime library dependencies are one reason for this. Statically linked
binaries have no such dependencies and are therefore easier to deploy. They
can also be quicker to start, since no dynamic loading is needed. In exchange,
all used symbols must be bundled into the application, which may lead to larger
artifacts.&lt;/p&gt;
&lt;p&gt;Thanks to the contribution of Will Jones of &lt;a href=&quot;https://www.habito.com/&quot;&gt;Habito&lt;/a&gt;&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a class=&quot;footnote-ref&quot; href=&quot;https://www.tweag.io/rss-nix.xml#fn-1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;,
&lt;a href=&quot;https://github.com/tweag/rules_haskell&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt;&lt;/a&gt;, the Haskell &lt;a href=&quot;https://bazel.build&quot;&gt;Bazel&lt;/a&gt; extension, has
&lt;a href=&quot;https://github.com/tweag/rules_haskell/pull/1390&quot;&gt;gained support&lt;/a&gt; for fully static linking of Haskell
binaries.&lt;/p&gt;
&lt;p&gt;Habito uses Bazel to develop, build, test and deploy Haskell code in a minimal
Docker container. By building fully-statically-linked binaries, Docker
packaging (using &lt;a href=&quot;https://github.com/bazelbuild/rules_docker&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;rules_docker&lt;/code&gt;&lt;/a&gt;) becomes straightforward and
easy to integrate into existing build workflows. A static binary can also be
&lt;code class=&quot;language-text&quot;&gt;strip&lt;/code&gt;ped once it is built to reduce the size of production artifacts. With
static binaries, what you see (just the binary) is what you get, and this is
powerful.&lt;/p&gt;
&lt;p&gt;In the following, we will discuss the technical challenges of statically
linking Haskell binaries and how these challenges are addressed in
&lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt;. Spoiler alert: Nix is an important part of the solution.
Finally, we will show you how you can create your own fully statically linked
Haskell binaries with Bazel and Nix.&lt;/p&gt;
&lt;h2&gt;Technical challenges&lt;/h2&gt;
&lt;p&gt;Creating fully statically linked Haskell binaries is not without challenges.
The main difficulties for doing so are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Not all library dependencies are suited for statically linked binaries.&lt;/li&gt;
&lt;li&gt;Compiling template Haskell requires dynamic libraries on Linux by default.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Library dependencies&lt;/h3&gt;
&lt;p&gt;Like most binaries on Linux, the Haskell compiler GHC is typically configured to
link against the &lt;a href=&quot;https://www.gnu.org/software/libc/&quot;&gt;GNU C library &lt;code class=&quot;language-text&quot;&gt;glibc&lt;/code&gt;&lt;/a&gt;. However, &lt;code class=&quot;language-text&quot;&gt;glibc&lt;/code&gt; is not
designed to support fully static linking and explicitly &lt;a href=&quot;https://sourceware.org/glibc/wiki/FAQ#Even_statically_linked_programs_need_some_shared_libraries_which_is_not_acceptable_for_me.__What_can_I_do.3F&quot;&gt;depends on dynamic
linking&lt;/a&gt; in some use cases. The alternative C library
&lt;a href=&quot;https://musl.libc.org/about.html&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;musl&lt;/code&gt;&lt;/a&gt; is designed to support fully static linking.&lt;/p&gt;
&lt;p&gt;Relatedly, there may be licensing reasons to not link some libraries
statically. Common instances in the Haskell ecosystem are again &lt;code class=&quot;language-text&quot;&gt;glibc&lt;/code&gt; which
is licensed under GPL, and the core Haskell dependency &lt;code class=&quot;language-text&quot;&gt;libgmp&lt;/code&gt; which is
licensed under LGPL. For the latter GHC can be configured to use the core
package &lt;code class=&quot;language-text&quot;&gt;integer-simple&lt;/code&gt; instead of &lt;code class=&quot;language-text&quot;&gt;integer-gmp&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Fortunately, the Nix community has made &lt;a href=&quot;https://github.com/NixOS/nixpkgs/issues/43795&quot;&gt;great
progress&lt;/a&gt; towards fully statically linked Haskell
binaries and we can build on much of this work in &lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt;. The
&lt;a href=&quot;https://github.com/tweag/rules_nixpkgs&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;rules_nixpkgs&lt;/code&gt;&lt;/a&gt; extension makes it possible to import Nix derivations
into a Bazel project, and &lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt; has first class support for
Nix-provided GHC toolchains using &lt;code class=&quot;language-text&quot;&gt;rules_nixpkgs&lt;/code&gt; under the hood. In
particular, it can import a GHC toolchain based on &lt;code class=&quot;language-text&quot;&gt;musl&lt;/code&gt; from
&lt;a href=&quot;https://github.com/nh2/static-haskell-nix&quot;&gt;static-haskell-nix&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Template Haskell&lt;/h3&gt;
&lt;p&gt;By default GHC is configured to require dynamic libraries when compiling
template Haskell. GHC’s runtime system (RTS) can be built in various
combinations of so called &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/compiler-ways&quot;&gt;ways&lt;/a&gt;. The relevant way in this context is
called &lt;em&gt;dynamic&lt;/em&gt;. On Linux, GHC itself is built with a dynamic RTS. However,
statically linked code is targeting a non-dynamic RTS. This may sound familiar
if you ever tried to compile code using template Haskell in profiling mode. As
the &lt;a href=&quot;https://downloads.haskell.org/ghc/8.10.1/docs/html/users_guide/glasgow_exts.html#using-template-haskell-with-profiling&quot;&gt;GHC user guide&lt;/a&gt; points out, when evaluating template Haskell
splices, GHC will execute compiled expressions in its built-in bytecode
interpreter and this code has to be compatible with the RTS of GHC itself. In
short, a GHC configured with a dynamic RTS will not be able to load static
Haskell libraries to evaluate template Haskell splices.&lt;/p&gt;
&lt;p&gt;One way to solve this issue is to compile all Haskell libraries twice, once
with dynamic linking and once with static linking. C library dependencies will
similarly need to be available in both static and dynamic forms. This is the
approach taken by &lt;code class=&quot;language-text&quot;&gt;static-haskell-nix&lt;/code&gt;. However, in the context of Bazel we
found it preferable to only compile Haskell libraries once in static form and
also only have to provide C libraries in static form. To achieve this we need
to build GHC with a static RTS and to make sure that Haskell code is
compiled as position independent code so that it can be loaded into a running
GHC for template Haskell splices. Thanks to Nix, it is easy to override the GHC
derivation to include the necessary configuration.&lt;/p&gt;
&lt;h2&gt;Make your project fully statically linked&lt;/h2&gt;
&lt;p&gt;How can you benefit from this? In this section we will show how you can setup a
Bazel Haskell project for fully static linking with Nix. For further details
please refer to the corresponding documentation on
&lt;a href=&quot;https://rules-haskell.readthedocs.io/en/latest/haskell-use-cases.html#building-fully-statically-linked-binaries&quot;&gt;haskell.build&lt;/a&gt;. A fully working example repository is
available &lt;a href=&quot;https://github.com/lunaris/minirepo&quot;&gt;here&lt;/a&gt;. For a primer on setting up a Bazel Haskell project
take a look at &lt;a href=&quot;https://www.tweag.io/blog/2020-05-06-convert-haskell-project-to-bazel/&quot;&gt;this tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;First, you need to configure a Nixpkgs repository that defines a GHC toolchain
for fully static linking based on musl. We start by pulling in a base Nixpkgs
revision and the &lt;code class=&quot;language-text&quot;&gt;static-haskell-nix&lt;/code&gt; project. Create a &lt;code class=&quot;language-text&quot;&gt;default.nix&lt;/code&gt;,
with the following.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt;
  baseNixpkgs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;builtins&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fetchTarball&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;nixos-nixpkgs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    url &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;https://github.com/NixOS/nixpkgs/archive/dca182df882db483cea5bb0115fea82304157ba1.tar.gz&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    sha256 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;0193bpsg1ssr93ihndyv7shz6ivsm8cvaxxl72mc7vfb8d1bwx55&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  staticHaskellNixpkgs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;builtins&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fetchTarball&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;https://github.com/nh2/static-haskell-nix/archive/dbce18f4808d27f6a51ce31585078b49c86bd2b5.tar.gz&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then we import a Haskell package set based on &lt;code class=&quot;language-text&quot;&gt;musl&lt;/code&gt; from &lt;code class=&quot;language-text&quot;&gt;static-haskell-nix&lt;/code&gt;.
The package set provides GHC and various Haskell packages. However, we will
only use the GHC compiler and use Bazel to build other Haskell packages.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt;
  staticHaskellPkgs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;staticHaskellNixpkgs &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;/survey/default.nix&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;approachPkgs&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next we define a Nixpkgs &lt;a href=&quot;https://nixos.org/nixpkgs/manual/#chap-overlays&quot;&gt;overlay&lt;/a&gt; that introduces a GHC based
on &lt;code class=&quot;language-text&quot;&gt;musl&lt;/code&gt; that is configured to use a static runtime system and core packages
built with position independent code so that they can be loaded for template
Haskell.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt;
  overlay &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; super&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    staticHaskell &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; staticHaskellPkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;extend &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;selfSH&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; superSH&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      ghc &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;superSH&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;ghc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;override &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        enableRelocatedStaticLibs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        enableShared &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;overrideAttrs &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldAttrs&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        preConfigure &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;''
          &lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token antiquotation variable&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;oldAttrs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;preConfigure &lt;span class=&quot;token keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
          echo &quot;GhcLibHcOpts += -fPIC -fexternal-dynamic-refs&quot; &amp;gt;&amp;gt; mk/build.mk
          echo &quot;GhcRtsHcOpts += -fPIC -fexternal-dynamic-refs&quot; &amp;gt;&amp;gt; mk/build.mk
        ''&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, we extend the base Nixpkgs revision with the overlay. This makes the
newly configured GHC available under the Nix attribute path
&lt;code class=&quot;language-text&quot;&gt;staticHaskell.ghc&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;  args&lt;span class=&quot;token operator&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; overlays &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;import&lt;/span&gt; baseNixpkgs &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;args &lt;span class=&quot;token operator&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      overlays &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;overlay&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt; overlays&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This concludes the Nix part of the setup and we can move on to the Bazel part.&lt;/p&gt;
&lt;p&gt;You can import this Nixpkgs repository into Bazel by adding the following lines
to your &lt;code class=&quot;language-text&quot;&gt;WORKSPACE&lt;/code&gt; file.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;load&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;@io_tweag_rules_nixpkgs//nixpkgs:nixpkgs.bzl&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;nixpkgs_local_repository&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
nixpkgs_local_repository&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;nixpkgs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    nix_file &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;default.nix&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now you can define a GHC toolchain for &lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt; that uses the Nix built
GHC defined above. Note how we declare that this toolchain has a static RTS and
is configured for fully static linking. Add the following lines to your
&lt;code class=&quot;language-text&quot;&gt;WORKSPACE&lt;/code&gt; file.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;load&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;@rules_haskell//haskell:nixpkgs.bzl&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;haskell_register_ghc_nixpkgs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
haskell_register_ghc_nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    version &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;X.Y.Z&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;# Make sure this matches the GHC version.&lt;/span&gt;
    attribute_path &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;staticHaskell.ghc&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    repositories &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;nixpkgs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;@nixpkgs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    static_runtime &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    fully_static_link &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GHC relies on the C compiler and linker during compilation. &lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt;
will always use the C compiler and linker provided by the active Bazel C
toolchain. We need to make sure that we use a musl-based C toolchain as well.
Here we will use the same Nix-provided C toolchain that is used by
static-haskell-nix to build GHC.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;load&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;@io_tweag_rules_nixpkgs//nixpkgs:nixpkgs.bzl&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;nixpkgs_cc_configure&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
nixpkgs_cc_configure&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    repository &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;@nixpkgs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    nix_file_content &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token triple-quoted-string string&quot;&gt;&quot;&quot;&quot;
      with import &amp;lt;nixpkgs&amp;gt; { config = {}; overlays = []; }; buildEnv {
        name = &quot;bazel-cc-toolchain&quot;;
        paths = [ staticHaskell.stdenv.cc staticHaskell.binutils ];
      }
    &quot;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, everything is configured for fully static linking. You can define a
Bazel target for a fully statically linked Haskell binary as follows.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;haskell_binary&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
    name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;example&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    srcs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Main.hs&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    features &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;fully_static_link&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can build your binary and confirm that it is fully statically linked as follows.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ bazel build //:example
$ ldd bazel-bin/example
      not a dynamic executable&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;If you’re interested in further exploring the benefits of fully statically linked
binaries, you might &lt;a href=&quot;https://rules-haskell.readthedocs.io/en/latest/haskell-use-cases.html#containerization-with-rules-docker&quot;&gt;combine them with &lt;code class=&quot;language-text&quot;&gt;rules_docker&lt;/code&gt;&lt;/a&gt; (e.g. through its
&lt;code class=&quot;language-text&quot;&gt;container_image&lt;/code&gt; rule) to build Docker images as Habito have done. With
a rich enough set of Bazel rules and dependency specifications, it’s possible
to reduce your build and deployment workflow to a &lt;code class=&quot;language-text&quot;&gt;bazel test&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;bazel run&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;The current implementation depends on a Nix-provided GHC toolchain capable of
fully static linking that is imported into Bazel using &lt;code class=&quot;language-text&quot;&gt;rules_nixpkgs&lt;/code&gt;.
However, there is no reason why it shouldn’t be possible to use a GHC
distribution capable of fully static linking that was provided by other means,
for example a Docker image such as &lt;a href=&quot;https://github.com/utdemir/ghc-musl&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;ghc-musl&lt;/code&gt;&lt;/a&gt;. Get in touch if you
would like to create fully statically linked Haskell binaries with Bazel but
can’t or don’t want to integrate Nix into your build. Contributions are
welcome!&lt;/p&gt;
&lt;p&gt;We thank Habito for their contributions to &lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;  &lt;a href=&quot;https://www.habito.com/&quot;&gt;Habito&lt;/a&gt; is fixing mortgages and making homebuying fit for the
future. Habito gives people tools, jargon-free knowledge and expert support
to help them buy and finance their homes. Built on a rich foundation of
functional programming and other cutting-edge technology, Habito is a long
time user of and contributor to &lt;code class=&quot;language-text&quot;&gt;rules_haskell&lt;/code&gt;.&lt;/p&gt;
&lt;a class=&quot;footnote-backref&quot; href=&quot;https://www.tweag.io/rss-nix.xml#fnref-1&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
	<pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Sander van der Burg: Assigning unique IDs to services in Disnix deployment models</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-1266939232103509859</guid>
	<link>http://sandervanderburg.blogspot.com/2020/09/assigning-unique-ids-to-services-in.html</link>
	<description>As described in some of my recent blog posts, one of the more advanced features of &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/disnix-toolset-for-distributed.html&quot;&gt;Disnix&lt;/a&gt; as well as &lt;a href=&quot;https://sandervanderburg.blogspot.com/2019/11/a-nix-based-functional-organization-for.html&quot;&gt;the experimental Nix process management&lt;/a&gt; framework is to deploy &lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/06/deploying-containers-with-disnix-as.html&quot;&gt;&lt;strong&gt;multiple instances&lt;/strong&gt;&lt;/a&gt; of the same service to the same machine.&lt;br /&gt;&lt;br /&gt;To make running multiple service instances on the same machine possible, these tools rely on &lt;strong&gt;conflict avoidance&lt;/strong&gt; rather than isolation (typically used for &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/07/on-using-nix-and-docker-as-deployment.html&quot;&gt;containers&lt;/a&gt;). To allow multiple services instances to co-exist on the same machine, they need to be configured in such a way that they do not allocate any conflicting resources.&lt;br /&gt;&lt;br /&gt;Although for small systems it is doable to configure multiple instances by hand, this process gets tedious and time consuming for larger and more technologically diverse systems.&lt;br /&gt;&lt;br /&gt;One particular kind of conflicting resource that could be configured automatically are &lt;strong&gt;numeric IDs&lt;/strong&gt;, such as TCP/UDP port numbers, user IDs (UIDs), and group IDs (GIDs).&lt;br /&gt;&lt;br /&gt;In this blog post, I will describe how multiple service instances are configured (in Disnix and the process management framework) and how we can automatically assign unique numeric IDs to them.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Configuring multiple service instances&lt;/h2&gt;&lt;br /&gt;To facilitate conflict avoidance in Disnix and the Nix process management framework, services are configured as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{createManagedProcess, tmpDir}:&lt;br /&gt;{port, instanceSuffix ? &quot;&quot;, instanceName ? &quot;webapp${instanceSuffix}&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  webapp = import ../../webapp;&lt;br /&gt;in&lt;br /&gt;createManagedProcess {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  description = &quot;Simple web application&quot;;&lt;br /&gt;  inherit instanceName;&lt;br /&gt;&lt;br /&gt;  # This expression can both run in foreground or daemon mode.&lt;br /&gt;  # The process manager can pick which mode it prefers.&lt;br /&gt;  process = &quot;${webapp}/bin/webapp&quot;;&lt;br /&gt;  daemonArgs = [ &quot;-D&quot; ];&lt;br /&gt;&lt;br /&gt;  environment = {&lt;br /&gt;    PORT = port;&lt;br /&gt;    PID_FILE = &quot;${tmpDir}/${instanceName}.pid&quot;;&lt;br /&gt;  };&lt;br /&gt;  user = instanceName;&lt;br /&gt;  credentials = {&lt;br /&gt;    groups = {&lt;br /&gt;      &quot;${instanceName}&quot; = {};&lt;br /&gt;    };&lt;br /&gt;    users = {&lt;br /&gt;      &quot;${instanceName}&quot; = {&lt;br /&gt;        group = instanceName;&lt;br /&gt;        description = &quot;Webapp&quot;;&lt;br /&gt;      };&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  overrides = {&lt;br /&gt;    sysvinit = {&lt;br /&gt;      runlevels = [ 3 4 5 ];&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The Nix expression shown above is a nested function that describes how to deploy a simple self-contained REST web application with an embedded HTTP server:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The &lt;strong&gt;outer function header&lt;/strong&gt; (first line) specifies all common build-time dependencies and configuration properties that the service needs:&lt;br /&gt;    &lt;br /&gt;    &lt;ul&gt;      &lt;li&gt;&lt;i&gt;createManagedProcess&lt;/i&gt; is a function that can be used to &lt;a href=&quot;https://sandervanderburg.blogspot.com/2019/11/a-nix-based-functional-organization-for.html&quot;&gt;define process manager agnostic configurations&lt;/a&gt; that can be translated to configuration files for a variety of process managers (e.g. &lt;i&gt;systemd&lt;/i&gt;, &lt;i&gt;launchd&lt;/i&gt;, &lt;i&gt;supervisord&lt;/i&gt; etc.).&lt;/li&gt;      &lt;li&gt;&lt;i&gt;tmpDir&lt;/i&gt; refers to the temp directory in which temp files are stored.&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;  &lt;li&gt;The &lt;strong&gt;inner function header&lt;/strong&gt; (second line) specifies all instance parameters -- these are the parameters that must be configured in such a way that conflicts with other process instances are avoided:&lt;br /&gt;    &lt;br /&gt;    &lt;ul&gt;      &lt;li&gt;The &lt;i&gt;instanceName&lt;/i&gt; parameter (that can be derived from the &lt;i&gt;instanceSuffix&lt;/i&gt;) is a value used by some of the process management backends (e.g. the ones that invoke the &lt;i&gt;daemon&lt;/i&gt; command) to derive a unique PID file for the process. When running multiple instances of the same process, each of them requires a unique PID file name.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;port&lt;/i&gt; parameter specifies to which TCP port the service binds to. Binding the service to a port that is already taken by another service, causes the deployment of this service to fail.&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;  &lt;li&gt;    In the function &lt;strong&gt;body&lt;/strong&gt;, we invoke the &lt;i&gt;createManagedProcess&lt;/i&gt; function to construct configuration files for all supported process manager backends to run the &lt;i&gt;webapp&lt;/i&gt; process:&lt;br /&gt;    &lt;br /&gt;    &lt;ul&gt;      &lt;li&gt;As explained earlier, the &lt;i&gt;instanceName&lt;/i&gt; is used to configure the &lt;i&gt;daemon&lt;/i&gt; executable in such a way that it allocates a unique PID file.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;process&lt;/i&gt; parameter specifies which executable we need to run, both as a foreground process or daemon.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;daemonArgs&lt;/i&gt; parameter specifies which command-line parameters need to be propagated to the executable when the process should &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/01/writing-well-behaving-daemon-in-c.html&quot;&gt;daemonize on its own&lt;/a&gt;.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;environment&lt;/i&gt; parameter specifies all environment variables. The &lt;i&gt;webapp&lt;/i&gt; service uses these variables for runtime property configuration.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;user&lt;/i&gt; parameter is used to specify that the process should run as an unprivileged user. The &lt;i&gt;credentials&lt;/i&gt; parameter is used to configure the creation of the user account and corresponding user group.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;overrides&lt;/i&gt; parameter is used to override the process manager-agnostic parameters with process manager-specific parameters. For the &lt;i&gt;sysvinit&lt;/i&gt; backend, we configure the runlevels in which the service should run.&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Although the convention shown above makes it possible to avoid conflicts (assuming that all potential conflicts have been identified and exposed as function parameters), these parameters are typically configured manually:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{ pkgs, system&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;sysvinit&quot;&lt;br /&gt;, ...&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  processType = import ../../nixproc/derive-dysnomia-process-type.nix {&lt;br /&gt;    inherit processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp1 = rec {&lt;br /&gt;    name = &quot;webapp1&quot;;&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;1&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  webapp2 = rec {&lt;br /&gt;    name = &quot;webapp2&quot;;&lt;br /&gt;    port = 5001;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;2&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression shows both a valid Disnix &lt;strong&gt;services&lt;/strong&gt; as well as a valid &lt;strong&gt;processes&lt;/strong&gt; model that composes two web application process instances that can run concurrently on the same machine by invoking the nested constructor function shown in the previous example:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Each &lt;i&gt;webapp&lt;/i&gt; instance has its own unique instance name, by specifying a unique numeric &lt;i&gt;instanceSuffix&lt;/i&gt; that gets appended to the service name.&lt;/li&gt;  &lt;li&gt;Every &lt;i&gt;webapp&lt;/i&gt; instance binds to a unique TCP port (5000 and 5001) that should not conflict with system services or other process instances.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Previous work: assigning port numbers&lt;/h2&gt;&lt;br /&gt;Although configuring two process instances is still manageable, the configuration process becomes more tedious and time consuming when the amount and the kind of processes (each having their own potential conflicts) grow.&lt;br /&gt;&lt;br /&gt;Five years ago, I already identified a resource that could be automatically assigned to services: &lt;strong&gt;port numbers&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;I have created &lt;a href=&quot;https://sandervanderburg.blogspot.com/2015/07/assigning-port-numbers-to-microservices.html&quot;&gt;a very simple port assigner tool&lt;/a&gt; that allows you to specify a global ports pool and a target-specific pool pool. The former is used to assign globally unique port numbers to all services in the network, whereas the latter assigns port numbers that are unique to the target machine where the service is deployed to (this is to cope with the scarcity of port numbers).&lt;br /&gt;&lt;br /&gt;Although the tool is quite useful for systems that do not consist of too many different kinds of components, I ran into a number limitations when I want to manage a more diverse set of services:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Port numbers are not the only numeric IDs that services may require. When deploying systems that consist of self-contained executables, you typically want to run them as unprivileged users for security reasons. User accounts on most UNIX-like systems require unique &lt;strong&gt;user IDs&lt;/strong&gt;, and the corresponding users' groups require unique &lt;strong&gt;group IDs&lt;/strong&gt;.&lt;/li&gt;  &lt;li&gt;We typically want to manage &lt;strong&gt;multiple&lt;/strong&gt; resource &lt;strong&gt;pools&lt;/strong&gt;, for a variety of reasons. For example, when we have a number of HTTP server instances and a number of database instances, then we may want to pick port numbers in the 8000-9000 range for the HTTP servers, whereas for the database servers we want to use a different pool, such as 5000-6000.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Assigning unique numeric IDs&lt;/h2&gt;&lt;br /&gt;To address these shortcomings, I have developed a replacement tool that acts as a generic numeric ID assigner.&lt;br /&gt;&lt;br /&gt;This new ID assigner tool works with ID &lt;strong&gt;resource configuration&lt;/strong&gt; files, such as:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;rec {&lt;br /&gt;  ports = {&lt;br /&gt;    min = 5000;&lt;br /&gt;    max = 6000;&lt;br /&gt;    scope = &quot;global&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  uids = {&lt;br /&gt;    min = 2000;&lt;br /&gt;    max = 3000;&lt;br /&gt;    scope = &quot;global&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  gids = uids;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above ID resource configuration file (&lt;i&gt;idresources.nix&lt;/i&gt;) defines three resource pools: &lt;i&gt;ports&lt;/i&gt; is a resource that represents port numbers to be assigned to the webapp processes, &lt;i&gt;uids&lt;/i&gt; refers to user IDs and &lt;i&gt;gids&lt;/i&gt; to group IDs. The group IDs' resource configuration is identical to the users' IDs configuration.&lt;br /&gt;&lt;br /&gt;Each resource attribute refers the following configuration properties:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The &lt;i&gt;min&lt;/i&gt; value specifies the &lt;strong&gt;minimum&lt;/strong&gt; ID to hand out, &lt;i&gt;max&lt;/i&gt; the &lt;strong&gt;maximum&lt;/strong&gt; ID.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;scope&lt;/i&gt; value specifies the &lt;strong&gt;scope&lt;/strong&gt; of the resource pool. &lt;i&gt;global&lt;/i&gt; (which is the default option) means that the IDs assigned from this resource pool to services are globally unique for the entire system.&lt;br /&gt;    &lt;br /&gt;    The &lt;i&gt;machine&lt;/i&gt; scope can be used to assign IDs that are unique for the machine where a service is distributed to. When the latter option is used, services that are distributed two separate machines may have the same ID.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;We can adjust the services/processes model in such a way that every service will use dynamically assigned IDs and that each service specifies for which resources it requires a unique ID:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{ pkgs, system&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;sysvinit&quot;&lt;br /&gt;, ...&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  ids = if builtins.pathExists ./ids.nix then (import ./ids.nix).ids else {};&lt;br /&gt;&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir forceDisableUserChange processManager ids;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  processType = import ../../nixproc/derive-dysnomia-process-type.nix {&lt;br /&gt;    inherit processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp1 = rec {&lt;br /&gt;    name = &quot;webapp1&quot;;&lt;br /&gt;    port = ids.ports.webapp1 or 0;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;1&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;ports&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  webapp2 = rec {&lt;br /&gt;    name = &quot;webapp2&quot;;&lt;br /&gt;    port = ids.ports.webapp2 or 0;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;2&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;ports&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above services/processes model, we have made the following changes:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;In the beginning of the expression, we &lt;strong&gt;import&lt;/strong&gt; the dynamically generated &lt;i&gt;ids.nix&lt;/i&gt; expression that provides ID assignments for each resource. If the &lt;i&gt;ids.nix&lt;/i&gt; file does not exists, we generate an empty attribute set. We implement this construction (in which the absence of &lt;i&gt;ids.nix&lt;/i&gt; can be tolerated) to allow the ID assigner to bootstrap the ID assignment process.&lt;/li&gt;  &lt;li&gt;Every hardcoded &lt;i&gt;port&lt;/i&gt; attribute of every service is replaced by a &lt;strong&gt;reference&lt;/strong&gt; to the &lt;i&gt;ids&lt;/i&gt; attribute set that is dynamically generated by the ID assigner tool. To allow the ID assigner to open the services model in the first run, we provide a fallback port value of 0.&lt;/li&gt;  &lt;li&gt;Every service specifies for which resources it &lt;strong&gt;requires&lt;/strong&gt; a unique ID through the &lt;i&gt;requiresUniqueIdsFor&lt;/i&gt; attribute. In the above example, both service instances require unique IDs to assign a port number, user ID to the user and group ID to the group.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The port assignments are propagated as function parameters to the constructor functions that configure the services (as shown earlier in this blog post).&lt;br /&gt;&lt;br /&gt;We could also implement a similar strategy with the UIDs and GIDs, but a more convenient mechanism is to compose the function that creates the credentials, so that it transparently uses our &lt;i&gt;uids&lt;/i&gt; and &lt;i&gt;gids&lt;/i&gt; assignments.&lt;br /&gt;&lt;br /&gt;As shown in the expression above, the &lt;i&gt;ids&lt;/i&gt; attribute set is also propagated to the constructors expression. The constructors expression indirectly composes the &lt;i&gt;createCredentials&lt;/i&gt; function as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{pkgs, ids ? {}, ...}:&lt;br /&gt;&lt;br /&gt;{&lt;br /&gt;  createCredentials = import ../../create-credentials {&lt;br /&gt;    inherit (pkgs) stdenv;&lt;br /&gt;    inherit ids;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  ...&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The &lt;i&gt;ids&lt;/i&gt; attribute set is propagated to the function that composes the &lt;i&gt;createCredentials&lt;/i&gt; function. As a result, it will automatically assign the UIDs and GIDs in the &lt;i&gt;ids.nix&lt;/i&gt; expression when the user configures a user or group with a name that exists in the &lt;i&gt;uids&lt;/i&gt; and &lt;i&gt;gids&lt;/i&gt; resource pools.&lt;br /&gt;&lt;br /&gt;To make these UIDs and GIDs assignments go smoothly, it is recommended to give a process instance the same process name, instance name, user and group names.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Using the ID assigner tool&lt;/h2&gt;&lt;br /&gt;By combining the ID resources specification with the three Disnix models: a &lt;strong&gt;services model&lt;/strong&gt; (that defines all distributable services, shown above), an &lt;strong&gt;infrastructure model&lt;/strong&gt; (that captures all available target machines) and their properties and a &lt;strong&gt;distribution model&lt;/strong&gt; (that maps services to target machines in the network), we can automatically generate an ids configuration that contains all ID assignments:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;$ dydisnix -s services.nix -i infrastructure.nix -d distribution.nix \&lt;br /&gt;  --id-resources idresources.nix --output-file ids.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above command will generate an ids configuration file (&lt;i&gt;ids.nix&lt;/i&gt;) that provides, for each resource in the ID resources model, a unique assignment to services that are distributed to a target machine in the network. (Services that are not distributed to any machine in the distribution model will be skipped, to not waste too many resources).&lt;br /&gt;&lt;br /&gt;The output file (&lt;i&gt;ids.nix&lt;/i&gt;) has the following structure:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{&lt;br /&gt;  &quot;ids&quot; = {&lt;br /&gt;    &quot;gids&quot; = {&lt;br /&gt;      &quot;webapp1&quot; = 2000;&lt;br /&gt;      &quot;webapp2&quot; = 2001;&lt;br /&gt;    };&lt;br /&gt;    &quot;uids&quot; = {&lt;br /&gt;      &quot;webapp1&quot; = 2000;&lt;br /&gt;      &quot;webapp2&quot; = 2001;&lt;br /&gt;    };&lt;br /&gt;    &quot;ports&quot; = {&lt;br /&gt;      &quot;webapp1&quot; = 5000;&lt;br /&gt;      &quot;webapp2&quot; = 5001;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;  &quot;lastAssignments&quot; = {&lt;br /&gt;    &quot;gids&quot; = 2001;&lt;br /&gt;    &quot;uids&quot; = 2001;&lt;br /&gt;    &quot;ports&quot; = 5001;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The &lt;i&gt;ids&lt;/i&gt; attribute contains for each resource (defined in the ID resources model) the unique ID assignments per service. As shown earlier, both service instances require unique IDs for &lt;i&gt;ports&lt;/i&gt;, &lt;i&gt;uids&lt;/i&gt; and &lt;i&gt;gids&lt;/i&gt;. The above attribute set stores the corresponding ID assignments.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;lastAssignments&lt;/i&gt; attribute memorizes the last ID assignment per resource. Once an ID is assigned, it will not be immediately reused. This is to allow roll backs and to prevent data to incorrectly get owned by the wrong user accounts. Once the maximum ID limit is reached, the ID assigner will start searching for a free assignment from the beginning of the resource pool.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;In addition to assigning IDs to services that are distributed to machines in the network, it is also possible to assign IDs to all services (regardless whether they have been deployed or not):&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;$ dydisnix -s services.nix \&lt;br /&gt;  --id-resources idresources.nix --output-file ids.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Since the above command does not know anything about the target machines, it only works with an ID resources configuration that defines global scope resources.&lt;br /&gt;&lt;br /&gt;When you intend to upgrade an existing deployment, you typically want to retain already assigned IDs, while obsolete ID assignment should be removed, and new IDs should be assigned to services that have none yet. This is to prevent unnecessary redeployments.&lt;br /&gt;&lt;br /&gt;When removing the first webapp service and adding a third instance:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{ pkgs, system&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;sysvinit&quot;&lt;br /&gt;, ...&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  ids = if builtins.pathExists ./ids.nix then (import ./ids.nix).ids else {};&lt;br /&gt;&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir forceDisableUserChange processManager ids;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  processType = import ../../nixproc/derive-dysnomia-process-type.nix {&lt;br /&gt;    inherit processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp2 = rec {&lt;br /&gt;    name = &quot;webapp2&quot;;&lt;br /&gt;    port = ids.ports.webapp2 or 0;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;2&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;ports&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;  &lt;br /&gt;  webapp3 = rec {&lt;br /&gt;    name = &quot;webapp3&quot;;&lt;br /&gt;    port = ids.ports.webapp3 or 0;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;3&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;ports&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;And running the following command (that provides the current &lt;i&gt;ids.nix&lt;/i&gt; as a parameter):&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix -s services.nix -i infrastructure.nix -d distribution.nix \&lt;br /&gt;  --id-resources idresources.nix --ids ids.nix --output-file ids.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;we will get the following ID assignment configuration:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{&lt;br /&gt;  &quot;ids&quot; = {&lt;br /&gt;    &quot;gids&quot; = {&lt;br /&gt;      &quot;webapp2&quot; = 2001;&lt;br /&gt;      &quot;webapp3&quot; = 2002;&lt;br /&gt;    };&lt;br /&gt;    &quot;uids&quot; = {&lt;br /&gt;      &quot;webapp2&quot; = 2001;&lt;br /&gt;      &quot;webapp3&quot; = 2002;&lt;br /&gt;    };&lt;br /&gt;    &quot;ports&quot; = {&lt;br /&gt;      &quot;webapp2&quot; = 5001;&lt;br /&gt;      &quot;webapp3&quot; = 5002;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;  &quot;lastAssignments&quot; = {&lt;br /&gt;    &quot;gids&quot; = 2002;&lt;br /&gt;    &quot;uids&quot; = 2002;&lt;br /&gt;    &quot;ports&quot; = 5002;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As may be observed, since the &lt;i&gt;webapp2&lt;/i&gt; process is in both the current and the previous configuration, its ID assignments will be retained. &lt;i&gt;webapp1&lt;/i&gt; gets removed because it is no longer in the services model. &lt;i&gt;webapp3&lt;/i&gt; gets the next numeric IDs from the resources pools.&lt;br /&gt;&lt;br /&gt;Because the configuration of &lt;i&gt;webapp2&lt;/i&gt; stays the same, it does not need to be redeployed.&lt;br /&gt;&lt;br /&gt;The models shown earlier are valid Disnix services models. As a consequence, they can be used with Dynamic Disnix's ID assigner tool: &lt;i&gt;dydisnix-id-assign&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;Although these Disnix services models are also valid processes models (used by the Nix process management framework) not every processes model is guaranteed to be compatible with a Disnix service model.&lt;br /&gt;&lt;br /&gt;For process models that are not compatible, it is possible to use the &lt;i&gt;nixproc-id-assign&lt;/i&gt; tool that acts as a wrapper around &lt;i&gt;dydisnix-id-assign&lt;/i&gt; tool:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nixproc-id-assign --id-resources idresources.nix processes.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Internally, the &lt;i&gt;nixproc-id-assign&lt;/i&gt; tool converts a processes model to a Disnix service model (augmenting the process instance objects with missing properties) and propagates it to the &lt;i&gt;dydisnix-id-assign&lt;/i&gt; tool.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;A more advanced example&lt;/h2&gt;&lt;br /&gt;The &lt;i&gt;webapp&lt;/i&gt; processes example is fairly trivial and only needs unique IDs for three kinds of resources: port numbers, UIDs, and GIDs.&lt;br /&gt;&lt;br /&gt;I have also developed a more complex example for the Nix process management framework that exposes several commonly used system services on Linux systems, such as:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{ pkgs ? import &amp;lt;nixpkgs&amp;gt; { inherit system; }&lt;br /&gt;, system ? builtins.currentSystem&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  ids = if builtins.pathExists ./ids.nix then (import ./ids.nix).ids else {};&lt;br /&gt;&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir cacheDir forceDisableUserChange processManager ids;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  apache = rec {&lt;br /&gt;    port = ids.httpPorts.apache or 0;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.simpleWebappApache {&lt;br /&gt;      inherit port;&lt;br /&gt;      serverAdmin = &quot;root@localhost&quot;;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;httpPorts&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  postgresql = rec {&lt;br /&gt;    port = ids.postgresqlPorts.postgresql or 0;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.postgresql {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;postgresqlPorts&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  influxdb = rec {&lt;br /&gt;    httpPort = ids.influxdbPorts.influxdb or 0;&lt;br /&gt;    rpcPort = httpPort + 2;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.simpleInfluxdb {&lt;br /&gt;      inherit httpPort rpcPort;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;influxdbPorts&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above processes model exposes three service instances: an Apache HTTP server (that works with a simple configuration that serves web applications from a single virtual host), PostgreSQL and InfluxDB. Each service requires a unique user ID and group ID so that their privileges are separated.&lt;br /&gt;&lt;br /&gt;To make these services more accessible/usable, we do not use a shared ports resource pool. Instead, each service type consumes port numbers from their own resource pools.&lt;br /&gt;&lt;br /&gt;The following ID resources configuration can be used to provision the unique IDs to the services above:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;rec {&lt;br /&gt;  uids = {&lt;br /&gt;    min = 2000;&lt;br /&gt;    max = 3000;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  gids = uids;&lt;br /&gt;&lt;br /&gt;  httpPorts = {&lt;br /&gt;    min = 8080;&lt;br /&gt;    max = 8085;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  postgresqlPorts = {&lt;br /&gt;    min = 5432;&lt;br /&gt;    max = 5532;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  influxdbPorts = {&lt;br /&gt;    min = 8086;&lt;br /&gt;    max = 8096;&lt;br /&gt;    step = 3;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above ID resources configuration defines a shared UIDs and GIDs resource pool, but separate ports resource pools for each service type. This has the following implications if we deploy multiple instances of each service type:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;All Apache HTTP server instances get a TCP port assignment between 8080-8085.&lt;/li&gt;  &lt;li&gt;All PostgreSQL server instances get a TCP port assignment between 5432-5532.&lt;/li&gt;  &lt;li&gt;All InfluxDB server instances get a TCP port assignment between 8086-8096. Since an InfluxDB allocates two port numbers: one for the HTTP server and one for the RPC service (the latter's port number is the base port number + 2). We use a step count of 3 so that we can retain this convention for each InfluxDB instance.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;br /&gt;In this blog post, I have described a new tool: &lt;i&gt;dydisnix-id-assign&lt;/i&gt; that can be used to automatically assign unique numeric IDs to services in Disnix service models.&lt;br /&gt;&lt;br /&gt;Moreover, I have described: &lt;i&gt;nixproc-id-assign&lt;/i&gt; that acts a thin wrapper around this tool to automatically assign numeric IDs to services in the Nix process management framework's processes model.&lt;br /&gt;&lt;br /&gt;This tool replaces the old &lt;i&gt;dydisnix-port-assign&lt;/i&gt; tool in the &lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/08/an-extended-self-adaptive-deployment.html&quot;&gt;Dynamic Disnix toolset&lt;/a&gt; (described in the blog post written five years ago) that is much more limited in its capabilities.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Availability&lt;/h2&gt;&lt;br /&gt;The &lt;i&gt;dydisnix-id-assign&lt;/i&gt; tool is available in the current development version of &lt;a href=&quot;https://github.com/svanderburg/dydisnix&quot;&gt;Dynamic Disnix&lt;/a&gt;. The &lt;i&gt;nixproc-id-assign&lt;/i&gt; is part of the current implementation of the &lt;a href=&quot;https://github.com/svanderburg/nix-processmgmt&quot;&gt;Nix process management framework prototype&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;</description>
	<pubDate>Thu, 24 Sep 2020 18:24:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Tweag I/O: Implicit Dependencies in Build Systems</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-09-16-implicit-build-dependencies/</guid>
	<link>https://tweag.io/blog/2020-09-16-implicit-build-dependencies/</link>
	<description>&lt;p&gt;In making a build system for your software, you codified the dependencies
between its parts. But, did you account for &lt;em&gt;implicit&lt;/em&gt; software dependencies,
like system libraries and compiler toolchains?&lt;/p&gt;
&lt;p&gt;Implicit dependencies give rise to the biggest and most common problem with
software builds - the lack of &lt;em&gt;hermiticity&lt;/em&gt;. Without hermetic builds,
&lt;em&gt;reproducibility&lt;/em&gt; and &lt;em&gt;cacheability&lt;/em&gt; are lost.&lt;/p&gt;
&lt;p&gt;This post motivates the desire for reproducibility and cacheability, and
explains how we achieve hermetic, reproducible, highly cacheable builds by
taking control of implicit dependencies.&lt;/p&gt;
&lt;h3&gt;Reproducibility&lt;/h3&gt;
&lt;p&gt;Consider a developer newly approaching a code repository. After cloning the
repo, the developer must install a long list of “build requirements” and plod
through multiple steps of “setup”, only to find that, yes indeed, the build
fails. Yet, it worked just fine for their colleague! The developer, typically
not expert in build tooling, must debug the mysterious failure not of their
making. This is bad for morale and for productivity.&lt;/p&gt;
&lt;p&gt;This happens because the build is not &lt;em&gt;reproducible&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;One very common reason for the failure is that the compiler toolchain on the
developer’s system is different from that of the colleague. This happens even
with build systems that use sophisticated build software, like &lt;a href=&quot;https://www.tweag.io/blog/tags/bazel&quot;&gt;Bazel&lt;/a&gt;.
Bazel implicitly uses whatever system libraries and compilers are currently
installed in the developer’s environment.&lt;/p&gt;
&lt;p&gt;A common workaround is to provide developers with a Docker image equipped with
a certain compiler toolchain and system libraries, and then to mandate that the
Bazel build occurs in that context.&lt;/p&gt;
&lt;p&gt;That solution has a number of drawbacks. First, if the developer is using
macOS, the virtualized build context runs substantially slower. Second, the
Bazel build cache, developer secrets, and the source code remain outside of the
image and this adds complexity to the Docker invocation. Third, the Docker
image must be rebuilt and redistributed as dependencies change and that’s extra
maintenance. Fourth, and this is the biggest issue, Docker image builds are
themselves not reproducible - they nearly always rely on some external state
that does not remain constant across build invocations, and that means the
build can fail for reasons unrelated to the developer’s code.&lt;/p&gt;
&lt;p&gt;A better solution is to use &lt;a href=&quot;https://www.tweag.io/blog/tags/nix&quot;&gt;Nix&lt;/a&gt; to supply the compiler toolchain and
system library dependencies. Nix is a software package management system
somewhat like Debian’s APT or macOS’s Homebrew. Nix goes much farther to help
developers control their environments. It is unsurpassed when it comes to
reproducible builds of software packages.&lt;/p&gt;
&lt;p&gt;Nix facilitates use of the Nixpkgs package set. That set is &lt;a href=&quot;https://repology.org/repositories/statistics/nonunique&quot;&gt;the largest single
set of software packages&lt;/a&gt;. It is also the &lt;a href=&quot;https://repology.org/repositories/statistics/newest&quot;&gt;freshest&lt;/a&gt; package set. It
provides build instructions that work both on Linux and macOS. Developers can
easily pin any software package at an exact version.&lt;/p&gt;
&lt;p&gt;Learn more about &lt;a href=&quot;https://www.tweag.io/blog/2018-03-15-bazel-nix/&quot;&gt;using Nix with Bazel, here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Cacheability&lt;/h3&gt;
&lt;p&gt;Not only should builds be reproducible, but they should also be fast. Fast
builds are achieved by caching intermediate build results. Cache entries are
keyed based on the precise dependencies as well as the build instructions that
produce the entries. Builds will only benefit from a (shared, distributed)
cache when they have matching dependencies. Otherwise, cache keys (which depend
on the precise dependencies) will be different, and there will be cache misses.
This means that the developer will have to rebuild targets locally. These
unnecessary local rebuilds slow development.&lt;/p&gt;
&lt;p&gt;The solution is to &lt;a href=&quot;https://www.tweag.io/blog/2018-03-15-bazel-nix/&quot;&gt;make the implicit dependencies into explicit ones, again
using Nix&lt;/a&gt;, making sure to configure and use a shared Nix cache.&lt;/p&gt;
&lt;p&gt;Learn more about &lt;a href=&quot;https://www.tweag.io/blog/2020-04-09-bazel-remote-cache/&quot;&gt;configuring a shared Bazel cache, here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;It is important to eliminate implicit dependencies in your build system in
order to retain build reproducibility and cacheability. Identify Nix packages
that can replace the implicit dependencies of your Bazel build and use
&lt;a href=&quot;https://github.com/tweag/rules_nixpkgs&quot;&gt;rules_nixpkgs&lt;/a&gt; to declare them as explicit dependencies. That will yield a
fast, correct, hermetic build.&lt;/p&gt;</description>
	<pubDate>Wed, 16 Sep 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Tweag I/O: Towards a content-addressed model for Nix</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-09-10-nix-cas/</guid>
	<link>https://tweag.io/blog/2020-09-10-nix-cas/</link>
	<description>&lt;p&gt;This is my first post about content-addressability in Nix — a long-awaited feature that is hopefully coming soon!
In this post I will show you how this feature will improve the Nix
infrastructure. I’ll come back in another post to explain the technical challenges of
adding content-addressability to Nix.&lt;/p&gt;
&lt;p&gt;Nix has a wonderful model for handling packages.
Because each derivation is stored under (aka &lt;em&gt;addressed by&lt;/em&gt;) a unique
name, multiple versions of the same library can coexist on the same
system without issues: each version of the library has a distinct
name, as far as Nix is concerned.&lt;/p&gt;
&lt;p&gt;What’s more, if &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; is upgraded in &lt;a href=&quot;https://github.com/NixOS/nixpkgs/&quot;&gt;Nixpkgs&lt;/a&gt;, Nix knows that all the
packages that depend on &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; (i.e., almost everything) must be
rebuilt, if only so that they point at the name of the new &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt;
version. This way, a Nix installation will never feature a package
built for one version of &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt;, but dynamically linked against
another: as a user, it means that you will never have an &lt;em&gt;undefined
symbol&lt;/em&gt; error. Hurray!&lt;/p&gt;
&lt;h2&gt;The input-addressed store&lt;/h2&gt;
&lt;p&gt;How does Nix achieve this feat? The idea is that the name of a package
is derived from all of its inputs (that is, the complete list of
dependencies, as well as the package description). So if you change
the git tag from which &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; is fetched, the name changes, if the
name of &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; changes, then the name of any package which has &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; in
its dependencies changes.&lt;/p&gt;
&lt;p&gt;However this can be very pessimistic: even changes that aren’t
semantically meaningful can imply mass rebuilding and downloading. As
a slightly extreme example, &lt;a href=&quot;https://github.com/NixOS/nixpkgs/pull/83446&quot;&gt;this merge-request on
Nixpkgs&lt;/a&gt; makes a tiny change to the way &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; is built. It doesn’t actually
change &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt;, yet requires rebuilding an insane amount of
packages. Because, as far as Nix is concerned, all these packages have
different names, hence are different packages. In reality, though,
they weren’t.&lt;/p&gt;
&lt;p&gt;Nevertheless, the cost of the rebuild has to be born by the Nix
infrastructure: &lt;a href=&quot;https://hydra.nixos.org&quot;&gt;Hydra&lt;/a&gt; builds all packages to populate the cache,
and all the newly built packages must be stored. It costs both time,
and money (in cpu power, and storage space).&lt;/p&gt;
&lt;h2&gt;Unnecessary rebuilds?&lt;/h2&gt;
&lt;p&gt;Most distributions, by default, don’t rebuild packages when their dependencies change, and have a (more-or-less automated) process to detect changes that require rebuilding reverse dependencies.
For example, Debian &lt;a href=&quot;https://www.debian.org/doc/debian-policy/policy.pdf#81&quot;&gt;tries to detect ABI changes automatically&lt;/a&gt; and Fedora has a &lt;a href=&quot;https://docs.fedoraproject.org/en-US/fesco/Updates_Policy/&quot;&gt;more manual process&lt;/a&gt;.
But Nix doesn’t.&lt;/p&gt;
&lt;p&gt;The issue is that the notion of a “breaking change” is a very fuzzy one.
Should we follow Debian and consider that only ABI changes are breaking?
This criterion only applies for shared libraries, and as the Debian policy acknowledges, only for “well-behaved” programs.
So if we follow this criterion, there’s still need for manual curation, which is &lt;strong&gt;precisely&lt;/strong&gt; what Nix tries to avoid.&lt;/p&gt;
&lt;h2&gt;The content-addressed model&lt;/h2&gt;
&lt;p&gt;Quite happily, there is a criterion to avoid many useless rebuilds without sacrificing correctness: detecting when changes in a package (or one of its dependencies) yields the exact same output.
That might seem like an edge case, but the &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; example above (and many others) shows that there’s a practical application to it.
As another example, &lt;code class=&quot;language-text&quot;&gt;go&lt;/code&gt; depends on &lt;code class=&quot;language-text&quot;&gt;perl&lt;/code&gt; for its tests, so an upgrade of &lt;code class=&quot;language-text&quot;&gt;perl&lt;/code&gt; requires rebuilding all the Go packages in Nixpkgs, although it most likely doesn’t change the output of the &lt;code class=&quot;language-text&quot;&gt;go&lt;/code&gt; derivation.&lt;/p&gt;
&lt;p&gt;But, for Nix to recognise that a package is not a new package, the
new, unchanged, &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; or &lt;code class=&quot;language-text&quot;&gt;go&lt;/code&gt; packages must have &lt;em&gt;the same name&lt;/em&gt;
as the old version. Therefore, the name of a package must not be
derived from its inputs which have changed, but, instead, it should be
derived from the content of the compiled package. This is called
content addressing.&lt;/p&gt;
&lt;p&gt;Content addressing is how you can be sure that when you and a
colleague at the other side of the world type &lt;code class=&quot;language-text&quot;&gt;git checkout 7cc16bb8cd38ff5806e40b32978ae64d54023ce0&lt;/code&gt; you actually have the exact
same content in your tree. Git commits are content addressed, therefore the name
&lt;code class=&quot;language-text&quot;&gt;7cc16bb8cd38ff5806e40b32978ae64d54023ce0&lt;/code&gt; refers to that exact
tree.&lt;/p&gt;
&lt;p&gt;Yet another example of content-addressed storage is &lt;a href=&quot;https://ipfs.io/&quot;&gt;IPFS&lt;/a&gt;. In IPFS storage
files can be stored in any number of computers, and even moved from
computer to computer. The content-derived name is used as a way to give
an intrinsic name to a file, regardless of where it is stored.&lt;/p&gt;
&lt;p&gt;In fact, even the particular use case that we are discussing here -
avoiding recompilation when a rebuilt dependency hasn’t changed -
can be found in various build systems such as
&lt;a href=&quot;https://bazel.build/&quot;&gt;Bazel&lt;/a&gt;. In build systems, such recompilation
avoidance is sometimes known as the &lt;em&gt;early cutoff optimization&lt;/em&gt; −
see the &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf&quot;&gt;build systems a la carte paper&lt;/a&gt;
for example).&lt;/p&gt;
&lt;p&gt;So all we need to do is to move the Nix store from an input-addressed
model to a content-addressed model, as used by many tools
already, and we will be able to save a lot of storage space and CPU
usage, by rebuilding many fewer packages. Nixpkgs contributors will
see their CI time improved. It could also allow &lt;a href=&quot;https://github.com/NixOS/nix/issues/859&quot;&gt;serving a binary cache
over IPFS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Well, like many things with computers,
this is actually way harder than it sounds (which explains why this
hasn’t already been done despite being discussed nearly 15 years ago in the
&lt;a href=&quot;https://github.com/edolstra/edolstra.github.io/raw/49a78323f6b319da6e078b4f5f6b3112a30e8db9/pubs/phd-thesis.pdf&quot;&gt;original paper&lt;/a&gt;), but we now believe that there’s &lt;a href=&quot;https://github.com/NixOS/rfcs/pull/62&quot;&gt;a way forward&lt;/a&gt;… more on that in a later post.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;A content-addressed store for Nix would help reduce the insane load
that &lt;a href=&quot;https://hydra.nixos.org&quot;&gt;Hydra&lt;/a&gt; has to sustain. While content-addressing is a common technique both in distributed systems
and build systems (Nix is both!), getting to the point where it was
feasible to integrate content-addressing in Nix has been a long journey.&lt;/p&gt;
&lt;p&gt;In a future post, I’ll explain why it was so hard, and how we finally
managed to propose a viable design for a content-addressed Nix.&lt;/p&gt;</description>
	<pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Guillaume Maudoux: How to Digest Nix Hashes ?</title>
	<guid isPermaLink="true">https://blog.layus.be/posts/2020-09-01-nix-hashes.html</guid>
	<link>https://blog.layus.be/posts/2020-09-01-nix-hashes.html</link>
	<description>&lt;article&gt;
    &lt;p&gt;They say there are two hard things in computing: cache invalidation and naming things. Alas, build systems fight against these two at the same time. Because caching build results is a central feature of most build systems, they are immediately concerned by cache invalidation issues. For naming things, it is less obvious. I used to understand the naming problem as related to concepts and source code variables. Finding the right name for a class, a function or a variable can be a real headache.&lt;/p&gt;
&lt;p&gt;But it can also be difficult to generate a meaningful name for values manipulated by programs. Nix and a range of build systems have to forge unique and deterministic names for intermediate build results. These names are used as cache keys. In the case of Nix, the names are first class citizens as they are visible in the public store, in the form of store paths.&lt;/p&gt;
&lt;p&gt;Did you ever wonder what’s in your Nix hashes? Or how they are computed? Two different projects led me to further investigate these questions. Implementing &lt;a href=&quot;https://github.com/haskell-Nix&quot;&gt;HNix&lt;/a&gt; store and shepherding the “Content addressed paths” &lt;a href=&quot;https://github.com/NixOS/rfcs/pull/62&quot;&gt;RFC #62&lt;/a&gt;. In both cases, understanding how path names (and the other hashes) are generated took some time. Here is what I learned.&lt;/p&gt;
&lt;h2 id=&quot;store-path-hashes&quot;&gt;Store path hashes&lt;/h2&gt;
&lt;p&gt;The most visible digests in Nix appears in store path names. Lets take for example a pinned version of &lt;code&gt;hello&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;scroll-wrapper&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode nix&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb1-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;bu&quot;&gt;let&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb1-2&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;ex&quot;&gt;nixpkgs&lt;/span&gt; = import (builtins.fetchTarball {&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb1-3&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;ex&quot;&gt;url&lt;/span&gt; = &lt;span class=&quot;st&quot;&gt;&quot;https://github.com/nixos/nixpkgs/archive/c59ea8b8a0e7f927e7291c14ea6cd1bd3a16ff38.tar.gz&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb1-4&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;ex&quot;&gt;sha256&lt;/span&gt; = &lt;span class=&quot;st&quot;&gt;&quot;1ak7jqx94fjhc68xh1lh35kh3w3ndbadprrb762qgvcfb8351x8v&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb1-5&quot;&gt;&lt;/a&gt;  }) {};&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb1-6&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb1-7&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;ex&quot;&gt;nixpkgs.hello&lt;/span&gt; # =&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; /nix/store/ab1pfk338f6gzpglsirxhvji4g9w558i-hello-2.10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Nix composes the hash part of the path by compressing to 32 base32 characters (160 bits or 20 bytes) a sha256 digest. Base32 encoding is unique to Nix. It uses digits and lower-case letters (except &lt;a href=&quot;https://discourse.nixos.org/t/no-hashes-starting-with-e-t-o-or-u-in-nix-store/4906/1&quot;&gt;EOUT&lt;/a&gt;) for a total of 32 characters valid in a file name. The result is more dense than base16 while avoiding the strange characters of base64 (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;) amongst which &lt;code&gt;/&lt;/code&gt; would create a lot of trouble in file names.&lt;/p&gt;
&lt;p&gt;For example &lt;code&gt;/nix/store/ab1pfk338f6gzpglsirxhvji4g9w558i-hello-2.10&lt;/code&gt; contains &lt;code&gt;&lt;b&gt;ab1pfk338f6g&lt;/b&gt;zpglsirxhvji4g9w558i&lt;/code&gt; which is the compression on 20 bytes of &lt;code&gt;0fqqilza6ifk0arlay18&lt;b&gt;ab1pfk338f6g&lt;/b&gt;zrpcb56pnaw245h8gv9r&lt;/code&gt;. Basically folding excess bits with xor. Notice how some characters are shared, as the input is so small that some of them are passed as-is.&lt;/p&gt;
&lt;div class=&quot;scroll-wrapper&quot;&gt;
&lt;pre&gt;&lt;code&gt;  ab1pfk338f6gzrpcb56pnaw245h8gv9r
^             0fqqilza6ifk0arlay18
  --------------------------------
= ab1pfk338f6gzpglsirxhvji4g9w558i&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The full (uncompressed) digest comes from hashing the string &lt;code&gt;output:out:sha256:5d4447675168bb44442f0d225ab8b50b7a67544f0ba2104dbf74926ff4df1d1e:/nix/store:hello-2.10&lt;/code&gt;. This string is a fingerprint of the important parts of that derivation. If any part changes, the hash will be different, and it will produce a different output path.&lt;/p&gt;
&lt;p&gt;We can see four parts:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;code&gt;output:out&lt;/code&gt; is the type of the fingerprint. Here we fingerprint something used for an output path. The output named &lt;code&gt;out&lt;/code&gt; in this case. Nix uses various types, and each expects different things in the remainder of the string.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sha256:5d4447675168bb44442f0d225ab8b50b7a67544f0ba2104dbf74926ff4df1d1e&lt;/code&gt; is the hash of the derivation building hello. As a hash it encompasses many things, and we will explore that further below.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/nix/store&lt;/code&gt; is the store prefix.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hello-2.10&lt;/code&gt; is the name of the derivation.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hashing the derivation is a tricky part. Nix store a lot of information about derivations. To read it, we can use &lt;code&gt;nix show-derivation&lt;/code&gt; on our &lt;code&gt;hello&lt;/code&gt; package.&lt;/p&gt;
&lt;div class=&quot;scroll-wrapper&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode json&quot;&gt;&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-2&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;dt&quot;&gt;&quot;/nix/store/4pmrswlhqyclwpv12l1h7mr9qkfhpd1c-hello-2.10.drv&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-3&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;outputs&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-4&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;out&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;&quot;path&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/nix/store/ab1pfk338f6gzpglsirxhvji4g9w558i-hello-2.10&quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-5&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-5&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;},&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-6&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-6&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;inputSrcs&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-7&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-7&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;inputDrvs&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-8&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-8&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;/nix/store/fkz4j4zj7xaf1z1g0i29987dvvc3xxbv-hello-2.10.tar.gz.drv&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;out&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-9&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-9&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;/nix/store/fsqdw7hjs2qdcy8qgcv5hnrajsr77xhc-bash-4.4-p23.drv&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;out&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-10&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-10&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;/nix/store/q0kiricfc0gkwm1vy3j0svcq5jib4v1g-stdenv-linux.drv&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;out&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-11&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-11&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;},&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-12&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-12&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;platform&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;x86_64-linux&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-13&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-13&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;builder&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/nix/store/6737cq9nvp4k5r70qcgf61004r0l2g3v-bash-4.4-p23/bin/bash&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-14&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-14&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;args&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;-e&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-15&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-15&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;env&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-16&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-16&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;hello-2.10&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-17&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-17&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;out&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/nix/store/ab1pfk338f6gzpglsirxhvji4g9w558i-hello-2.10&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-18&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-18&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;src&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/nix/store/3x7dwzq014bblazs7kq20p9hyzz0qh8g-hello-2.10.tar.gz&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-19&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-19&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;stdenv&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/nix/store/50780gywsyjad8nxrf79q6qx7y7mqgal-stdenv-linux&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-20&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-20&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;er&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;[elided&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;brevity]&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-21&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-21&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-22&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-22&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-23&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb3-23&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;show-derivation&lt;/code&gt; pretty prints and reformats the content of the .drv file. The exact content of &lt;code&gt;/nix/store/4pmrswlhqyclwpv12l1h7mr9qkfhpd1c-hello-2.10.drv&lt;/code&gt; is a nested structure starting with &lt;code&gt;&quot;Derive(&quot;&lt;/code&gt; and that’s why we will call it the &lt;em&gt;derive&lt;/em&gt; string. It is formatted as an &lt;a href=&quot;http://releases.strategoxt.org/strategoxt-manual/unstable/manual/chunk-chapter/stratego-terms.html#id3314115&quot;&gt;ATerm&lt;/a&gt; from the Stratego language. Curious readers will find more about this format in the related &lt;a href=&quot;http://lethalman.blogspot.com/2014/07/nix-pill-6-our-first-derivation.html&quot;&gt;nix pill&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&quot;scroll-wrapper&quot;&gt;
&lt;pre&gt;&lt;code&gt;$ cat /nix/store/4pmrswlhqyclwpv12l1h7mr9qkfhpd1c-hello-2.10.drv
Derive([(&quot;out&quot;,&quot;/nix/store/ab1pfk338f6gzpglsirxhvji4g9w558i-hello-2.10&quot;,&quot;&quot;,&quot;&quot;)],[(&quot;/nix/store/fkz4j4zj7xaf1z1g0i29987dvvc3xxbv-hello-2.10.tar.gz.drv&quot;,[&quot;out&quot;]),(&quot;/nix/store/fsqdw7hjs2qdcy8qgcv5hnrajsr77xhc-bash-4.4-p23.drv&quot;,[&quot;out&quot;]),(&quot;/nix/store/q0kiricfc0gkwm1vy3j0svcq5jib4v1g-stdenv-linux.drv&quot;,[&quot;out&quot;])],[&quot;/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh&quot;],&quot;x86_64-linux&quot;,&quot;/nix/store/6737cq9nvp4k5r70qcgf61004r0l2g3v-bash-4.4-p23/bin/bash&quot;,[&quot;-e&quot;,&quot;/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh&quot;],[(&quot;buildInputs&quot;,&quot;&quot;),(&quot;builder&quot;,&quot;/nix/store/6737cq9nvp4k5r70qcgf61004r0l2g3v-bash-4.4-p23/bin/bash&quot;),(&quot;configureFlags&quot;,&quot;&quot;),(&quot;depsBuildBuild&quot;,&quot;&quot;),(&quot;depsBuildBuildPropagated&quot;,&quot;&quot;),(&quot;depsBuildTarget&quot;,&quot;&quot;),(&quot;depsBuildTargetPropagated&quot;,&quot;&quot;),(&quot;depsHostHost&quot;,&quot;&quot;),(&quot;depsHostHostPropagated&quot;,&quot;&quot;),(&quot;depsTargetTarget&quot;,&quot;&quot;),(&quot;depsTargetTargetPropagated&quot;,&quot;&quot;),(&quot;doCheck&quot;,&quot;1&quot;),(&quot;doInstallCheck&quot;,&quot;&quot;),(&quot;name&quot;,&quot;hello-2.10&quot;),(&quot;nativeBuildInputs&quot;,&quot;&quot;),(&quot;out&quot;,&quot;/nix/store/ab1pfk338f6gzpglsirxhvji4g9w558i-hello-2.10&quot;),(&quot;outputs&quot;,&quot;out&quot;),(&quot;patches&quot;,&quot;&quot;),(&quot;pname&quot;,&quot;hello&quot;),(&quot;propagatedBuildInputs&quot;,&quot;&quot;),(&quot;propagatedNativeBuildInputs&quot;,&quot;&quot;),(&quot;src&quot;,&quot;/nix/store/3x7dwzq014bblazs7kq20p9hyzz0qh8g-hello-2.10.tar.gz&quot;),(&quot;stdenv&quot;,&quot;/nix/store/50780gywsyjad8nxrf79q6qx7y7mqgal-stdenv-linux&quot;),(&quot;strictDeps&quot;,&quot;&quot;),(&quot;system&quot;,&quot;x86_64-linux&quot;),(&quot;version&quot;,&quot;2.10&quot;)])&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;However, hashing this derive string directly does not yield the expected hash found above. (Do you recall the &lt;code&gt;sha256:5d4447675168bb44442f0d225ab8b50b7a67544f0ba2104dbf74926ff4df1d1e&lt;/code&gt; ?)&lt;/p&gt;
&lt;div class=&quot;scroll-wrapper&quot;&gt;
&lt;pre&gt;&lt;code&gt;$ nix-hash --flat --type sha256 /nix/store/4pmrswlhqyclwpv12l1h7mr9qkfhpd1c-hello-2.10.drv
40289ac3cc7d8896122c9a93ce580fb657aa29af6cf0a2bc4a30b3c53172ccf6&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;To understand where this hash comes from, it helps to understand other types of store objects. Let’s make a small detour to simpler paths.&lt;/p&gt;
&lt;h2 id=&quot;text-files&quot;&gt;Text files&lt;/h2&gt;
&lt;p&gt;Raw text files whose content is know by Nix without running any builder are named by a comparatively simpler scheme. Their name is a digest over both the content and the name of the path.&lt;/p&gt;
&lt;div class=&quot;scroll-wrapper&quot;&gt;
&lt;pre&gt;&lt;code&gt;$ nix-instantiate --eval --expr 'builtins.toFile &quot;file-name&quot; &quot;some content&quot;'
/nix/store/gn48qr23kimj8iyh50jvffjx7335k9fz-file-name
└── gn48qr23kimj8iyh50jvffjx7335k9fz
    └── 0cl4lvq60bp9il749fyngn48qr23kimj8xalivaxf55lnp41s7h9
        └── &quot;text:sha256:290f493c44f5d63d06b374d0a5abd292fae38b92cab2fae5efefe1b0e9347f56:/nix/store:file-name&quot;
            └── 290f493c44f5d63d06b374d0a5abd292fae38b92cab2fae5efefe1b0e9347f56
                └── &quot;some content&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The text format is also used by .drv files. But .drv files can depend on other .drv files. All the dependencies appear between the &lt;code&gt;text:&lt;/code&gt; and &lt;code&gt;:sha256&lt;/code&gt; part of the path description.&lt;/p&gt;
&lt;div class=&quot;scroll-wrapper&quot;&gt;
&lt;pre&gt;&lt;code&gt;/nix/store/4pmrswlhqyclwpv12l1h7mr9qkfhpd1c-hello-2.10.drv
└── 4pmrswlhqyclwpv12l1h7mr9qkfhpd1c
    └── 1c3ws0r5wm3ydx1zijcf4pmrswlhqyclxvqxqlqmv0spmfgg6zd2
        └── &quot;text:[... dependant .drv's  ...]:sha256:40289ac3cc7d8896122c9a93ce580fb657aa29af6cf0a2bc4a30b3c53172ccf6:/nix/store:hello-2.10.drv&quot;
            └── 40289ac3cc7d8896122c9a93ce580fb657aa29af6cf0a2bc4a30b3c53172ccf6
                └── &quot;Derive([(&quot;out&quot;,&quot;... [content of /nix/store/4pmrswlhqyclwpv12l1h7mr9qkfhpd1c-hello-2.10.drv] ...&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;All the different store path description strings are listed in &lt;a href=&quot;https://github.com/NixOS/nix/blob/691a1bd7179bcf88f2638c1b8574c81f61e20786/src/libstore/store-api.cc#L63-L140&quot;&gt;store-api.cc&lt;/a&gt;. We have already seen ‘text’ right now and ‘output’ before. The third type is ‘source’, for some well-behaved, content addressed paths.&lt;/p&gt;
&lt;h2 id=&quot;hashing-modulo&quot;&gt;Hashing modulo&lt;/h2&gt;
&lt;p&gt;Back to our initial &lt;code&gt;pkgs.hello&lt;/code&gt; store path. We were stuck at understanding the hash used there.&lt;/p&gt;
&lt;div class=&quot;scroll-wrapper&quot;&gt;
&lt;pre&gt;&lt;code&gt;/nix/store/ab1pfk338f6gzpglsirxhvji4g9w558i-hello-2.10
└── ab1pfk338f6gzpglsirxhvji4g9w558i
    └── 0fqqilza6ifk0arlay18ab1pfk338f6gzrpcb56pnaw245h8gv9r
        └── &quot;output:out:sha256:5d4447675168bb44442f0d225ab8b50b7a67544f0ba2104dbf74926ff4df1d1e:/nix/store:hello-2.10&quot;
            └── 5d4447675168bb44442f0d225ab8b50b7a67544f0ba2104dbf74926ff4df1d1e
                └── ???&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Ideally, this would be the hash of the ‘derive’ string from the .drv. This is not the case because it would be impossible and undesirable. The impossibility comes from the fact that the output paths of a derivation are part of its ‘derive’ string. The loop needs to be broken somewhere. That is why the output paths are replaced with empty strings before hashing the ‘derive’ string used in output paths.&lt;/p&gt;
&lt;p&gt;The other aspect comes from fixed-output paths. While the recipe to build them may vary (and hence their derive string) we would like to avoid propagating such changes to other derivations outputs. As fixed-output derivations can happen anywhere in the dependency tree, the process of replacing the hash of fixed-output derivations needs to be recursive. This is performed by &lt;code&gt;hashDerivationModulo()&lt;/code&gt; whose name hints that the hashing is made modulo the equivalence of recipes for the same fixed-output paths.&lt;/p&gt;
&lt;p&gt;It means that instead of the former &lt;code&gt;nix show-derivation&lt;/code&gt; result, hashDerivationModulo ends up hashing a modified derive string.&lt;/p&gt;
&lt;div class=&quot;scroll-wrapper&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb9&quot;&gt;&lt;pre class=&quot;sourceCode json&quot;&gt;&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span id=&quot;cb9-1&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-2&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-2&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;dt&quot;&gt;&quot;/nix/store/4pmrswlhqyclwpv12l1h7mr9qkfhpd1c-hello-2.10.drv +mased +modulo&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-3&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-3&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;outputs&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-4&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-4&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;out&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;&quot;path&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;masked&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-5&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-5&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;},&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-6&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-6&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;inputSrcs&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-7&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-7&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;inputDrvs&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-8&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-8&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;103f297b7051255f2b7c1cd9838ee978d6ba392fb6ae2a6112d5816279c4ed14&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;out&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt; &lt;/span&gt;
&lt;span id=&quot;cb9-9&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-9&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;er&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;modulo&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;fixed-ouput&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;derivations&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;/nix/store/fsqdw7hjs2qdcy8qgcv5hnrajsr77xhc-bash-4.4-p23.drv&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-10&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-10&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;26f653058a4d742a815b4d3a3c0721bca16200ffc48c22d62b3eb54164560856&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;out&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-11&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-11&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;er&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;fixed&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;fixed-ouptut&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;derivation&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;/nix/store/3x7dwzq014bblazs7kq20p9hyzz0qh8g-hello-2.10.tar.gz&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-12&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-12&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;er&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;'fixed&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;out:sha256:&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;31e066137&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;a962676e89f69d1b65382de95a7ef7d914b8cb956f41ea72e0f516b:/nix/store/&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;x7dwzq014bblazs7kq20p9hyzz0qh8g-hello&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;-2.10&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;.tar.gz'&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-13&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-13&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;st&quot;&gt;&quot;a9365c39d2b7a2a8f2340da6e9814ca605f8dcefe4b49f5c44db7d9ed3bb031f&quot;&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;out&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-14&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-14&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;er&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;modulo&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;fixed-output&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;derivations&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;/nix/store/q0kiricfc0gkwm1vy3j0svcq5jib4v1g-stdenv-linux.drv&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-15&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-15&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;},&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-16&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-16&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;platform&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;x86_64-linux&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-17&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-17&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;builder&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/nix/store/6737cq9nvp4k5r70qcgf61004r0l2g3v-bash-4.4-p23/bin/bash&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-18&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-18&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;args&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;-e&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-19&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-19&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;&quot;env&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-20&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-20&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;hello-2.10&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-21&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-21&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;out&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;masked&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-22&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-22&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;src&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/nix/store/3x7dwzq014bblazs7kq20p9hyzz0qh8g-hello-2.10.tar.gz&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-23&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-23&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;dt&quot;&gt;&quot;stdenv&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;/nix/store/50780gywsyjad8nxrf79q6qx7y7mqgal-stdenv-linux&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-24&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-24&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;er&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;[still&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;elided&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;er&quot;&gt;brevity]&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-25&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-25&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-26&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-26&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-27&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb9-27&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;recap&quot;&gt;Recap&lt;/h2&gt;
&lt;p&gt;As we have seen, hashing in Nix is based on several concepts.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;Description strings&lt;/dt&gt;
&lt;dd&gt;starting with a type, and separated with colons. Highly recognisable. They describe uniquely a ressource. In practice, we never encounter them, as they are always hashed with sha256.
&lt;/dd&gt;
&lt;dt&gt;Hash compression&lt;/dt&gt;
&lt;dd&gt;The hash appearing in path names is a folded version of full digests. Nix compresses the hash to 32 base32 characters.
&lt;/dd&gt;
&lt;dt&gt;Maksing&lt;/dt&gt;
&lt;dd&gt;&lt;em&gt;Derive&lt;/em&gt; strings contain the output paths of the derivation. As these output paths are generated based on a digest of the derivation itself, we have to break the loop. Masking is the process of removing output paths from a &lt;em&gt;derive&lt;/em&gt; string before computing it’s hash.
&lt;/dd&gt;
&lt;dt&gt;Hashing modulo [other derivations]&lt;/dt&gt;
&lt;dd&gt;Digests of derivations form a tree. Any change to a dependency’s &lt;em&gt;derive&lt;/em&gt; string will propagate to all the dependant .drv paths and output paths. But it makes little sense to propagate changes in the recipe (the &lt;em&gt;derive&lt;/em&gt; string) of a fixed output path. By definition, they will produce the same output regardless of their recipe. Nix computes output paths hashes on a tree of digests where fixed-output &lt;em&gt;derive&lt;/em&gt; strings are replaced by the fixed-output hash.
&lt;/dd&gt;
&lt;/dl&gt;
&lt;h2 id=&quot;practical-issues&quot;&gt;Practical issues&lt;/h2&gt;
&lt;p&gt;So much for technical considerations. What is this useful for? The way hashes are computed constrains how they can be computed and generated.&lt;/p&gt;
&lt;p&gt;In an HNix &lt;a href=&quot;https://github.com/haskell-nix/hnix-store/pull/59#discussion_r429582370-permalink&quot;&gt;discussion&lt;/a&gt;, I discovered that the Nix daemon has two API calls to build derivations.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;opBuildPaths&lt;/code&gt; is the most obvious one. It takes a list of pre-uploaded .drv files and triggers the build. Because a .drv depends on other .drv files, the full closure needs to be uploaded to the store upfront. In our example, that closure represents 280 .drv files to upload before starting the build. And &lt;code&gt;hello&lt;/code&gt; is a relatively small package. This can slow down build times in distributed remote building situation where the builder responsible for a package may not be the one that built its dependencies. The machine will have to download all the .drv files when all it really needs is the &lt;code&gt;hello&lt;/code&gt; .drv file and the build inputs paths.&lt;/p&gt;
&lt;p&gt;That is why &lt;code&gt;opBuildDerivation&lt;/code&gt; was implemented. It takes all the information from a derivation and builds it. The input paths need to be uploaded beforehand, but nothing more. This nice feature come with a downside. As we have seen, the ouptut path of a derivation is computed with hashDerivationModulo, which requires the full closure of derivations to substitute the hashe of fixed-output ones. Without the closure, it is impossible for the builder to check the validity of an output path. That is why this API call is a privileged operation.&lt;/p&gt;
&lt;p&gt;Allowing unprivileged builds without the .drv closure is not an easy feature. As Eelco Dolstra states in the &lt;a href=&quot;https://blog.layus.be/tags/1511aa9f488ba0762c2da0bf8ab61b5fde47305d&quot;&gt;commit introducing &lt;code&gt;opBuildDerivation&lt;/code&gt;&lt;/a&gt;, it would require changing the hashing scheme. And finding the right balance is complicated. Using a hash “without modulo” means that changing &lt;em&gt;how&lt;/em&gt; we build fixed-output derivations will propagate to all the package. Not hashing inputs makes it possible to obtain the same output path name for all the derivations that change only in their inputs. For example, updating gcc would not change our &lt;code&gt;hello&lt;/code&gt; output path. You could get different things under the same name. Not an option.&lt;/p&gt;
&lt;p&gt;That sentence from Eelco Dolstra feels a bit like Fermat’s last theorem. While it seems to imply that there exists other hashing schemes, nothing is said about these schemes. Years later (the commit dates from 2015), the solution comes from a different angle. The long discussed, argued (and ultimately postponed) feature of a content-addressed store could bring builds without the .drv closure. Much like the proof of Fermat’s last theorem, the implementation of the content-addressed store comes long after the problem is sketched but, were it used only to solve that specific problem, would also feels like bringing an elephant to kill the mouse.&lt;/p&gt;
&lt;h3 id=&quot;content-addressed-paths&quot;&gt;Content-addressed paths&lt;/h3&gt;
&lt;p&gt;In the content-addressed store, output path names are not derived from their .drv, but from their content. Orthogonal changes to .drv files are not reflected in the name, and do not propagate. The name changes only if the content changes. The major downside is that output path names cannot be known before their content is made available. That’s why we need two names. On for the output path we want to build, and one for the actual content-addressed result.&lt;/p&gt;
&lt;p&gt;In such a setup, there is no need anymore for &lt;code&gt;hashDerivationModulo&lt;/code&gt;. I tend to see &lt;code&gt;hashDerivationModulo&lt;/code&gt; as a hack, a workaround to limit useless rebuilds as much as possible without having to implement the content-addressed store in its full complexity. That hack served us well over the years, and content-addressed stores are not yet implemented.&lt;/p&gt;

&lt;h2 id=&quot;closing-thoughts&quot;&gt;Closing thoughts&lt;/h2&gt;
&lt;p&gt;There is already a lot in this article, but we did not cover everything. There are several ways to upload a content-addressed path to the store, and content-addressed paths can also depend on other content-addressed paths. There are other funny corner cases here and there. But overall, this sketches the idea behind Nix store paths generation, and gives an idea of how derivations and store paths interact.&lt;/p&gt;
&lt;p&gt;I had to leave aside the detailed explanation of content-addressed stores, but this is perhaps not for long…&lt;/p&gt;
&lt;p&gt;This blog is still lacking a proper way to leave comments, but I would be more than happy to receive remarks, comments, advices and praises by email, or by any other channel if you are willing to wait more.&lt;/p&gt;
&lt;h2 id=&quot;some-more-stuff-a.k.a.-annexes&quot;&gt;Some more stuff (a.k.a. Annexes)&lt;/h2&gt;
&lt;p&gt;Things that did not fit elsewhere.&lt;/p&gt;
&lt;p&gt;A/ Python based hash compression.&lt;/p&gt;
&lt;div class=&quot;scroll-wrapper&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb10&quot;&gt;&lt;pre class=&quot;sourceCode python&quot;&gt;&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span id=&quot;cb10-1&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;&quot;&quot;&quot; XORing directly in base32, thanks to python &quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-2&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-2&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-3&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-3&quot;&gt;&lt;/a&gt;h &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;0fqqilza6ifk0arlay18ab1pfk338f6gzrpcb56pnaw245h8gv9r&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-4&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-4&quot;&gt;&lt;/a&gt;key &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;0123456789abcdfghijklmnpqrsvwxyz&quot;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;# no e,o,u,t&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-5&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-5&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# len(key) == 32&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-6&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-6&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-7&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-7&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; xor(a, b):&lt;/span&gt;
&lt;span id=&quot;cb10-8&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-8&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; key[key.index(a) &lt;span class=&quot;op&quot;&gt;^&lt;/span&gt; key.index(b)]&lt;/span&gt;
&lt;span id=&quot;cb10-9&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-9&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# xor('0', 'a') == 'a'&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-10&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-10&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-11&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-11&quot;&gt;&lt;/a&gt;h1, h2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; h[&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;:], &lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{:0&amp;gt;32}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(h[:&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;])&lt;/span&gt;
&lt;span id=&quot;cb10-12&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-12&quot;&gt;&lt;/a&gt;res &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;.join(xor(h1[i],h2[i]) &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb10-13&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-13&quot;&gt;&lt;/a&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;  &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;^ &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;  ---------------------------------&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;= &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(h1,h2,res))&lt;/span&gt;
&lt;span id=&quot;cb10-14&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-14&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# prints:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-15&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-15&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-16&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-16&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;  ab1pfk338f6gzrpcb56pnaw245h8gv9r&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-17&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-17&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;^ 0000000000000fqqilza6ifk0arlay18&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-18&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-18&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;  ---------------------------------&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-19&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-19&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;= ab1pfk338f6gzpglsirxhvji4g9w558i&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-20&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb10-20&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;B/ Nix source code patch to trace digests being computed.&lt;/p&gt;
&lt;div class=&quot;scroll-wrapper&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb11&quot;&gt;&lt;pre class=&quot;sourceCode diff&quot;&gt;&lt;code class=&quot;sourceCode diff&quot;&gt;&lt;span id=&quot;cb11-1&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;diff --git a/src/libutil/hash.cc b/src/libutil/hash.cc&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-2&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-2&quot;&gt;&lt;/a&gt;index 4a94f0dfd..b06a08c79 100644&lt;/span&gt;
&lt;span id=&quot;cb11-3&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-3&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;--- a/src/libutil/hash.cc&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-4&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-4&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;+++ b/src/libutil/hash.cc&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-5&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-5&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;@@ -316,6 +316,15 @@ Hash hashString(HashType ht, std::string_view s)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-6&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-6&quot;&gt;&lt;/a&gt;     start(ht, ctx);&lt;/span&gt;
&lt;span id=&quot;cb11-7&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-7&quot;&gt;&lt;/a&gt;     update(ht, ctx, (const unsigned char *) s.data(), s.length());&lt;/span&gt;
&lt;span id=&quot;cb11-8&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-8&quot;&gt;&lt;/a&gt;     finish(ht, ctx, hash.hash);&lt;/span&gt;
&lt;span id=&quot;cb11-9&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-9&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+    if (s.length() &amp;gt; 500 &amp;amp;&amp;amp; s.data()[0] != 'D') {&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-10&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-10&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+        warn(&quot;Hashing %d characters with '%s'&quot;, s.length(), ht);&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-11&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-11&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+        warn(&quot;base32: %s&quot;, hash.to_string(Base32, true));&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-12&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-12&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+    } else {&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-13&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-13&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+        warn(&quot;Hashing '%s' with '%s'&quot;, s, ht);&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-14&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-14&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+        warn(&quot;base16: %s&quot;, hash.to_string(Base16, true));&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-15&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-15&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+        warn(&quot;base32: %s&quot;, hash.to_string(Base32, true));&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-16&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-16&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+        warn(&quot;base64: %s&quot;, hash.to_string(Base64, true));&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-17&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-17&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+    }&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-18&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-18&quot;&gt;&lt;/a&gt;     return hash;&lt;/span&gt;
&lt;span id=&quot;cb11-19&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-19&quot;&gt;&lt;/a&gt; }&lt;/span&gt;
&lt;span id=&quot;cb11-20&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-20&quot;&gt;&lt;/a&gt; &lt;/span&gt;
&lt;span id=&quot;cb11-21&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-21&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;@@ -380,6 +389,7 @@ Hash compressHash(const Hash &amp;amp; hash, unsigned int newSize)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-22&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-22&quot;&gt;&lt;/a&gt;     h.hashSize = newSize;&lt;/span&gt;
&lt;span id=&quot;cb11-23&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-23&quot;&gt;&lt;/a&gt;     for (unsigned int i = 0; i &amp;lt; hash.hashSize; ++i)&lt;/span&gt;
&lt;span id=&quot;cb11-24&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-24&quot;&gt;&lt;/a&gt;         h.hash[i % newSize] ^= hash.hash[i];&lt;/span&gt;
&lt;span id=&quot;cb11-25&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-25&quot;&gt;&lt;/a&gt;&lt;span class=&quot;va&quot;&gt;+    warn(&quot;Compressed '%s' to size %d: '%s'&quot;, hash.to_string(Base32, false), newSize, h.to_string(Base32, false));&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb11-26&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-26&quot;&gt;&lt;/a&gt;     return h;&lt;/span&gt;
&lt;span id=&quot;cb11-27&quot;&gt;&lt;a href=&quot;https://blog.layus.be/tags/nix.rss#cb11-27&quot;&gt;&lt;/a&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;C/ The full log of hashes generated for out &lt;code&gt;pkgs.hello&lt;/code&gt; example with the above logging patch is available on &lt;a href=&quot;https://gist.github.com/551fcccf4ddc1a851bc818ad2d21f8fb&quot;&gt;gist&lt;/a&gt;.&lt;/p&gt;
&lt;/article&gt;</description>
	<pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>nixbuild.net: nixbuild.net is Generally Available</title>
	<guid isPermaLink="true">https://blog.nixbuild.net/posts/2020-08-28-nixbuild-net-is-generally-available.html</guid>
	<link>https://blog.nixbuild.net/posts/2020-08-28-nixbuild-net-is-generally-available.html</link>
	<description>&lt;p&gt;Today, &lt;a href=&quot;https://nixbuild.net&quot;&gt;nixbuild.net&lt;/a&gt; is exiting private beta and made generally available! Anyone can now &lt;a href=&quot;https://nixbuild.net#register&quot;&gt;sign up&lt;/a&gt; for a nixbuild.net account and immediately start building using the free CPU hours included with every account.&lt;/p&gt;
&lt;p&gt;After the free CPU hours have been consumed, the pricing is simple: 0.12 EUR (excl. VAT) per CPU hour consumed, billed monthly.&lt;/p&gt;

&lt;p&gt;As part of this GA announcement, a number of marketing and documentation improvements have been published:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A much improved and redesigned landing page at &lt;a href=&quot;https://nixbuild.net&quot;&gt;https://nixbuild.net&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An extensive &lt;a href=&quot;https://nixbuild.net#faq&quot;&gt;FAQ&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A reworked &lt;a href=&quot;https://docs.nixbuild.net/getting-started&quot;&gt;Getting Started&lt;/a&gt; guide&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Proper documentation of the &lt;a href=&quot;https://docs.nixbuild.net/nixbuild-shell&quot;&gt;nixbuild.net shell&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;We’re really happy for nixbuild.net to enter this new phase — making simple, performant and scalable remote builds available to every Nix user! We’re excited to see how the service is used, and we have lots of plans for the future of nixbuild.net.&lt;/strong&gt;&lt;/p&gt;</description>
	<pubDate>Fri, 28 Aug 2020 00:00:00 +0000</pubDate>
	<author>support@nixbuild.net (nixbuild.net)</author>
</item>
<item>
	<title>Tweag I/O: How Nix grew a marketing team</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-08-20-how-nix-grew-a-marketing-team/</guid>
	<link>https://tweag.io/blog/2020-08-20-how-nix-grew-a-marketing-team/</link>
	<description>&lt;p&gt;Recently I witnessed the moment when a potential Nix user reached eureka.
The moment where everything regarding Nix made sense.
My friend, now a Nix user, screamed from joy: &lt;strong&gt;“We need to Nix–ify everything!”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Moments like these reinforce my belief that Nix is a solution from — and for — the future.
A solution that could reach many more people, only if learning about Nix didn’t demand investing as much time and effort as it does now.&lt;/p&gt;
&lt;p&gt;I think that Nix has the perfect foundation for becoming a success but that it still needs better &lt;em&gt;marketing&lt;/em&gt;.
Many others agree with me, and that’s why we formed the &lt;a href=&quot;https://nixos.org/teams/marketing.html&quot;&gt;Nix marketing team&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would like to convince you that indeed, marketing is the way to go and that it is worth it.
Therefore, in this post I will share my thoughts on what kind of success we aim for, and which marketing efforts we are currently pursuing.
The marketing team is already giving its first results, and with your input, we can go further.&lt;/p&gt;
&lt;h2&gt;What does success look like?&lt;/h2&gt;
&lt;p&gt;At the time of writing this post, I have been using Nix for 10 years.
I organized one and attended most of the Nix conferences since then, and talked to many people in the community.
All of this does not give me the authority to say what success for Nix looks like, but it does give me a great insight into what we — the Nix community — can agree on.&lt;/p&gt;
&lt;p&gt;Success for Nix would be the next time you encounter a project on GitHub, it would already contain a &lt;code class=&quot;language-text&quot;&gt;default.nix&lt;/code&gt; for you to start developing.
Success for Nix would be the next time you try to run a server on the cloud, NixOS would be offered to you.
Or even more ambitious, would be other communities recognising Nix as a &lt;em&gt;de facto&lt;/em&gt; standard that improves the industry as a whole.&lt;/p&gt;
&lt;p&gt;To some, this success statement may seem very obvious.
However, it is important to say it out loud and often, so we can keep focus, and keep working on the parts of Nix that will contribute the most to this success.&lt;/p&gt;
&lt;h2&gt;The importance of marketing&lt;/h2&gt;
&lt;p&gt;Before we delve into what Nix still lacks, I would like to say that we — engineers and developers — should be aware of our bias against marketing.
This bias becomes clear when we think about what we think are the defining aspects for a project’s success.
We tend to believe that code is everything, and that good code leads to good results.
But what if I tell you that good marketing constitutes more than 50% of the success of a project?
Would you be upset?
We have to overcome this bias, since it prevents us from seeing the big picture.&lt;/p&gt;
&lt;p&gt;Putting aside those Sunday afternoons when I code for the pure joy of stretching my mind, most of the time I simply want to solve a problem.
The joy when seeing others realizing that their problem is not a problem anymore, is one of the best feelings I experienced as a developer.
This is what drives me.
Not the act of coding itself, but the act of solving the problem.
Coding is then only part of the solution.
Others need to know about the existence of your code, understand how it can solve their problem and furthermore they need to know how to use it.&lt;/p&gt;
&lt;p&gt;That is why marketing, and, more generally, non-technical work, is at least as important as technical work.
Documentation, writing blog posts, creating content for the website, release announcements, conference talks, conference booths, forums, chat channels, email lists, demo videos, use cases, swag, search engine optimisation, social media presence, engaging with the community…
These are all crucial parts of any successful project.&lt;/p&gt;
&lt;p&gt;Nix needs better marketing, from a better website to better documentation, along with all the ingredients mentioned above.
If we want Nix to grow as a project we need to improve our marketing game, since this is the area of work that is historically receiving the least amount of attention.
And we are starting to work on it.
In the middle of March 2020, a bunch of us got together and &lt;a href=&quot;https://discourse.nixos.org/t/marketing-team-can-we-present-nix-nixos-better/6249&quot;&gt;announced&lt;/a&gt; the creation of &lt;a href=&quot;https://nixos.org/teams/marketing.html&quot;&gt;the Nix marketing team&lt;/a&gt;.
Since then we meet roughly every two weeks to discuss and work on non-technical challenges that the Nix project is facing.&lt;/p&gt;
&lt;p&gt;But before the Nix marketing team could start doing any actual work we had to answer an important question:&lt;/p&gt;
&lt;h2&gt;What is Nix?&lt;/h2&gt;
&lt;p&gt;I want to argue that the Nix community is still missing an answer to an apparently very simple question: &lt;em&gt;What is Nix?&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The reason why &lt;em&gt;what is Nix?&lt;/em&gt; is a harder question than it may appear at first, is that any complete answer has to tell us &lt;em&gt;what&lt;/em&gt; and &lt;em&gt;who&lt;/em&gt; Nix is for.
Knowing the audience and primary use cases is a precondition to improving the website, documentation, or even Nix itself.&lt;/p&gt;
&lt;p&gt;This is what the Nix marketing team &lt;a href=&quot;https://www.youtube.com/watch?list=PLt4-_lkyRrOOO8CYo5XPx6UI05q8kwhj0&quot;&gt;discussed first&lt;/a&gt;. We identified the following audiences and primary use cases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Development environments (audience: developers)&lt;/li&gt;
&lt;li&gt;Deploying to the cloud (audience: system administrators)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It doesn’t mean other use cases are not important — they are.
We are just using the primary use cases as a gateway drug into the rest of the Nix’s ecosystem.
In this way, new users will not be overwhelmed with all the existing options and will have a clear idea where to start.&lt;/p&gt;
&lt;p&gt;Some reasons for selecting the two use cases are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Both use cases are relatively polished solutions.
Clearly, there is still much to be improved, but currently these are the two use cases with the best user experience in the Nix ecosystem.&lt;/li&gt;
&lt;li&gt;One use case is a natural continuation of another.
First, you develop and then you can use the same tools to package and deploy.&lt;/li&gt;
&lt;li&gt;Market size for both use cases is huge, which means there is a big potential.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A differentiating factor — why somebody would choose Nix over others — is Nix’s ability to provide reproducible results.
The promise of reproducibility is the aspect that already attracts the majority of Nix’s user base.
From this, we came up with a slogan for Nix:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reproducible builds and deploys&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With the basic question answered we started working.&lt;/p&gt;
&lt;h2&gt;What has been done so far? How can I help?&lt;/h2&gt;
&lt;p&gt;So far, the Marketing team focused on improving the website:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Moved the website to Netlify.&lt;/strong&gt;
The important part is not switching to Netlify, but separating the website from the Nix infrastructure.
This removes the fear of a website update bringing down parts of Nix infrastructure.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Simplified navigation.&lt;/strong&gt;
If you remember, the navigation was different for each project that was listed on the website.
We removed the project differentiation and unified navigation.
This will show Nix ecosystem as a unified story and not a collection of projects.
One story is easier to follow than five.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Created a new learn page.&lt;/strong&gt;
Discoverability of documentation was a huge problem.
Links to popular topics in manuals are now more visible.
Some work on entry level tutorials has also started.
Good and beginner friendly learning resources are what is going to create the next generation of Nix users.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Created new team pages.&lt;/strong&gt;
We collected information about different official and less official teams working on Nix.
The work here is not done, but it shows that many teams don’t have clear responsibilities.
It shows how decisions are made and invites new Nix users to become more involved with the project.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Improved landing page.&lt;/strong&gt;
Instead of telling the user what Nix is, they will experience it from the start.
The landing page is filled with examples that will convince visitors to give Nix a try.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The work of the marketing team has just started, and there is still a lot to be done.
We are working hard on &lt;a href=&quot;https://github.com/NixOS/nixos-homepage/issues/449&quot;&gt;redesigning the website&lt;/a&gt; and &lt;a href=&quot;https://github.com/NixOS/nixos-homepage/issues/444&quot;&gt;improving the messaging&lt;/a&gt;.
The &lt;a href=&quot;https://github.com/NixOS/nixos-homepage/milestone/1&quot;&gt;roadmap&lt;/a&gt; will tell you more about what to expect next.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;If you wish to help&lt;/strong&gt; come and say hi to &lt;a href=&quot;irc://irc.freenode.net/#nixos-marketing&quot;&gt;#nixos-marketing on irc.freenode.org&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Marketing, and non-technical work, is all too often an afterthought for developers. I really wish it weren’t the case.
Having clearly defined problems, audience and strategy should be as important to us as having clean and tested code.
This is important for Nix. This is important for any project that aims to succeed.&lt;/p&gt;</description>
	<pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>nixbuild.net: Build Reuse in nixbuild.net</title>
	<guid isPermaLink="true">https://blog.nixbuild.net/posts/2020-08-13-build-reuse-in-nixbuild-net.html</guid>
	<link>https://blog.nixbuild.net/posts/2020-08-13-build-reuse-in-nixbuild-net.html</link>
	<description>&lt;p&gt;Performance and cost-effectiveness are core values for nixbuild.net. How do you make a Nix build as performant and cheap as possible? The answer is — by not running it at all!&lt;/p&gt;
&lt;p&gt;This post goes into some detail about the different ways nixbuild.net is able to safely reuse build results. The post gets technical, but the main message is that nixbuild.net really tries to avoid building if it can, in order to save time and money for its users.&lt;/p&gt;

&lt;h2 id=&quot;binary-caches&quot;&gt;Binary Caches&lt;/h2&gt;
&lt;p&gt;The most obvious way of reusing build results is by utilising binary caches, and an &lt;a href=&quot;https://blog.nixbuild.net/posts/2020-04-18-binary-cache-support.html&quot;&gt;earlier blog post&lt;/a&gt; described how this is supported by nixbuild.net. In short, if something has been built on &lt;code&gt;cache.nixos.org&lt;/code&gt;, nixbuild.net can skip building it and just fetch it. It is also possible to configure other binary caches to use, and even treat the builds of specific nixbuild.net users in the same way as a trusted binary cache.&lt;/p&gt;
&lt;h2 id=&quot;no-shared-uploads&quot;&gt;No Shared Uploads&lt;/h2&gt;
&lt;p&gt;As part of the Nix remote build protocol, inputs (dependencies) can be uploaded directly to nixbuild.net. Those inputs are not necessarily trustworty, because we don’t know how they were produced. Therefore, those inputs are only allowed to be used by the user who uploaded them. The exception is if the uploaded input had a signature from a binary cache key, then we allow it to be used by all accounts that trust that specific key. Also, if explicit trust has been setup between two accounts, uploaded paths will be shared.&lt;/p&gt;
&lt;h2 id=&quot;derivation-sharing&quot;&gt;Derivation Sharing&lt;/h2&gt;
&lt;p&gt;Another method of reuse, unique to nixbuild.net, is the sharing of build results between users that don’t necessarily trust each other. It works like this:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;When we receive a build request, we get a &lt;a href=&quot;https://nixos.org/nixos/nix-pills/our-first-derivation.html&quot;&gt;derivation&lt;/a&gt; from the user’s Nix client. In essence, this derivation describes what inputs (dependencies) the build needs, and what commands must be run to produce the build output.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The inputs are described in the derivation simply as a list of store paths (&lt;code&gt;/nix/store/abc&lt;/code&gt;, &lt;code&gt;/nix/store/xyz&lt;/code&gt;). The way the Nix remote build protocol works, those store paths have already been provided to us, either because we already had trusted variants of them in our storage, or because we’ve downloaded them from binary caches, or because the client uploaded them to us.&lt;/p&gt;
&lt;p&gt;In order for us to be able to run the build, we need to map the input store paths to the actual file contents of the inputs. This mapping can actually vary even though store paths are the same. This is because a Nix store path does not depend on the &lt;em&gt;contents&lt;/em&gt; of the path, but rather on the &lt;em&gt;dependencies&lt;/em&gt; of the path. So we can very well have multiple versions of the same store path in our storage, because multiple users might have uploaded differing builds of the same paths.&lt;/p&gt;
&lt;p&gt;Anyhow, we will end up with a mapping that depends entirely on what paths the user is allowed to use. So, two users may build the exact same derivation but get different store-path-to-content mappings.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;At this stage, we store a representation of both the derivation itself, and the mapping described in previous step. Together, these two pieces represent a unique derivation in nixbuild.net’s database.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now, we can build the derivation. The build runs inside an isolated, virtualized sandbox that has no network access and nothing other than its inputs inside its filesystem.&lt;/p&gt;
&lt;p&gt;The sandbox is of course vital for keeping your builds secure, but it has another application, too: If we already have built a specific derivation (with a specific set of input content), this build result can be reused for &lt;em&gt;any&lt;/em&gt; user that comes along and requests a build of the exact same derivation with the exact same set of input content.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We do not yet have any numbers on how big impact this type of build result sharing has in practice. The effectiveness will depend on how reproducible the builds are, and of course also on how many users that are likely to build the same derivations.&lt;/p&gt;
&lt;p&gt;For an organization with a large set of custom packages that want to share binary builds with contributors and users, it could turn out useful. The benefit for users is that they don’t actually have to blindly trust a binary cache but instead can be sure that they get binaries that correspond to the nix derivations they have evaluated.&lt;/p&gt;</description>
	<pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate>
	<author>support@nixbuild.net (nixbuild.net)</author>
</item>
<item>
	<title>Tweag I/O: Developing Python with Poetry &amp; Poetry2nix: Reproducible flexible Python environments</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-08-12-poetry2nix/</guid>
	<link>https://tweag.io/blog/2020-08-12-poetry2nix/</link>
	<description>&lt;p&gt;Most Python projects are in fact &lt;em&gt;polyglot&lt;/em&gt;.
Indeed, many popular libraries on &lt;a href=&quot;https://pypi.org&quot;&gt;PyPi&lt;/a&gt; are Python wrappers around C code.
This applies particularly to popular scientific computing packages, such as &lt;code class=&quot;language-text&quot;&gt;scipy&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;numpy&lt;/code&gt;.
Normally, this is the terrain where Nix shines, but its support for Python projects has often been labor-intensive, requiring lots of manual fiddling and fine-tuning.
One of the reasons for this is that most Python package management tools do not give enough static information about the project, not offering the determinism needed by Nix.&lt;/p&gt;
&lt;p&gt;Thanks to &lt;a href=&quot;https://python-poetry.org/&quot;&gt;Poetry&lt;/a&gt;, this is a problem of the past — its rich lock file offers more than enough information to get Nix running, with minimal manual intervention.
In this post, I will show how to use Poetry, together with &lt;a href=&quot;https://github.com/nix-community/poetry2nix&quot;&gt;Poetry2nix&lt;/a&gt;, to easily manage Python projects with Nix.
I will show how to package a simple Python application both using the existing support for Python in Nixpkgs, and then using Poetry2nix.
This will both show why Poetry2nix is more convenient, and serve as a short tutorial covering its features.&lt;/p&gt;
&lt;h2&gt;Our application&lt;/h2&gt;
&lt;p&gt;We are going to package a simple application, a &lt;a href=&quot;https://flask.palletsprojects.com&quot;&gt;Flask&lt;/a&gt; server with two endpoints: one returning a static string “Hello World” and another returning a resized image.
This application was chosen because:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It can fit into a single file for the purposes of this post.&lt;/li&gt;
&lt;li&gt;Image resizing using Pillow requires the use of native libraries, which is something of a strength of Nix.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The code for it is in the &lt;code class=&quot;language-text&quot;&gt;imgapp/__init__.py&lt;/code&gt; file:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; send_file
&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Flask
&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; io &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; BytesIO
&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; PIL &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Image
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; requests


app &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Flask&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__name__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;


IMAGE_URL &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;https://farm1.staticflickr.com/422/32287743652_9f69a6e9d9_b.jpg&quot;&lt;/span&gt;
IMAGE_SIZE &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;route&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;


&lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;route&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;'/image'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    r &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; requests&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;get&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;IMAGE_URL&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;not&lt;/span&gt; r&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;status_code &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;raise&lt;/span&gt; ValueError&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string-interpolation&quot;&gt;&lt;span class=&quot;token string&quot;&gt;f&quot;Response code was '&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;r&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;status_code&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;'&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    img_io &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; BytesIO&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    img &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Image&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;BytesIO&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;r&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;content&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    img&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;thumbnail&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;IMAGE_SIZE&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    img&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;save&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;img_io&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;'JPEG'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; quality&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    img_io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;seek&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; send_file&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;img_io&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; mimetype&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;'image/jpeg'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;run&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; __name__ &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    main&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;The status quo for packaging Python with Nix&lt;/h2&gt;
&lt;p&gt;There are two standard techniques for integrating Python projects with Nix.&lt;/p&gt;
&lt;h3&gt;Nix only&lt;/h3&gt;
&lt;p&gt;The first technique uses only Nix for package management, and is described in the &lt;a href=&quot;https://nixos.org/nixpkgs/manual/#python&quot;&gt;Python section&lt;/a&gt; of the Nix manual.
While it works and may look very appealing on the surface, it uses Nix for all package management needs, which comes with some drawbacks:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We are essentially tied to whatever package version Nixpkgs provides for any given dependency.
This can be worked around with overrides, but those can cause version incompatibilities.
This happens often in complex Python projects, such as data science ones, which tend to be very sensitive to version changes.&lt;/li&gt;
&lt;li&gt;We are tied to using packages already in Nixpkgs.
While Nixpkgs has many Python packages already packaged up (around 3000 right now) there are many packages missing — PyPi, the Python Package Index has more than 200000 packages.
This can of course be worked around with overlays and manual packaging, but this quickly becomes a daunting task.&lt;/li&gt;
&lt;li&gt;In a team setting, every team member wanting to add packages needs to buy in to Nix and at least have some experience using and understanding Nix.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;All these factors lead us to a conclusion: we need to embrace Python tooling so we can efficiently work with the entire Python ecosystem.&lt;/p&gt;
&lt;h3&gt;Pip and Pypi2Nix&lt;/h3&gt;
&lt;p&gt;The second standard method tries to overcome the faults above by using a hybrid approach of Python tooling together with Nix code generation.
Instead of writing dependencies manually in Nix, they are extracted from the &lt;code class=&quot;language-text&quot;&gt;requirements.txt&lt;/code&gt; file that users of Pip and Virtualenv are very used to.
That is, from a &lt;code class=&quot;language-text&quot;&gt;requirements.txt&lt;/code&gt; file containing the necessary dependencies:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-txt&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;requests
pillow
flask&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we can use &lt;a href=&quot;https://github.com/nix-community/pypi2nix&quot;&gt;pypi2nix&lt;/a&gt; to package our application in a more automatic fashion than before:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;nix-shell -p pypi2nix --run &quot;pypi2nix -r requirements.txt&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, Pip is not a dependency manager and therefore the &lt;code class=&quot;language-text&quot;&gt;requirements.txt&lt;/code&gt; file is not explicit enough — it lacks both exact versions for libraries, and system dependencies.
Therefore, the command above will not produce a working Nix expression.
In order to make pypi2nix work correctly, one has to manually find all dependencies incurred by the use of Pillow:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;nix-shell -p pypi2nix --run &quot;pypi2nix -V 3.8 -E pkgconfig -E freetype -E libjpeg -E openjpeg -E zlib -E libtiff -E libwebp -E tcl -E lcms2 -E xorg.libxcb -r requirements.txt&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will generate a large Nix expression, that will indeed work as expected.
Further use of Pypi2nix is left to the reader, but we can already draw some conclusions about this approach:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Code generation results in huge Nix expressions that can be hard to debug and understand.
These expressions will typically be checked into a project repository, and can get out of sync with actual dependencies.&lt;/li&gt;
&lt;li&gt;It’s very high friction, especially around native dependencies.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Having many large Python projects, I wasn’t satisfied with the status quo around Python package management.
So I looked into what could be done to make the situation better, and which tools could be more appropriate for our use-case.
A potential candidate was &lt;a href=&quot;https://github.com/pypa/pipenv&quot;&gt;Pipenv&lt;/a&gt;, however its dependency
solver and lock file format were difficult to work with.
In particular, Pipenv’s detection of “local” vs “non-local” dependencies did not work properly inside the Nix shell and gave us the wrong dependency graph.
Eventually, I found &lt;a href=&quot;https://python-poetry.org/&quot;&gt;Poetry&lt;/a&gt; and it looked very promising.&lt;/p&gt;
&lt;h2&gt;Poetry and Poetry2nix&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&quot;https://python-poetry.org/docs/&quot;&gt;Poetry package manager&lt;/a&gt; is a relatively recent addition to the Python ecosystem but it is gaining popularity very quickly.
Poetry features a nice CLI with good UX and deterministic builds through lock files.&lt;/p&gt;
&lt;p&gt;Poetry uses &lt;code class=&quot;language-text&quot;&gt;pip&lt;/code&gt; under the hood and, for this reason, inherited some of its shortcomings and lock file design.
I managed to land a few patches in Poetry before the 1.0 release to improve the lock file format, and now it is fit for use in Nix builds.
The result was &lt;a href=&quot;https://github.com/nix-community/poetry2nix&quot;&gt;Poetry2nix&lt;/a&gt;, whose key design goals were:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dead simple API.&lt;/li&gt;
&lt;li&gt;Work with the entire Python ecosystem using regular Python tooling.&lt;/li&gt;
&lt;li&gt;Python developers should not have to be Nix experts, and vice versa.&lt;/li&gt;
&lt;li&gt;Being an expert should allow you to “drop down” into the lower levels of the build and customise it.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Poetry2nix is not a code generation tool — it is implemented in pure Nix.
This fixes many of problems outlined in previous paragraphs, since there is a single point of truth for dependencies and their versions.&lt;/p&gt;
&lt;p&gt;But what about our native dependencies from before?
How does Poetry2nix know about those?
Indeed, Poetry2nix comes with an extensive set of overrides built-in for a lot of common packages, including Pillow.
Users are encouraged to contribute overrides &lt;a href=&quot;https://github.com/nix-community/poetry2nix/blob/master/overrides.nix&quot;&gt;upstream&lt;/a&gt; for popular packages, so everyone can have a better user experience.&lt;/p&gt;
&lt;p&gt;Now, let’s see how Poetry2nix works in practice.&lt;/p&gt;
&lt;h3&gt;Developing with Poetry&lt;/h3&gt;
&lt;p&gt;Let’s start with only our application file above (&lt;code class=&quot;language-text&quot;&gt;imgapp/__init__.py&lt;/code&gt;) and a &lt;code class=&quot;language-text&quot;&gt;shell.nix&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; pkgs &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;nixpkgs&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;

pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mkShell &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

  buildInputs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;python3
    pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;poetry
  &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Poetry comes with some nice helpers to create a project, so we run:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;$ poetry init&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then we’ll add our dependencies:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;$ poetry add requests pillow flask&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We now have two files in the folder:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first one is &lt;code class=&quot;language-text&quot;&gt;pyproject.toml&lt;/code&gt; which not only specifies our dependencies but also replaces &lt;code class=&quot;language-text&quot;&gt;setup.py&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The second is &lt;code class=&quot;language-text&quot;&gt;poetry.lock&lt;/code&gt; which contains our entire pinned Python dependency graph.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For Nix to know which scripts to install in the &lt;code class=&quot;language-text&quot;&gt;bin/&lt;/code&gt; output directory, we also need to add a &lt;code class=&quot;language-text&quot;&gt;scripts&lt;/code&gt; section to &lt;code class=&quot;language-text&quot;&gt;pyproject.toml&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-toml&quot;&gt;&lt;code class=&quot;language-toml&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;tool.poetry&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;imgapp&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;description&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;authors&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;adisbladis &amp;lt;adisbladis@gmail.com&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;tool.poetry.dependencies&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;python&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;^3.7&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;requests&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;^2.23.0&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;pillow&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;^7.1.2&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;^1.1.2&quot;&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;tool.poetry.dev-dependencies&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;tool.poetry.scripts&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;imgapp&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;'imgapp:main'&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;build-system&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;requires&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;poetry&amp;gt;=0.12&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;build-backend&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;poetry.masonry.api&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Packaging with Poetry2nix&lt;/h3&gt;
&lt;p&gt;Since Poetry2nix is not a code generation tool but implemented entirely in Nix, this step is trivial.
Create a &lt;code class=&quot;language-text&quot;&gt;default.nix&lt;/code&gt; containing:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; pkgs &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;nixpkgs&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;poetry2nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mkPoetryApplication &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  projectDir &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token url&quot;&gt;./.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can now invoke &lt;code class=&quot;language-text&quot;&gt;nix-build&lt;/code&gt; to build our package defined in &lt;code class=&quot;language-text&quot;&gt;default.nix&lt;/code&gt;.
Poetry2nix will automatically infer package names, dependencies, meta attributes and more from the Poetry metadata.&lt;/p&gt;
&lt;h3&gt;Manipulating overrides&lt;/h3&gt;
&lt;p&gt;Many overrides for system dependencies are already upstream, but what if some are lacking?
These overrides can be manipulated and extended manually:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;poetry2nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mkPoetryApplication &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    projectDir &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token url&quot;&gt;./.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    overrides &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; poetry2nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;overrides&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;withDefaults &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; super&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;overridePythonAttrs&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldAttrs&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;By embracing both modern Python package management tooling and the Nix language, we can achieve best-in-class user experience for Python developers and Nix developers alike.&lt;/p&gt;
&lt;p&gt;There are ongoing efforts to make Poetry2nix and other Nix Python tooling work better with data science packages like &lt;code class=&quot;language-text&quot;&gt;numpy&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;scipy&lt;/code&gt;.
I believe that Nix may soon rival Conda on Linux and MacOS for data science.&lt;/p&gt;
&lt;p&gt;Python + Nix has a bright future ahead of it!&lt;/p&gt;</description>
	<pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Sander van der Burg: Experimenting with Nix and the service management properties of Docker</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-4809008011877447165</guid>
	<link>http://sandervanderburg.blogspot.com/2020/08/experimenting-with-nix-and-service.html</link>
	<description>In &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/07/on-using-nix-and-docker-as-deployment.html&quot;&gt;the previous blog post&lt;/a&gt;, I have analyzed &lt;a href=&quot;https://nixos.org/nix&quot;&gt;Nix&lt;/a&gt; and &lt;a href=&quot;https://www.docker.com&quot;&gt;Docker&lt;/a&gt; as deployment solutions and described in what ways these solutions are similar and different.&lt;br /&gt;&lt;br /&gt;To summarize my findings:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://sandervanderburg.blogspot.com/2012/11/an-alternative-explaination-of-nix.html&quot;&gt;Nix&lt;/a&gt; is a &lt;strong&gt;source-based package manager&lt;/strong&gt; responsible for obtaining, installing, configuring and upgrading packages in a reliable and reproducible manner and facilitating the construction of packages from source code and their dependencies.&lt;/li&gt;&lt;li&gt;Docker's purpose is to fully &lt;strong&gt;manage&lt;/strong&gt; the life-cycle of &lt;strong&gt;applications&lt;/strong&gt; (services and ordinary processes) in a reliable and reproducible manner, including their deployments.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;As explained in my previous blog post, two prominent goals both solutions have in common is to facilitate &lt;strong&gt;reliable&lt;/strong&gt; and &lt;strong&gt;reproducible&lt;/strong&gt; deployment. They both use different kinds of techniques to accomplish these goals.&lt;br /&gt;&lt;br /&gt;Although Nix and Docker can be used for a variety of comparable use cases (such as constructing images, deploying test environments, and constructing packages from source code), one prominent feature that the Nix package manager does not provide is &lt;strong&gt;process&lt;/strong&gt; (or service) &lt;strong&gt;management&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;In a Nix-based workflow you need to augment Nix with another solution that can facilitate process management.&lt;br /&gt;&lt;br /&gt;In this blog post, I will investigate how Docker could fulfill this role -- it is pretty much the opposite goal of the combined use cases scenarios I have shown in the previous blog post, in which Nix can overtake the role  of a conventional package manager in supplying packages in the construction process of an image and even the complete construction process of images.&lt;br /&gt;  &lt;br /&gt;&lt;h2&gt;Existing Nix integrations with process management&lt;/h2&gt;&lt;br /&gt;Although Nix does not do any process management, there are sister projects that can, such as:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/01/nixos-purely-functional-linux.html&quot;&gt;&lt;strong&gt;NixOS&lt;/strong&gt;&lt;/a&gt; builds entire machine configurations from a single declarative deployment specification and uses the Nix package manager to deploy and isolate all static artifacts of a system. It will also automatically generate and deploy &lt;a href=&quot;https://freedesktop.org/wiki/Software/systemd/&quot;&gt;systemd&lt;/a&gt; units for services defined in a NixOS configuration.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/LnL7/nix-darwin&quot;&gt;&lt;strong&gt;nix-darwin&lt;/strong&gt;&lt;/a&gt; can be used to specify a collection of services in a deployment specification and uses the Nix package manager to deploy all services and their corresponding &lt;a href=&quot;https://www.launchd.info/&quot;&gt;launchd&lt;/a&gt; configuration files.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Although both projects do a great job (e.g. they both provide a big collection of deployable services) what I consider a disadvantage is that they are &lt;strong&gt;platform specific&lt;/strong&gt; -- both solutions only work on a single operating system (Linux and macOS) and a single process management solution (systemd and launchd).&lt;br /&gt;&lt;br /&gt;If you are using Nix in a different environment, such as a different operating system, a conventional (non-NixOS) Linux distribution, or a different process manager, then there is no off-the-shelf solution that will help you managing services for packages provided by Nix.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Docker functionality&lt;/h2&gt;&lt;br /&gt;Docker could be considered a multi-functional solution for application management. I can categorize its functionality as follows:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Process management&lt;/strong&gt;. The life-cycle of a container is bound to the life-cycle of a root process that needs to be started or stopped.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Dependency management&lt;/strong&gt;. To ensure that applications have all the dependencies that they need and that no dependency is missing, Docker uses &lt;strong&gt;images&lt;/strong&gt; containing a complete root filesystem with all required files to run an application.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Resource isolation&lt;/strong&gt; is heavily used for a variety of different reasons:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Foremost, to ensure that the root filesystem of the container does not conflict with the host system's root filesystem.&lt;/li&gt;&lt;li&gt;It is also used to prevent conflicts with other kinds of resources. For example, the isolated network interfaces allow services to bind to the same TCP ports that may also be in use by the host system or other containers.&lt;/li&gt;&lt;li&gt;It offers some degree of protection. For example, a malicious process will not be able to see or control a process belonging to the host system or a different container.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Resource restriction&lt;/strong&gt; can be used to limit the amount of system resources that a process can consume, such as the amount of RAM.&lt;br /&gt;&lt;br /&gt;Resource restriction can be useful for a variety of reasons, for example, to prevent a service from eating up all the system's resources affecting the stability of the system as a whole.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Integrations&lt;/strong&gt; with the host system (e.g. volumes) and other services.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;As described in the previous blog post, Docker uses a number of key concepts to implement the functionality shown above, such as layers, &lt;a href=&quot;https://man7.org/linux/man-pages/man7/namespaces.7.html&quot;&gt;&lt;strong&gt;namespaces&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://man7.org/linux/man-pages/man7/cgroups.7.html&quot;&gt;&lt;strong&gt;cgroups&lt;/strong&gt;&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Developing a Nix-based process management solution&lt;/h2&gt;&lt;br /&gt;For quite some time, &lt;a href=&quot;https://sandervanderburg.blogspot.com/2019/11/a-nix-based-functional-organization-for.html&quot;&gt;I have been investigating the process management domain&lt;/a&gt; and worked on a &lt;a href=&quot;https://github.com/svanderburg/nix-processmgmt&quot;&gt;prototype solution&lt;/a&gt; to provide a more generalized infrastructure that complements Nix with process management -- I came up with an experimental Nix-based process manager-agnostic framework that has the following objectives:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;It uses Nix to &lt;strong&gt;deploy&lt;/strong&gt; all required &lt;strong&gt;packages&lt;/strong&gt; and other &lt;strong&gt;static artifacts&lt;/strong&gt; (such as configuration files) that a service needs.&lt;/li&gt;&lt;li&gt;It integrates with a &lt;strong&gt;variety&lt;/strong&gt; of process managers on a variety of operating systems. So far, it can work with: sysvinit scripts, BSD rc scripts, supervisord, systemd, cygrunsrv and launchd.&lt;br /&gt;  &lt;br /&gt;  In addition to process managers, it can also &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/05/deploying-heterogeneous-service.html&quot;&gt;automatically convert a processes model to deployment specifications that Disnix can consume&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;It uses &lt;strong&gt;declarative&lt;/strong&gt; specifications to define functions that construct managed processes and process instances.&lt;br /&gt;  &lt;br /&gt;  Processes can be declared in a process-manager specific and &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/02/a-declarative-process-manager-agnostic.html&quot;&gt;process-manager agnostic&lt;/a&gt; way. The latter makes it possible to target all six supported process managers with the same declarative specification, albeit with a limited set of features.&lt;/li&gt;&lt;li&gt;It allows you to run &lt;strong&gt;multiple instances&lt;/strong&gt; of processes, by introducing a convention to cope with potential resource conflicts between process instances -- instance properties and potential conflicts can be configured with function parameters and can be changed in such a way that they do not conflict.&lt;/li&gt;&lt;li&gt;It can facilitate &lt;strong&gt;unprivileged&lt;/strong&gt; user deployments by using Nix's ability to perform unprivileged package deployments and introducing a convention that allows you to disable user switching.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;To summarize how the solution works from a user point of view, we can write a process manager-agnostic constructor function as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{createManagedProcess, tmpDir}:&lt;br /&gt;{port, instanceSuffix ? &quot;&quot;, instanceName ? &quot;webapp${instanceSuffix}&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  webapp = import ../../webapp;&lt;br /&gt;in&lt;br /&gt;createManagedProcess {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  description = &quot;Simple web application&quot;;&lt;br /&gt;  inherit instanceName;&lt;br /&gt;&lt;br /&gt;  process = &quot;${webapp}/bin/webapp&quot;;&lt;br /&gt;  daemonArgs = [ &quot;-D&quot; ];&lt;br /&gt;&lt;br /&gt;  environment = {&lt;br /&gt;    PORT = port;&lt;br /&gt;    PID_FILE = &quot;${tmpDir}/${instanceName}.pid&quot;;&lt;br /&gt;  };&lt;br /&gt;  user = instanceName;&lt;br /&gt;  credentials = {&lt;br /&gt;    groups = {&lt;br /&gt;      &quot;${instanceName}&quot; = {};&lt;br /&gt;    };&lt;br /&gt;    users = {&lt;br /&gt;      &quot;${instanceName}&quot; = {&lt;br /&gt;        group = instanceName;&lt;br /&gt;        description = &quot;Webapp&quot;;&lt;br /&gt;      };&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  overrides = {&lt;br /&gt;    sysvinit = {&lt;br /&gt;      runlevels = [ 3 4 5 ];&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The Nix expression above is a nested function that defines in a process manager-agnostic way a configuration for a web application process containing an embedded web server serving a static HTML page.&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The &lt;strong&gt;outer function header&lt;/strong&gt; (first line) refers to parameters that are &lt;strong&gt;common&lt;/strong&gt; to all process instances: &lt;i&gt;createManagedProcess&lt;/i&gt; is a function that can construct process manager configurations and &lt;i&gt;tmpDir&lt;/i&gt; refers to the directory in which temp files are stored (which is &lt;i&gt;/tmp&lt;/i&gt; in conventional Linux installations).&lt;/li&gt;  &lt;li&gt;The &lt;strong&gt;inner function header&lt;/strong&gt; (second line) refers to &lt;strong&gt;instance parameters&lt;/strong&gt; -- when it is desired to construct multiple instances of this process, we must make sure that we have configured these parameters in such as a way that they do not conflict with other processes.&lt;br /&gt;    &lt;br /&gt;    For example, when we assign a unique TCP port and a unique instance name (a property used by the &lt;a href=&quot;http://www.libslack.org/daemon/&quot;&gt;&lt;i&gt;daemon&lt;/i&gt;&lt;/a&gt; tool to create unique PID files) we can safely have multiple instances of this service co-existing on the same system.&lt;/li&gt;  &lt;li&gt;In the body, we invoke the &lt;i&gt;createManagedProcess&lt;/i&gt; function to generate configurations files for a process manager.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;process&lt;/i&gt; parameter specifies the executable that we need to run to start the process.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;daemonArgs&lt;/i&gt; parameter specifies command-line instructions passed to the the process executable, when the process should daemonize itself (the &lt;i&gt;-D&lt;/i&gt; parameter instructs the webapp process to daemonize).&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;environment&lt;/i&gt; parameter specifies all environment variables. Environment variables are used as a generic configuration facility for the service.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;user&lt;/i&gt; parameter specifies the name the process should run as (each process instance has its own user and group with the same name as the instance).&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;credentials&lt;/i&gt; parameter is used to automatically create the group and user that the process needs.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;overrides&lt;/i&gt; parameter makes it possible to override the parameters generated by the &lt;i&gt;createManagedProcess&lt;/i&gt; function with process manager-specific overrides, to configure features that are not universally supported.&lt;br /&gt;&lt;br /&gt;In the example above, we use an override to configure the &lt;a href=&quot;https://wiki.debian.org/RunLevel&quot;&gt;runlevels&lt;/a&gt; in which the service should run (runlevels 3-5 are typically used to boot a system that is network capable). Runlevels are a sysvinit-specific concept.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;In addition to defining constructor functions allowing us to construct zero or more process instances, we also need to construct process instances. These can be defined in a &lt;strong&gt;processes model&lt;/strong&gt;:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{ pkgs ? import &amp;lt;nixpkgs&amp;gt; { inherit system; }&lt;br /&gt;, system ? builtins.currentSystem&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir;&lt;br /&gt;    inherit forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp = rec {&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  nginxReverseProxy = rec {&lt;br /&gt;    port = 8080;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.nginxReverseProxyHostBased {&lt;br /&gt;      webapps = [ webapp ];&lt;br /&gt;      inherit port;&lt;br /&gt;    } {};&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expressions defines two process instances and uses the following conventions:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The first line is a function header in which the function parameters correspond to ajustable properties that apply to all process instances:     &lt;ul&gt;      &lt;li&gt;&lt;i&gt;stateDir&lt;/i&gt; allows you to globally override the base directory in which all state is stored (the default value is: &lt;i&gt;/var&lt;/i&gt;).&lt;/li&gt;      &lt;li&gt;We can also change the locations of each individual state directories: &lt;i&gt;tmpDir&lt;/i&gt;, &lt;i&gt;cacheDir&lt;/i&gt;, &lt;i&gt;logDir&lt;/i&gt;, &lt;i&gt;runtimeDir&lt;/i&gt; etc.) if desired.&lt;/li&gt;      &lt;li&gt;&lt;i&gt;forceDisableUserChange&lt;/i&gt; can be enabled to prevent the process manager to change user permissions and create users and groups. This is useful to facilitate unprivileged user deployments in which the user typically has no rights to change user permissions.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;processManager&lt;/i&gt; parameter allows you to pick a process manager. All process configurations will be automatically generated for the selected process manager.&lt;br /&gt;      &lt;br /&gt;      For example, if we would pick: &lt;i&gt;systemd&lt;/i&gt; then all configurations get translated to systemd units. &lt;i&gt;supervisord&lt;/i&gt; causes all configurations to be translated to supervisord configuration files.&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;  &lt;li&gt;To get access to constructor functions, we import a &lt;strong&gt;constructors expression&lt;/strong&gt; that composes all constructor functions by calling them with their common parameters (not shown in this blog post).&lt;br /&gt;    &lt;br /&gt;    The constructors expression also contains a reference to the Nix expression that deploys the webapp service, shown in our previous example.&lt;/li&gt;  &lt;li&gt;The processes model defines two processes: a &lt;i&gt;webapp&lt;/i&gt; instance that listens to TCP port 5000 and Nginx that acts as a reverse proxy forwarding requests to &lt;i&gt;webapp&lt;/i&gt; process instances based on the virtual host name.&lt;/li&gt;  &lt;li&gt;&lt;i&gt;webapp&lt;/i&gt; is declared a &lt;strong&gt;dependency&lt;/strong&gt; of the &lt;i&gt;nginxReverseProxy&lt;/i&gt; service (by passing &lt;i&gt;webapp&lt;/i&gt; as a parameter to the constructor function of Nginx). This causes &lt;i&gt;webapp&lt;/i&gt; to be activated before the &lt;i&gt;nginxReverseProxy&lt;/i&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;To deploy all process instances with a process manager, we can invoke a variety of tools that are bundled with the experimental Nix process management framework.&lt;br /&gt;&lt;br /&gt;The process model can be deployed as sysvinit scripts for an unprivileged user, with the following command:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nixproc-sysvinit-switch --state-dir /home/sander/var \&lt;br /&gt;  --force-disable-user-change processes.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above command automatically generates sysvinit scripts, changes the base directory of all state folders to a directory in the user's home directory: &lt;i&gt;/home/sander/var&lt;/i&gt; and disables user changing (and creation) so that an unprivileged user can run it.&lt;br /&gt;&lt;br /&gt;The following command uses systemd as a process manager with the default parameters, for production deployments:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nixproc-systemd-switch processes.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above command automatically generates systemd unit files and invokes systemd to deploy the processes.&lt;br /&gt;&lt;br /&gt;In addition to the examples shown above, the framework contains many more tools, such as: &lt;i&gt;nixproc-supervisord-switch&lt;/i&gt;, &lt;i&gt;nixproc-launchd-switch&lt;/i&gt;, &lt;i&gt;nixproc-bsdrc-switch&lt;/i&gt;, &lt;i&gt;nixproc-cygrunsrv-switch&lt;/i&gt;, and &lt;i&gt;nixproc-disnix-switch&lt;/i&gt; that all work with the same processes model.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Integrating Docker into the process management framework&lt;/h2&gt;&lt;br /&gt;Both Docker and the Nix-based process management framework are multi-functional solutions. After comparing the functionality of Docker and the process management framework, I realized that it is possible to integrate Docker into this framework as well, if I would use it in an unconventional way, by disabling or substituting some if its conflicting features.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Using a shared Nix store&lt;/h3&gt;&lt;br /&gt;As explained in the beginning of this blog post, Docker's primary means to provide dependencies is by using images that are self-contained root file systems containing all necessary files (e.g. packages, configuration files) to allow an application to work.&lt;br /&gt;&lt;br /&gt;In the previous blog post, I have also demonstrated that instead of using traditional &lt;i&gt;Dockerfile&lt;/i&gt;s to construct images, we can also use the Nix package manager as a replacement. A Docker image built by Nix is typically smaller than a conventional Docker image built from a base Linux distribution, because it only contains the runtime dependencies that an application actually needs.&lt;br /&gt;&lt;br /&gt;A major disadvantage of using Nix constructed Docker images is that they only consist of one layer -- as a result, there is no reuse between container instances running different services that use common libraries. To alleviate this problem, Nix can also build layered images, in which common dependencies are isolated in separate layers as much as possible.&lt;br /&gt;&lt;br /&gt;There is even a more optimal reuse strategy possible -- when running Docker on a machine that also has Nix installed, we do not need to put anything that is in the Nix store in a disk image. Instead, we can &lt;strong&gt;share&lt;/strong&gt; the host system's Nix store between Docker containers.&lt;br /&gt;&lt;br /&gt;This may sound scary, but as I have explained in the previous blog post, paths in the Nix store are prefixed with SHA256 hash codes. When two Nix store paths with identical hash codes are built on two different machines, their build results should be (nearly) bit-identical. As a result, it is safe to share the same Nix store path between multiple machines and containers.&lt;br /&gt;&lt;br /&gt;A hacky solution to build a container image, without actually putting any of the Nix built packages in the container, can be done with the following expression:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;with import &amp;lt;nixpkgs&amp;gt; {};&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  cmd = [ &quot;${nginx}/bin/nginx&quot; &quot;-g&quot; &quot;daemon off;&quot; &quot;-c&quot; ./nginx.conf ];&lt;br /&gt;in&lt;br /&gt;dockerTools.buildImage {&lt;br /&gt;  name = &quot;nginxexp&quot;;&lt;br /&gt;  tag = &quot;test&quot;;&lt;br /&gt;&lt;br /&gt;  runAsRoot = ''&lt;br /&gt;    ${dockerTools.shadowSetup}&lt;br /&gt;    groupadd -r nogroup&lt;br /&gt;    useradd -r nobody -g nogroup -d /dev/null&lt;br /&gt;    mkdir -p /var/log/nginx /var/cache/nginx /var/www&lt;br /&gt;    cp ${./index.html} /var/www/index.html&lt;br /&gt;  '';&lt;br /&gt;&lt;br /&gt;  config = {&lt;br /&gt;    Cmd = map (arg: builtins.unsafeDiscardStringContext arg) cmd;&lt;br /&gt;    Expose = {&lt;br /&gt;      &quot;80/tcp&quot; = {};&lt;br /&gt;    };&lt;br /&gt;  };                                                                                                                                                                                                                          &lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above expression is quite similar to the Nix-based Docker image example shown in the previous blog post, that deploys Nginx serving a static HTML page.&lt;br /&gt;&lt;br /&gt;The only difference is how I configure the start command (the &lt;i&gt;Cmd&lt;/i&gt; parameter). In the Nix expression language, &lt;a href=&quot;https://shealevy.com/blog/2018/08/05/understanding-nixs-string-context&quot;&gt;strings have &lt;strong&gt;context&lt;/strong&gt;&lt;/a&gt; -- if a string with context is passed to a build function (any string that contains a value that evaluates to a Nix store path), then the corresponding Nix store paths automatically become a dependency of the package that the build function builds.&lt;br /&gt;&lt;br /&gt;By using the unsafe &lt;i&gt;builtins.unsafeDiscardStringContext&lt;/i&gt; function I can discard the context of strings. As a result, the Nix packages that the image requires are still built. However, because their context is discarded they are no longer considered dependencies of the Docker image. As a consequence, they will not be integrated into the image that the &lt;i&gt;dockerTools.buildImage&lt;/i&gt; creates.&lt;br /&gt;&lt;br /&gt;(As a sidenote: there are still two Nix store paths that end-up in the image, namely &lt;i&gt;bash&lt;/i&gt; and &lt;i&gt;glibc&lt;/i&gt; that is a runtime dependency of &lt;i&gt;bash&lt;/i&gt;. This is caused by the fact that the internals of the &lt;i&gt;dockerTools.buildImage&lt;/i&gt; function make a reference to &lt;i&gt;bash&lt;/i&gt; without discarding its context. In theory, it is also possible to eliminate this dependency as well).&lt;br /&gt;&lt;br /&gt;To run the container and make sure that the required Nix store paths are available, I can mount the host system's Nix store as a shared volume:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run -p 8080:80 -v /nix/store:/nix/store -it nginxexp:latest&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;By mounting the host system's Nix store (with the &lt;i&gt;-v&lt;/i&gt; parameter), Nginx should still behave as expected -- it is not provided by the image, but referenced from the shared Nix store.&lt;br /&gt;&lt;br /&gt;(As a sidenote: mounting the host system's Nix store for sharing is not a new idea. It has already been intensively used by the &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/using-nixos-for-declarative-deployment.html&quot;&gt;NixOS test driver&lt;/a&gt; for many years to rapidly create QEMU virtual machines for system integration tests).&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Using the host system's network&lt;/h3&gt;&lt;br /&gt;As explained in the previous blog post, every Docker container by default runs in its own private network namespace making it possible for services to bind to any port without conflicting with the services on the host system or services provided by any other container.&lt;br /&gt;&lt;br /&gt;The Nix process management framework does not work with private networks, because it is not a generalizable concept (i.e. namespaces are a Linux-only feature). Aside from Docker, the only other process manager supported by the framework that can work with namespaces is systemd.&lt;br /&gt;&lt;br /&gt;To prevent ports and other dynamic resources from conflicting with each other, the process management framework makes it possible to configure them through instance function parameters. If the instance parameters have unique values, they will not conflict with other process instances (based on the assumption that the packager has identified all possible conflicts that a process might have).&lt;br /&gt;&lt;br /&gt;Because we already have a framework that prevents conflicts, we can also instruct Docker to use the host system's network with the &lt;i&gt;--network host&lt;/i&gt; parameter:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run -v /nix/store:/nix/store --network host -it nginxexp:latest&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The only thing the framework cannot provide you is protection -- mallicious services in a private network namespace cannot connect to ports used by other containers or the host system, but the framework cannot protect you from that.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Mapping a base directory for storing state&lt;/h3&gt;&lt;br /&gt;Services that run in containers are not always stateless -- they may rely on data that should be persistently stored, such as databases. &lt;a href=&quot;https://developers.redhat.com/blog/2016/02/24/10-things-to-avoid-in-docker-containers/&quot;&gt;The Docker recommendation to handle persistent state&lt;/a&gt; is not to store it in a container's writable layer, but on a shared volume on the host system.&lt;br /&gt;&lt;br /&gt;Data stored outside the container makes it possible to reliably upgrade a container -- when it is desired to install a newer version of an application, the container can be discarded and recreated from a new image.&lt;br /&gt;&lt;br /&gt;For the Nix process management framework, integration with a state directory outside the container is also useful. With an extra shared volume, we can mount the host system's state directory:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run -v /nix/store:/nix/store \&lt;br /&gt;  -v /var:/var --network host -it nginxexp:latest&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h3&gt;Orchestrating containers&lt;/h3&gt;&lt;br /&gt;The last piece in the puzzle is to orchestrate the containers: we must create or discard them, and start or stop them, and perform all required steps in the right order.&lt;br /&gt;&lt;br /&gt;Moreover, to prevent the Nix packages that a containers needs from being garbage collected, we need to make sure that they are a dependency of a package that is registered as in use.&lt;br /&gt;&lt;br /&gt;I came up with my own convention to implement the container deployment process. When building the processes model for the &lt;i&gt;docker&lt;/i&gt; process manager, the following files are generated that help me orchestrating the deployment process:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;01-webapp-docker-priority&lt;br /&gt;02-nginx-docker-priority&lt;br /&gt;nginx-docker-cmd&lt;br /&gt;nginx-docker-createparams&lt;br /&gt;nginx-docker-settings&lt;br /&gt;webapp-docker-cmd&lt;br /&gt;webapp-docker-createparams&lt;br /&gt;webapp-docker-settings&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above list, we have the following kinds of files:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The files that have a &lt;i&gt;-docker-settings&lt;/i&gt; suffix contain general properties of the container, such as the image that needs to be used a template.&lt;/li&gt;  &lt;li&gt;The files that have a &lt;i&gt;-docker-createparams&lt;/i&gt; suffix contain the command line parameters that are propagated to &lt;i&gt;docker create&lt;/i&gt; to create the container. If a container with the same name already exists, the container creation is skipped and the existing instance is used instead.&lt;/li&gt;  &lt;li&gt;To prevent the Nix packages that a Docker container needs from being garbage collected the generator creates a file with a &lt;i&gt;-docker-cmd&lt;/i&gt; suffix containing the &lt;i&gt;Cmd&lt;/i&gt; instruction including the full Nix store paths of the packages that a container needs.&lt;br /&gt;    &lt;br /&gt;    Because the strings' contexts are not discarded in the generation process, the packages become a dependency of the configuration file. As long as this configuration file is deployed, the packages will not get garbage collected.&lt;/li&gt;  &lt;li&gt;To ensure that the containers are activated in the right order we have two files that are prefixed with two numeric digits that have a &lt;i&gt;-container-priority&lt;/i&gt; suffix. The numeric digits determine in which order the containers should be activated -- in the above example the webapp process gets activated before Nginx (that acts as a reverse proxy).&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;With the following command, we can automatically generate the configuration files shown above for all our processes in the processes model, and use it to automatically create and start docker containers for all process instances:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;$ nixproc-docker-switch processes.nix&lt;br /&gt;55d833e07428: Loading layer [==================================================&amp;gt;]  46.61MB/46.61MB&lt;br /&gt;Loaded image: webapp:latest&lt;br /&gt;f020f5ecdc6595f029cf46db9cb6f05024892ce6d9b1bbdf9eac78f8a178efd7&lt;br /&gt;nixproc-webapp&lt;br /&gt;95b595c533d4: Loading layer [==================================================&amp;gt;]  46.61MB/46.61MB&lt;br /&gt;Loaded image: nginx:latest&lt;br /&gt;b195cd1fba24d4ec8542c3576b4e3a3889682600f0accc3ba2a195a44bf41846&lt;br /&gt;nixproc-nginx&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The result is two running Docker containers that correspond to the process instances shown in the processes model:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;$ docker ps&lt;br /&gt;CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES                                                   &lt;br /&gt;b195cd1fba24        nginx:latest        &quot;/nix/store/j3v4fz9h…&quot;   15 seconds ago      Up 14 seconds                           nixproc-nginx                                           &lt;br /&gt;f020f5ecdc65        webapp:latest       &quot;/nix/store/b6pz847g…&quot;   16 seconds ago      Up 15 seconds                           nixproc-webapp&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and we should be able to access the example HTML page, by opening the following URL: &lt;i&gt;http://localhost:8080&lt;/i&gt; in a web browser.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Deploying Docker containers in a heteregenous and/or distributed environment&lt;/h2&gt;&lt;br /&gt;As explained in my previous blog posts about the experimental Nix process management framework, the processes model is a sub set of a &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/disnix-toolset-for-distributed.html&quot;&gt;Disnix&lt;/a&gt; &lt;strong&gt;services&lt;/strong&gt; model. When it is desired to deploy processes to a network of machines or combine processes with other kinds of services, we can easily turn a processes model into a services model.&lt;br /&gt;&lt;br /&gt;For example, I can change the processes model shown earlier into a services model that deploys Docker containers:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{ pkgs ? import &amp;lt;nixpkgs&amp;gt; { inherit system; }&lt;br /&gt;, system ? builtins.currentSystem&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir;&lt;br /&gt;    inherit forceDisableUserChange;&lt;br /&gt;    processManager = &quot;docker&quot;;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp = rec {&lt;br /&gt;    name = &quot;webapp&quot;;&lt;br /&gt;&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    type = &quot;docker-container&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  nginxReverseProxy = rec {&lt;br /&gt;    name = &quot;nginxReverseProxy&quot;;&lt;br /&gt;&lt;br /&gt;    port = 8080;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.nginxReverseProxyHostBased {&lt;br /&gt;      webapps = [ webapp ];&lt;br /&gt;      inherit port;&lt;br /&gt;    } {};&lt;br /&gt;&lt;br /&gt;    type = &quot;docker-container&quot;;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above example, I have added a &lt;i&gt;name&lt;/i&gt; attribute to each process (a required property for Disnix service models) and a &lt;i&gt;type&lt;/i&gt; attribute referring to: &lt;i&gt;docker-container&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;In Disnix, a service could take any form. A plugin system (named &lt;a href=&quot;https://sandervanderburg.blogspot.com/2015/07/deploying-state-with-disnix.html&quot;&gt;Dysnomia&lt;/a&gt;) is responsible for managing the life-cycle of a service, such as activating or deactivating it. The &lt;i&gt;type&lt;/i&gt; attribute is used to tell Disnix that we should use the &lt;i&gt;docker-container&lt;/i&gt; Dysnomia module. This module will automatically create and start the container on activation, and stop and discard the container on deactivation.&lt;br /&gt;&lt;br /&gt;To deploy the above services to a network of machines, we require an &lt;strong&gt;infrastructure model&lt;/strong&gt; (that captures the available machines and their relevant deployment properties):&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{&lt;br /&gt;  test1.properties.hostname = &quot;test1&quot;;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above infrastructure model contains only one target machine: &lt;i&gt;test1&lt;/i&gt; with a hostname that is identical to the machine name.&lt;br /&gt;&lt;br /&gt;We also require a &lt;strong&gt;distribution model&lt;/strong&gt; that maps services in the services model to machines in the infrastructure model:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{infrastructure}:&lt;br /&gt;&lt;br /&gt;{&lt;br /&gt;  webapp = [ infrastructure.test1 ];&lt;br /&gt;  nginxReverseProxy = [ infrastructure.test1 ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above distribution model, we map the all the processes in the services model to the &lt;i&gt;test1&lt;/i&gt; target machine in the infrastructure model.&lt;br /&gt;&lt;br /&gt;With the following command, we can deploy our Docker containers to the remote &lt;i&gt;test1&lt;/i&gt; target machine:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ disnix-env -s services.nix -i infrastructure.nix -d distribution.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;When the above command succeeds, the &lt;i&gt;test1&lt;/i&gt; target machine provides running &lt;i&gt;webapp&lt;/i&gt; and &lt;i&gt;nginxReverseProxy&lt;/i&gt; containers.&lt;br /&gt;&lt;br /&gt;(As a sidenote: to make Docker container deployments work with Disnix, the Docker service already needs to be predeployed to the target machines in the infrastructure model, or the Docker daemon needs to be deployed as a &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/04/deploying-container-and-application.html&quot;&gt;container provider&lt;/a&gt;).&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Deploying conventional Docker containers with Disnix&lt;/h2&gt;&lt;br /&gt;The nice thing about the &lt;i&gt;docker-container&lt;/i&gt; Dysnomia module is that it is generic enough to also work with conventional Docker containers (that work with images, not a shared Nix store).&lt;br /&gt;&lt;br /&gt;For example, we can deploy Nginx as a regular container built with the &lt;i&gt;dockerTools.buildImage&lt;/i&gt; function:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;font-size: 90%; overflow: auto;&quot;&gt;&lt;br /&gt;{dockerTools, stdenv, nginx}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  dockerImage = dockerTools.buildImage {&lt;br /&gt;    name = &quot;nginxexp&quot;;&lt;br /&gt;    tag = &quot;test&quot;;&lt;br /&gt;    contents = nginx;&lt;br /&gt;&lt;br /&gt;    runAsRoot = ''&lt;br /&gt;      ${dockerTools.shadowSetup}&lt;br /&gt;      groupadd -r nogroup&lt;br /&gt;      useradd -r nobody -g nogroup -d /dev/null&lt;br /&gt;      mkdir -p /var/log/nginx /var/cache/nginx /var/www&lt;br /&gt;      cp ${./index.html} /var/www/index.html&lt;br /&gt;    '';&lt;br /&gt;&lt;br /&gt;    config = {&lt;br /&gt;      Cmd = [ &quot;${nginx}/bin/nginx&quot; &quot;-g&quot; &quot;daemon off;&quot; &quot;-c&quot; ./nginx.conf ];&lt;br /&gt;      Expose = {&lt;br /&gt;        &quot;80/tcp&quot; = {};&lt;br /&gt;      };&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;stdenv.mkDerivation {&lt;br /&gt;  name = &quot;nginxexp&quot;;&lt;br /&gt;  buildCommand = ''&lt;br /&gt;    mkdir -p $out&lt;br /&gt;    cat &amp;gt; $out/nginxexp-docker-settings &amp;lt;&amp;lt;EOF&lt;br /&gt;    dockerImage=${dockerImage}&lt;br /&gt;    dockerImageTag=nginxexp:test&lt;br /&gt;    EOF&lt;br /&gt;&lt;br /&gt;    cat &amp;gt; $out/nginxexp-docker-createparams &amp;lt;&amp;lt;EOF&lt;br /&gt;    -p&lt;br /&gt;    8080:80&lt;br /&gt;    EOF&lt;br /&gt;  '';&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above example, instead of using the process manager-agnostic &lt;i&gt;createManagedProcess&lt;/i&gt;, I directly construct a Docker-based Nginx image (by using the &lt;i&gt;dockerImage&lt;/i&gt; attribute) and container configuration files (in the &lt;i&gt;buildCommand&lt;/i&gt; parameter) to make the container deployments work with the &lt;i&gt;docker-container&lt;/i&gt; Dysnomia module.&lt;br /&gt;&lt;br /&gt;It is also possible to deploy containers from images that are constructed with &lt;i&gt;Dockerfile&lt;/i&gt;s. After we have built an image in the traditional way, we can export it from Docker with the following command:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker save nginx-debian -o nginx-debian.tar.gz&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and then we can use the following Nix expression to deploy a container using our exported image:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{dockerTools, stdenv, nginx}:&lt;br /&gt;&lt;br /&gt;stdenv.mkDerivation {&lt;br /&gt;  name = &quot;nginxexp&quot;;&lt;br /&gt;  buildCommand = ''&lt;br /&gt;    mkdir -p $out&lt;br /&gt;    cat &amp;gt; $out/nginxexp-docker-settings &amp;lt;&amp;lt;EOF&lt;br /&gt;    dockerImage=${./nginx-debian.tar.gz}&lt;br /&gt;    dockerImageTag=nginxexp:test&lt;br /&gt;    EOF&lt;br /&gt;&lt;br /&gt;    cat &amp;gt; $out/nginxexp-docker-createparams &amp;lt;&amp;lt;EOF&lt;br /&gt;    -p&lt;br /&gt;    8080:80&lt;br /&gt;    EOF&lt;br /&gt;  '';&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above expression, the &lt;i&gt;dockerImage&lt;/i&gt; property refers to our exported image.&lt;br /&gt;&lt;br /&gt;Although Disnix is flexible enough to also orchestrate Docker containers (thanks to its generalized plugin architecture), I did not develop the &lt;i&gt;docker-container&lt;/i&gt; Dysnomia module to make Disnix compete with existing container orchestration solutions, such as &lt;a href=&quot;https://kubernetes.io/&quot;&gt;Kubernetes&lt;/a&gt; or &lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;Docker Swarm&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;Disnix is a heterogeneous deployment tool that can be used to integrate units that have all kinds of shapes and forms on all kinds of operating systems -- having a &lt;i&gt;docker-container&lt;/i&gt; module makes it possible to mix Docker containers with other service types that Disnix and Dysnomia support.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Discussion&lt;/h2&gt;&lt;br /&gt;In this blog post, I have demonstrated that we can integrate Docker as a process management backend option into the experimental Nix process management framework, by substituting some of its conflicting features.&lt;br /&gt;&lt;br /&gt;Moreover, because a Disnix service model is a superset of a processes model, we can also use Disnix as a simple Docker container orchestrator and integrate Docker containers with other kinds of services.&lt;br /&gt;&lt;br /&gt;Compared to Docker, the Nix process management framework supports a number of features that Docker does not:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Docker is heavily developed around Linux-specific concepts, such as namespaces and cgroups. As a result, it can only be used to deploy software built for Linux.&lt;br /&gt;    &lt;br /&gt;    The Nix process management framework should work on any operating system that is supported by the Nix package manager (e.g. Nix also has first class support for macOS, and can also be used on other UNIX-like operating systems such as FreeBSD). The same also applies to Disnix.&lt;/li&gt;  &lt;li&gt;The Nix process management framework can work with &lt;i&gt;sysvinit&lt;/i&gt;, &lt;i&gt;BSD rc&lt;/i&gt; and Disnix process scripts, that do not require any external service to manage a process' life-cycle. This is convenient for local unprivileged user deployments. To deploy Docker containers, you need to have the Docker daemon installed first.&lt;/li&gt;  &lt;li&gt;Docker has an experimental rootless deployment mode, but in the Nix process management framework facilitating unprivileged user deployments is a first class concept.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;On the other hand, the Nix process management framework does not take over all responsibilities of Docker:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Docker heavily relies on namespaces to prevent resource conflicts, such as overlapping TCP ports and global state directories. The Nix process management framework solves conflicts by avoiding them (i.e. configuring properties in such a way that they are unique). The conflict avoidance approach works as long as a service is well-specified. Unfortunately, preventing conflicts is not a hard guarantee that the tool can provide you.&lt;/li&gt;  &lt;li&gt;Docker also provides some degree of protection by using namespaces and cgroups. The Nix process management framework does not support this out of the box, because these concepts are not generalizable over all the process management backends it supports. (As a sidenote: it is still possible to use these concepts by defining process manager-specific overrides).&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;From a functionality perspective, &lt;a href=&quot;https://docs.docker.com/compose&quot;&gt;&lt;i&gt;docker-compose&lt;/i&gt;&lt;/a&gt; comes close to the features that the experimental Nix process management framework supports. &lt;i&gt;docker-compose&lt;/i&gt; allows you to declaratively define container instances and their dependencies, and automatically deploy them.&lt;br /&gt;&lt;br /&gt;However, as its name implies &lt;i&gt;docker-compose&lt;/i&gt; is specifically designed for deploying Docker containers whereas the Nix process management framework is more general -- it should work with all kinds of process managers, uses Nix as the primary means to provide dependencies, it uses the Nix expression language for configuration and it should work on a variety of operating systems.&lt;br /&gt;&lt;br /&gt;The fact that Docker (and containers in general) are multi-functional solutions is not an observation only made by me. For example, &lt;a href=&quot;https://iximiuz.com/en/posts/you-dont-need-an-image-to-run-a-container&quot;&gt;this blog post&lt;/a&gt; also demonstrates that containers can work without images.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Availability&lt;/h2&gt;&lt;br /&gt;The Docker backend has been integrated into the &lt;a href=&quot;https://github.com/svanderburg/nix-processmgmt&quot;&gt;latest development version&lt;/a&gt; of the Nix process management framework.&lt;br /&gt;&lt;br /&gt;To use the &lt;i&gt;docker-container&lt;/i&gt; Dysnomia module (so that Disnix can deploy Docker containers), you need to install the latest development version of Dysnomia.&lt;br /&gt;</description>
	<pubDate>Tue, 11 Aug 2020 19:18:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Matej Cotman: Neovim, WSL and Nix</title>
	<guid isPermaLink="true">https://blog.matejc.com/blogs/myblog/neovim-wsl-and-nix</guid>
	<link>https://blog.matejc.com/blogs/myblog/neovim-wsl-and-nix</link>
	<description>&lt;p&gt;How to use Neovim (Neovim-Qt) under WSL 1/2 with the power of Nix&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Well we all know that generally development on Linux is easier than on Windows, but sometimes you are forced to use Windows. But that does not mean that all those nice tools from Linux are not available to you, as we will see in this post.&lt;/p&gt;

&lt;p&gt;Windows has some thing called WSL which enables you to run Linux tools natively in the Windows subsystem.
Not all is without issues, you can not run graphical Linux applications because Windows does not run Xorg server, yeah you have Xorg ports that run there but that is in this case just one more unwanted layer, remember, building efficient solutions is what every engineer should strive to.&lt;/p&gt;

&lt;p&gt;What I did is to use Windows pre-built binaries of Neovim-Qt and run the Neovim installed with Nix inside WSL.&lt;/p&gt;

&lt;p&gt;Ok, you could say then, why not use VS Code with some Vim/Neovim plugin and use so called Remote-WSL plugin to access WSL… Well yes, but at least me I stumble upon few issues.
First was that CPU usage was through the roof when Remote-WSL extension was in use on WSL1 (I could not just run Windows Update on client’s managed computer) and the fix was to install specific version of libc with dpkg (which is absurd in the first place because this is a good way to ruin your whole environment).
Applying this fix did the trick for lowering the CPU usage. The second issue come right after, when I wanted to install some package with APT package manager, like I predicted, libc install did its damage, I could not install or un-install anything with APT. Nix comes again to the rescue.&lt;/p&gt;

&lt;p&gt;By the way the &lt;strong&gt;sleep&lt;/strong&gt; command forgot how to work under WSL and Ubuntu 20.04 &lt;a href=&quot;https://askubuntu.com/questions/1230252/sleep-doesnt-work-on-ubuntu-20-04-wsl&quot;&gt;Source&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;lets-see-the-solution&quot;&gt;Let’s see the solution&lt;/h2&gt;

&lt;h3 id=&quot;neovim-qt&quot;&gt;Neovim-Qt&lt;/h3&gt;

&lt;p&gt;Neovim-Qt has nicely built binaries on their GitHub page for Windows, so I just downloaded that zip and unpacked it into &lt;strong&gt;C:/Program Files/neovim-qt/&lt;/strong&gt;. But any location could do.&lt;/p&gt;

&lt;h3 id=&quot;wsl&quot;&gt;WSL&lt;/h3&gt;

&lt;p&gt;Open PowerShell as Administrator and run:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;dism.exe&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;/online&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;/enable-feature&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;/featurename:Microsoft-Windows-Subsystem-Linux&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;/all&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;/norestart&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you do not have up to date Windows for any kind of reason to install WLS2 then reboot now.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reboot Time&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You should have now enabled the WSL1 and you can proceed to install Ubuntu 20.04 (or any other Linux distro you like) from Microsoft store.
Do not forget to click Launch after installing it (it will ask you to create a user).&lt;/p&gt;

&lt;h3 id=&quot;nix&quot;&gt;Nix&lt;/h3&gt;

&lt;p&gt;To install Nix, you need to first open some terminal emulator and run &lt;strong&gt;wsl.exe&lt;/strong&gt;, but you can also just run it from Start menu.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;bash &amp;lt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt; https://nixos.org/nix/install&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To finish you can just close the terminal and open wsl.exe again.&lt;/p&gt;

&lt;p&gt;Thats it.&lt;/p&gt;

&lt;h3 id=&quot;the-nix-script&quot;&gt;The Nix script&lt;/h3&gt;

&lt;p&gt;Now here is the absolutely most awesome part that connects everything together.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;pkgs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;nixpkgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}:&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;pkgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;writeScript&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;run-neovim-qt.sh&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    #!&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pkgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;stdenv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    set -e&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    # get random free port&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    export NVIM_LISTEN=&quot;127.0.0.1:$(&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pkgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;python3Packages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;python&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/bin/python -c 'import socket; s=socket.socket(); s.bind((&quot;&quot;, 0)); print(s.getsockname()[1]); s.close()')&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    # use python's sleep, because coreutils' sleep does not function under Ubuntu 20.04 and WSL&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    #   after delay start nvim-qt - so that nvim starts before the GUI&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    { &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pkgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;python3Packages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;python&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/bin/python -c 'import time; time.sleep(1)'; &quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;''$&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;{NVIM_QT_PATH}&quot; --server &quot;$NVIM_LISTEN&quot;; } &amp;amp;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    # start nvim&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pkgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;neovim&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/bin/nvim --listen &quot;$NVIM_LISTEN&quot; --headless &quot;$@&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;''&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Save it to your drive or download with &lt;strong&gt;wget&lt;/strong&gt; under WSL:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;wget https://raw.githubusercontent.com/matejc/helper_scripts/master/nixes/neovim-qt.nix &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then build the command with:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build ./neovim-qt.nix&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The resulting script is &lt;strong&gt;./result&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;/h3&gt;

&lt;p&gt;First we need to tell the script where is the Neovim-qt located:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;NVIM_QT_PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/mnt/c/Program Files/neovim-qt/bin/nvim-qt.exe'&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can save this into &lt;strong&gt;.bashrc&lt;/strong&gt; or &lt;strong&gt;.profile&lt;/strong&gt; and restart the terminal so that you do not need to repeat the step every time you run wsl shell.&lt;/p&gt;

&lt;p&gt;The final step is:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./result my/awesome/code.py&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Too much work? You think? Well how much more time you would use using and configuring VS Code or Atom to work under similar environment?
And what about Nix? You can install it without the use of native package managers (in case the native one is b0rked) and once you do, you have the power to install your favorite development environment with single command.&lt;/p&gt;

&lt;p&gt;I like this solution, in my eyes its simple and efficient, what are your thoughts?&lt;/p&gt;

&lt;p&gt;Until next time… I wish you happy hacking!&lt;/p&gt;

&lt;h2 id=&quot;links&quot;&gt;Links&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/vscode-remote-release/issues/2921&quot;&gt;High cpu usage of node process in Remote-WSL extension #2921&lt;/a&gt;
&lt;a href=&quot;https://github.com/equalsraf/neovim-qt/releases&quot;&gt;Neovim-Qt Releases&lt;/a&gt;
&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/wsl/install-win10&quot;&gt;WSL on Windows 10&lt;/a&gt;
&lt;a href=&quot;https://nixos.org/nix/manual/#chap-quick-start&quot;&gt;Quick start with Nix&lt;/a&gt;&lt;/p&gt;</description>
	<pubDate>Fri, 07 Aug 2020 22:00:00 +0000</pubDate>
</item>
<item>
	<title>Tweag I/O: Nix Flakes, Part 3: Managing NixOS systems</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-07-31-nixos-flakes/</guid>
	<link>https://tweag.io/blog/2020-07-31-nixos-flakes/</link>
	<description>&lt;p&gt;This is the third in a series of blog posts about &lt;a href=&quot;https://github.com/NixOS/rfcs/pull/49&quot;&gt;&lt;em&gt;Nix
flakes&lt;/em&gt;&lt;/a&gt;. The &lt;a href=&quot;https://www.tweag.io/../2020-05-25-flakes&quot;&gt;first
part&lt;/a&gt; motivated why we developed flakes — to
improve Nix’s reproducibility, composability and usability — and gave
a short tutorial on how to use flakes. The &lt;a href=&quot;https://www.tweag.io/../2020-06-25-eval-cache&quot;&gt;second
part&lt;/a&gt; showed how flakes enable reliable
caching of Nix evaluation results. In this post, we show how flakes
can be used to manage NixOS systems in a reproducible and composable
way.&lt;/p&gt;
&lt;h2&gt;What problems are we trying to solve?&lt;/h2&gt;
&lt;h3&gt;Lack of reproducibility&lt;/h3&gt;
&lt;p&gt;One of the main selling points of NixOS is reproducibility: given a
specification of a system, if you run &lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt; to deploy it,
you should always get the same &lt;em&gt;actual&lt;/em&gt; system (modulo mutable state
such as the contents of databases). For instance, we should be able to
reproduce in a production environment the exact same configuration
that we’ve previously validated in a test environment.&lt;/p&gt;
&lt;p&gt;However, the default NixOS workflow doesn’t provide reproducible
system configurations out of the box. Consider a typical sequence of
commands to upgrade a NixOS system:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You edit &lt;code class=&quot;language-text&quot;&gt;/etc/nixos/configuration.nix&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;You run &lt;code class=&quot;language-text&quot;&gt;nix-channel --update&lt;/code&gt; to get the latest version of the
&lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; repository (which contains the NixOS sources).&lt;/li&gt;
&lt;li&gt;You run &lt;code class=&quot;language-text&quot;&gt;nixos-rebuild switch&lt;/code&gt;, which evaluates and builds a
function in the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; repository that takes
&lt;code class=&quot;language-text&quot;&gt;/etc/nixos/configuration.nix&lt;/code&gt; as an input.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this workflow, &lt;code class=&quot;language-text&quot;&gt;/etc/nixos/configuration.nix&lt;/code&gt; might not be under
configuration management (e.g. point to a Git repository), or if it
is, it might be a dirty working tree. Furthermore, &lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt;
doesn’t specify what Git revision of &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; to use; so if somebody
else deploys the same &lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt;, they might get a very
different result.&lt;/p&gt;
&lt;h3&gt;Lack of traceability&lt;/h3&gt;
&lt;p&gt;The ability to reproduce a configuration is not very useful if you
can’t tell what configuration you’re actually running. That is, from a
running system, you should be able to get back to its
specification. So there is a lack of &lt;em&gt;traceability&lt;/em&gt;: the ability to
trace derived artifacts back to their sources. This is an essential
property of good configuration management, since without it, we don’t
know &lt;em&gt;what&lt;/em&gt; we’re actually running in production, so reproducing or
fixing problems becomes much harder.&lt;/p&gt;
&lt;p&gt;NixOS currently doesn’t not have very good traceability. You can ask a
NixOS system what version of Nixpkgs it was built from:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nixos-version --json | jq -r .nixpkgsRevision
a84b797b28eb104db758b5cb2b61ba8face6744b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately, this doesn’t allow you to recover &lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt;
or any other external NixOS modules that were used by the
configuration.&lt;/p&gt;
&lt;h3&gt;Lack of composability&lt;/h3&gt;
&lt;p&gt;It’s easy to enable a package or system service in a NixOS
configuration if it is part of the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; repository: you just add
a line like &lt;code class=&quot;language-text&quot;&gt;environment.systemPackages = [ pkgs.hello ];&lt;/code&gt; or
&lt;code class=&quot;language-text&quot;&gt;services.postgresql.enable = true;&lt;/code&gt; to your &lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt;. But
what if we want to use a package or service that &lt;em&gt;isn’t&lt;/em&gt; part of
Nixpkgs? Then we’re forced to use mechanisms like &lt;code class=&quot;language-text&quot;&gt;$NIX_PATH&lt;/code&gt;,
&lt;code class=&quot;language-text&quot;&gt;builtins.fetchGit&lt;/code&gt;, imports using relative paths, and so on. These
are not standardized (since everybody uses different conventions) and
are inconvenient to use (for example, when using &lt;code class=&quot;language-text&quot;&gt;$NIX_PATH&lt;/code&gt;, it’s the
user’s responsibility to put external repositories in the right
directories).&lt;/p&gt;
&lt;p&gt;Put another way: NixOS is currently built around a &lt;em&gt;monorepo&lt;/em&gt; workflow
— the entire universe should be added to the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; repository,
because anything that isn’t, is much harder to use.&lt;/p&gt;
&lt;p&gt;It’s worth noting that any NixOS system configuration already violates
the monorepo assumption: your system’s &lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt; is not part
of the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; repository.&lt;/p&gt;
&lt;h2&gt;Using flakes for NixOS configurations&lt;/h2&gt;
&lt;p&gt;In the previous post, we saw that flakes are (typically) Git
repositories that have a file named &lt;code class=&quot;language-text&quot;&gt;flake.nix&lt;/code&gt;, providing a
standardized interface to Nix artifacts. We saw flakes that provide
packages and development environments; now we’ll use them to provide
&lt;em&gt;NixOS system configurations&lt;/em&gt;. This solves the problems described
above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Reproducibility&lt;/em&gt;: the entire system configuration (including
everything it depends on) is captured by the flake and its lock
file. So if two people check out the same Git revision of a flake
and build it, they should get the same result.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Traceability&lt;/em&gt;: &lt;code class=&quot;language-text&quot;&gt;nixos-version&lt;/code&gt; prints the Git revision of the
top-level configuration flake, not its &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; input.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Composability&lt;/em&gt;: it’s easy to pull in packages and modules from other
repositories as flake inputs.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;Flake support has been added as an experimental feature to NixOS
20.03. However, flake support is not part of the current stable
release of Nix (2.3). So to get a NixOS system that supports flakes,
you first need to switch to the &lt;code class=&quot;language-text&quot;&gt;nixUnstable&lt;/code&gt; package and enable some
experimental features. This can be done by adding the following to
&lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;package &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nixUnstable&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;extraOptions &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;''
  experimental-features = nix-command flakes
''&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Creating a NixOS configuration flake&lt;/h2&gt;
&lt;p&gt;Let’s create a flake that contains the configuration for a NixOS
container.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ git init my-flake
$ cd my-flake
$ nix flake init -t templates#simpleContainer
$ git commit -a -m 'Initial version'&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the &lt;code class=&quot;language-text&quot;&gt;-t&lt;/code&gt; flag to &lt;code class=&quot;language-text&quot;&gt;nix flake init&lt;/code&gt; specifies a &lt;em&gt;template&lt;/em&gt;
from which to copy the initial contents of the flake. This is useful
for getting started. To see what templates are available, you can run:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nix flake show templates&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For reference, this is what the initial &lt;code class=&quot;language-text&quot;&gt;flake.nix&lt;/code&gt; looks like:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  inputs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;url &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;github:NixOS/nixpkgs/nixos-20.03&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  outputs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nixpkgs &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

    nixosConfigurations&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;container &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lib&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nixosSystem &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      system &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;x86_64-linux&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      modules &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; pkgs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            boot&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;isContainer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;token comment&quot;&gt;# Let 'nixos-version --json' know about the Git revision&lt;/span&gt;
            &lt;span class=&quot;token comment&quot;&gt;# of this flake.&lt;/span&gt;
            system&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;configurationRevision &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lib&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mkIf &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; rev&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;rev&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;token comment&quot;&gt;# Network configuration.&lt;/span&gt;
            networking&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;useDHCP &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            networking&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firewall&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;allowedTCPPorts &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;80&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;token comment&quot;&gt;# Enable a web server.&lt;/span&gt;
            services&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;httpd &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
              enable &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
              adminAddr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;morty@example.org&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That is, the flake has one input, namely &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; - specifically the
20.03 branch. It has one output, &lt;code class=&quot;language-text&quot;&gt;nixosConfigurations.container&lt;/code&gt;, which
evaluates a NixOS configuration for tools like
&lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;nixos-container&lt;/code&gt;. The main argument is &lt;code class=&quot;language-text&quot;&gt;modules&lt;/code&gt;,
which is a list of NixOS configuration modules. This takes the place
of the file &lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt; in non-flake deployments. (In fact,
you can write &lt;code class=&quot;language-text&quot;&gt;modules = [ ./configuration.nix ]&lt;/code&gt; if you’re converting
a pre-flake NixOS configuration.)&lt;/p&gt;
&lt;p&gt;Let’s create and start the container! (Note that &lt;code class=&quot;language-text&quot;&gt;nixos-container&lt;/code&gt;
currently requires you to be &lt;code class=&quot;language-text&quot;&gt;root&lt;/code&gt;.)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-container create flake-test --flake /path/to/my-flake
host IP is 10.233.4.1, container IP is 10.233.4.2

# nixos-container start flake-test&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To check whether the container works, let’s try to connect to it:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ curl http://flake-test/
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;It works!&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As an aside, if you just want to &lt;em&gt;build&lt;/em&gt; the container without the
&lt;code class=&quot;language-text&quot;&gt;nixos-container&lt;/code&gt; command, you can do so as follows:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nix build /path/to/my-flake#nixosConfigurations.container.config.system.build.toplevel&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code class=&quot;language-text&quot;&gt;system.build.toplevel&lt;/code&gt; is an internal NixOS option that
evaluates to the “system” derivation that commands like
&lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;nixos-install&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;nixos-container&lt;/code&gt; build and
activate. The symlink &lt;code class=&quot;language-text&quot;&gt;/run/current-system&lt;/code&gt; points to the output of
this derivation.&lt;/p&gt;
&lt;h2&gt;Hermetic evaluation&lt;/h2&gt;
&lt;p&gt;One big difference between “regular” NixOS systems and flake-based
NixOS systems is that the latter record the Git revisions from which
they were built. We can query this as follows:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-container run flake-test -- nixos-version --json
{&quot;configurationRevision&quot;:&quot;9190c396f4dcfc734e554768c53a81d1c231c6a7&quot;
,&quot;nixosVersion&quot;:&quot;20.03.20200622.13c15f2&quot;
,&quot;nixpkgsRevision&quot;:&quot;13c15f26d44cf7f54197891a6f0c78ce8149b037&quot;}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, &lt;code class=&quot;language-text&quot;&gt;configurationRevision&lt;/code&gt; is the Git revision of the repository
&lt;code class=&quot;language-text&quot;&gt;/path/to/my-flake&lt;/code&gt;. Because evaluation is hermetic, and the lock file
locks all flake inputs such as &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt;, knowing the revision
&lt;code class=&quot;language-text&quot;&gt;9190c39…&lt;/code&gt; allows you to completely reconstruct this configuration at
a later point in time. For example, if you want to deploy this
particular configuration to a container, you can do:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-container update flake-test \
    --flake /path/to/my-flake?rev=9190c396f4dcfc734e554768c53a81d1c231c6a7&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Dirty configurations&lt;/h2&gt;
&lt;p&gt;It’s not required that you commit all changes to a configuration
before deploying it. For example, if you change the &lt;code class=&quot;language-text&quot;&gt;adminAddr&lt;/code&gt; line
in &lt;code class=&quot;language-text&quot;&gt;flake.nix&lt;/code&gt; to&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;adminAddr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;rick@example.org&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and redeploy the container, you will get:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-container update flake-test
warning: Git tree '/path/to/my-flake' is dirty
...
reloading container...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the container will no longer have a configuration Git revision:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-container run flake-test -- nixos-version --json | jq .configurationRevision
null&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While this may be convenient for testing, in production we really want
to ensure that systems are deployed from clean Git trees. One way is
to disallow dirty trees on the command line:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-container update flake-test --no-allow-dirty
error: --- Error -------------------- nix
Git tree '/path/to/my-flake' is dirty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another is to require a clean Git tree in &lt;code class=&quot;language-text&quot;&gt;flake.nix&lt;/code&gt;, for instance by
adding a check to the definition of &lt;code class=&quot;language-text&quot;&gt;system.configurationRevision&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;system&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;configurationRevision &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; self &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; rev
  &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;rev
  &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Refusing to build from a dirty Git tree!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Adding modules from third-party flakes&lt;/h2&gt;
&lt;p&gt;One of the main goals of flake-based NixOS is to make it easier to use
packages and modules that are not included in the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt;
repository. As an example, we’ll add
&lt;a href=&quot;https://github.com/NixOS/hydra/blob/master/flake.nix&quot;&gt;Hydra&lt;/a&gt; (a
continuous integration server) to our container.&lt;/p&gt;
&lt;p&gt;Here’s how we add it to our container. We specify it as an additional input:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;  inputs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hydra&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;url &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;github:NixOS/hydra&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and as a corresponding function argument to the &lt;code class=&quot;language-text&quot;&gt;outputs&lt;/code&gt; function:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;  outputs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; hydra &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, we enable the NixOS module provided by the &lt;code class=&quot;language-text&quot;&gt;hydra&lt;/code&gt; flake:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;      modules &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; hydra&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nixosModules&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hydraTest

          &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; pkgs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; our own configuration &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;

            &lt;span class=&quot;token comment&quot;&gt;# Hydra runs on port 3000 by default, so open it in the firewall.&lt;/span&gt;
            networking&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firewall&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;allowedTCPPorts &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we can discover the name of this module by using &lt;code class=&quot;language-text&quot;&gt;nix flake show&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nix flake show github:NixOS/hydra
github:NixOS/hydra/d0deebc4fc95dbeb0249f7b774b03d366596fbed
├───…
├───nixosModules
│   ├───hydra: NixOS module
│   ├───hydraProxy: NixOS module
│   └───hydraTest: NixOS module
└───overlay: Nixpkgs overlay&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After committing this change and running &lt;code class=&quot;language-text&quot;&gt;nixos-container update&lt;/code&gt;, we
can check whether &lt;code class=&quot;language-text&quot;&gt;hydra&lt;/code&gt; is working in the container by visiting
&lt;a href=&quot;http://flake-test:3000/&quot;&gt;http://flake-test:3000/&lt;/a&gt; in a web browser.&lt;/p&gt;
&lt;h2&gt;Working with lock files&lt;/h2&gt;
&lt;p&gt;There are a few command line flags accepted by &lt;code class=&quot;language-text&quot;&gt;nix&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt;
and &lt;code class=&quot;language-text&quot;&gt;nixos-container&lt;/code&gt; that make updating lock file more
convenient. A very common action is to update a flake input to the
latest version; for example,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nixos-container update flake-test --update-input nixpkgs --commit-lock-file&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;updates the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; input to the latest revision on the
&lt;code class=&quot;language-text&quot;&gt;nixos-20.03&lt;/code&gt; branch, and commits the new lock file with a commit
message that records the input change.&lt;/p&gt;
&lt;p&gt;A useful flag during development is &lt;code class=&quot;language-text&quot;&gt;--override-input&lt;/code&gt;, which allows
you to point a flake input to another location, completely overriding
the input location specified by &lt;code class=&quot;language-text&quot;&gt;flake.nix&lt;/code&gt;. For example, this is how
you can build the container against a local Git checkout of Hydra:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nixos-container update flake-test --override-input hydra /path/to/my/hydra&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Adding overlays from third-party flakes&lt;/h2&gt;
&lt;p&gt;Similarly, we can add Nixpkgs overlays from other flakes. (Nixpkgs
overlays add or override packages in the &lt;code class=&quot;language-text&quot;&gt;pkgs&lt;/code&gt; set.) For example,
here is how you add the overlay provided by &lt;a href=&quot;https://github.com/NixOS/nix/blob/flakes/flake.nix&quot;&gt;the &lt;code class=&quot;language-text&quot;&gt;nix&lt;/code&gt;
flake&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;  outputs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nix &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    nixosConfigurations&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;container &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lib&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nixosSystem &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
      modules &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
          &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; pkgs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;overlays &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;overlay &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
          &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Using &lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Above we saw how to manage NixOS containers using flakes. Managing
“real” NixOS systems works much the same, except using &lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt;
instead of &lt;code class=&quot;language-text&quot;&gt;nixos-container&lt;/code&gt;. For example,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-rebuild switch --flake /path/to/my-flake#my-machine&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;builds and activates the configuration specified by the flake output
&lt;code class=&quot;language-text&quot;&gt;nixosConfigurations.my-machine&lt;/code&gt;. If you omit the name of the
configuration (&lt;code class=&quot;language-text&quot;&gt;#my-machine&lt;/code&gt;), &lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt; defaults to using the
current host name.&lt;/p&gt;
&lt;h2&gt;Pinning Nixpkgs&lt;/h2&gt;
&lt;p&gt;It’s often convenient to &lt;em&gt;pin&lt;/em&gt; the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; flake to the exact
version of &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; used to build the system. This ensures that
commands like &lt;code class=&quot;language-text&quot;&gt;nix shell nixpkgs#&amp;lt;package&amp;gt;&lt;/code&gt; work more efficiently
since many or all of the dependencies of &lt;code class=&quot;language-text&quot;&gt;&amp;lt;package&amp;gt;&lt;/code&gt; will already be
present. Here is a bit of NixOS configuration that pins &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; in
the system-wide flake registry:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;registry&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;flake &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that this only affects commands that reference &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; without
further qualifiers; more specific flake references like
&lt;code class=&quot;language-text&quot;&gt;nixpkgs/nixos-20.03&lt;/code&gt; or
&lt;code class=&quot;language-text&quot;&gt;nixpkgs/348503b6345947082ff8be933dda7ebeddbb2762&lt;/code&gt; are unaffected.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In this blog post we saw how Nix flakes make NixOS configurations
hermetic and reproducible. In a future post, we’ll show how we can do
the same for cloud deployments using NixOps.&lt;/p&gt;
&lt;p&gt;Acknowledgment: The development of flakes was partially funded by
Target Corporation.&lt;/p&gt;
&lt;h2&gt;Nix Flakes Series&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.tweag.io/../2020-05-25-flakes&quot;&gt;Part 1: An introduction and tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.tweag.io/../2020-06-25-eval-cache&quot;&gt;Part 2: Evaluation caching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 3: Managing NixOS systems&lt;/li&gt;
&lt;/ul&gt;</description>
	<pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate>
</item>

</channel>
</rss>
