<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">

<channel>
	<title>NixOS Planet</title>
	<link>https://planet.nixos.org</link>
	<language>en</language>
	<description>NixOS Planet - https://planet.nixos.org</description>
	<atom:link rel="self" href="https://planet.nixos.org/rss20.xml" type="application/rss+xml"/>

<item>
	<title>Sander van der Burg: Assigning unique IDs to services in Disnix deployment models</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-1266939232103509859</guid>
	<link>http://sandervanderburg.blogspot.com/2020/09/assigning-unique-ids-to-services-in.html</link>
	<description>As described in some of my recent blog posts, one of the more advanced features of &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/disnix-toolset-for-distributed.html&quot;&gt;Disnix&lt;/a&gt; as well as &lt;a href=&quot;https://sandervanderburg.blogspot.com/2019/11/a-nix-based-functional-organization-for.html&quot;&gt;the experimental Nix process management&lt;/a&gt; framework is to deploy &lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/06/deploying-containers-with-disnix-as.html&quot;&gt;&lt;strong&gt;multiple instances&lt;/strong&gt;&lt;/a&gt; of the same service to the same machine.&lt;br /&gt;&lt;br /&gt;To make running multiple service instances on the same machine possible, these tools rely on &lt;strong&gt;conflict avoidance&lt;/strong&gt; rather than isolation (typically used for &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/07/on-using-nix-and-docker-as-deployment.html&quot;&gt;containers&lt;/a&gt;). To allow multiple services instances to co-exist on the same machine, they need to be configured in such a way that they do not allocate any conflicting resources.&lt;br /&gt;&lt;br /&gt;Although for small systems it is doable to configure multiple instances by hand, this process gets tedious and time consuming for larger and more technologically diverse systems.&lt;br /&gt;&lt;br /&gt;One particular kind of conflicting resource that could be configured automatically are &lt;strong&gt;numeric IDs&lt;/strong&gt;, such as TCP/UDP port numbers, user IDs (UIDs), and group IDs (GIDs).&lt;br /&gt;&lt;br /&gt;In this blog post, I will describe how multiple service instances are configured (in Disnix and the process management framework) and how we can automatically assign unique numeric IDs to them.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Configuring multiple service instances&lt;/h2&gt;&lt;br /&gt;To facilitate conflict avoidance in Disnix and the Nix process management framework, services are configured as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{createManagedProcess, tmpDir}:&lt;br /&gt;{port, instanceSuffix ? &quot;&quot;, instanceName ? &quot;webapp${instanceSuffix}&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  webapp = import ../../webapp;&lt;br /&gt;in&lt;br /&gt;createManagedProcess {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  description = &quot;Simple web application&quot;;&lt;br /&gt;  inherit instanceName;&lt;br /&gt;&lt;br /&gt;  # This expression can both run in foreground or daemon mode.&lt;br /&gt;  # The process manager can pick which mode it prefers.&lt;br /&gt;  process = &quot;${webapp}/bin/webapp&quot;;&lt;br /&gt;  daemonArgs = [ &quot;-D&quot; ];&lt;br /&gt;&lt;br /&gt;  environment = {&lt;br /&gt;    PORT = port;&lt;br /&gt;    PID_FILE = &quot;${tmpDir}/${instanceName}.pid&quot;;&lt;br /&gt;  };&lt;br /&gt;  user = instanceName;&lt;br /&gt;  credentials = {&lt;br /&gt;    groups = {&lt;br /&gt;      &quot;${instanceName}&quot; = {};&lt;br /&gt;    };&lt;br /&gt;    users = {&lt;br /&gt;      &quot;${instanceName}&quot; = {&lt;br /&gt;        group = instanceName;&lt;br /&gt;        description = &quot;Webapp&quot;;&lt;br /&gt;      };&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  overrides = {&lt;br /&gt;    sysvinit = {&lt;br /&gt;      runlevels = [ 3 4 5 ];&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The Nix expression shown above is a nested function that describes how to deploy a simple self-contained REST web application with an embedded HTTP server:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The &lt;strong&gt;outer function header&lt;/strong&gt; (first line) specifies all common build-time dependencies and configuration properties that the service needs:&lt;br /&gt;    &lt;br /&gt;    &lt;ul&gt;      &lt;li&gt;&lt;i&gt;createManagedProcess&lt;/i&gt; is a function that can be used to &lt;a href=&quot;https://sandervanderburg.blogspot.com/2019/11/a-nix-based-functional-organization-for.html&quot;&gt;define process manager agnostic configurations&lt;/a&gt; that can be translated to configuration files for a variety of process managers (e.g. &lt;i&gt;systemd&lt;/i&gt;, &lt;i&gt;launchd&lt;/i&gt;, &lt;i&gt;supervisord&lt;/i&gt; etc.).&lt;/li&gt;      &lt;li&gt;&lt;i&gt;tmpDir&lt;/i&gt; refers to the temp directory in which temp files are stored.&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;  &lt;li&gt;The &lt;strong&gt;inner function header&lt;/strong&gt; (second line) specifies all instance parameters -- these are the parameters that must be configured in such a way that conflicts with other process instances are avoided:&lt;br /&gt;    &lt;br /&gt;    &lt;ul&gt;      &lt;li&gt;The &lt;i&gt;instanceName&lt;/i&gt; parameter (that can be derived from the &lt;i&gt;instanceSuffix&lt;/i&gt;) is a value used by some of the process management backends (e.g. the ones that invoke the &lt;i&gt;daemon&lt;/i&gt; command) to derive a unique PID file for the process. When running multiple instances of the same process, each of them requires a unique PID file name.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;port&lt;/i&gt; parameter specifies to which TCP port the service binds to. Binding the service to a port that is already taken by another service, causes the deployment of this service to fail.&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;  &lt;li&gt;    In the function &lt;strong&gt;body&lt;/strong&gt;, we invoke the &lt;i&gt;createManagedProcess&lt;/i&gt; function to construct configuration files for all supported process manager backends to run the &lt;i&gt;webapp&lt;/i&gt; process:&lt;br /&gt;    &lt;br /&gt;    &lt;ul&gt;      &lt;li&gt;As explained earlier, the &lt;i&gt;instanceName&lt;/i&gt; is used to configure the &lt;i&gt;daemon&lt;/i&gt; executable in such a way that it allocates a unique PID file.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;process&lt;/i&gt; parameter specifies which executable we need to run, both as a foreground process or daemon.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;daemonArgs&lt;/i&gt; parameter specifies which command-line parameters need to be propagated to the executable when the process should &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/01/writing-well-behaving-daemon-in-c.html&quot;&gt;daemonize on its own&lt;/a&gt;.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;environment&lt;/i&gt; parameter specifies all environment variables. The &lt;i&gt;webapp&lt;/i&gt; service uses these variables for runtime property configuration.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;user&lt;/i&gt; parameter is used to specify that the process should run as an unprivileged user. The &lt;i&gt;credentials&lt;/i&gt; parameter is used to configure the creation of the user account and corresponding user group.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;overrides&lt;/i&gt; parameter is used to override the process manager-agnostic parameters with process manager-specific parameters. For the &lt;i&gt;sysvinit&lt;/i&gt; backend, we configure the runlevels in which the service should run.&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Although the convention shown above makes it possible to avoid conflicts (assuming that all potential conflicts have been identified and exposed as function parameters), these parameters are typically configured manually:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{ pkgs, system&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;sysvinit&quot;&lt;br /&gt;, ...&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  processType = import ../../nixproc/derive-dysnomia-process-type.nix {&lt;br /&gt;    inherit processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp1 = rec {&lt;br /&gt;    name = &quot;webapp1&quot;;&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;1&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  webapp2 = rec {&lt;br /&gt;    name = &quot;webapp2&quot;;&lt;br /&gt;    port = 5001;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;2&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression shows both a valid Disnix &lt;strong&gt;services&lt;/strong&gt; as well as a valid &lt;strong&gt;processes&lt;/strong&gt; model that composes two web application process instances that can run concurrently on the same machine by invoking the nested constructor function shown in the previous example:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Each &lt;i&gt;webapp&lt;/i&gt; instance has its own unique instance name, by specifying a unique numeric &lt;i&gt;instanceSuffix&lt;/i&gt; that gets appended to the service name.&lt;/li&gt;  &lt;li&gt;Every &lt;i&gt;webapp&lt;/i&gt; instance binds to a unique TCP port (5000 and 5001) that should not conflict with system services or other process instances.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Previous work: assigning port numbers&lt;/h2&gt;&lt;br /&gt;Although configuring two process instances is still manageable, the configuration process becomes more tedious and time consuming when the amount and the kind of processes (each having their own potential conflicts) grow.&lt;br /&gt;&lt;br /&gt;Five years ago, I already identified a resource that could be automatically assigned to services: &lt;strong&gt;port numbers&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;I have created &lt;a href=&quot;https://sandervanderburg.blogspot.com/2015/07/assigning-port-numbers-to-microservices.html&quot;&gt;a very simple port assigner tool&lt;/a&gt; that allows you to specify a global ports pool and a target-specific pool pool. The former is used to assign globally unique port numbers to all services in the network, whereas the latter assigns port numbers that are unique to the target machine where the service is deployed to (this is to cope with the scarcity of port numbers).&lt;br /&gt;&lt;br /&gt;Although the tool is quite useful for systems that do not consist of too many different kinds of components, I ran into a number limitations when I want to manage a more diverse set of services:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Port numbers are not the only numeric IDs that services may require. When deploying systems that consist of self-contained executables, you typically want to run them as unprivileged users for security reasons. User accounts on most UNIX-like systems require unique &lt;strong&gt;user IDs&lt;/strong&gt;, and the corresponding users' groups require unique &lt;strong&gt;group IDs&lt;/strong&gt;.&lt;/li&gt;  &lt;li&gt;We typically want to manage &lt;strong&gt;multiple&lt;/strong&gt; resource &lt;strong&gt;pools&lt;/strong&gt;, for a variety of reasons. For example, when we have a number of HTTP server instances and a number of database instances, then we may want to pick port numbers in the 8000-9000 range for the HTTP servers, whereas for the database servers we want to use a different pool, such as 5000-6000.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Assigning unique numeric IDs&lt;/h2&gt;&lt;br /&gt;To address these shortcomings, I have developed a replacement tool that acts as a generic numeric ID assigner.&lt;br /&gt;&lt;br /&gt;This new ID assigner tool works with ID &lt;strong&gt;resource configuration&lt;/strong&gt; files, such as:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;rec {&lt;br /&gt;  ports = {&lt;br /&gt;    min = 5000;&lt;br /&gt;    max = 6000;&lt;br /&gt;    scope = &quot;global&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  uids = {&lt;br /&gt;    min = 2000;&lt;br /&gt;    max = 3000;&lt;br /&gt;    scope = &quot;global&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  gids = uids;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above ID resource configuration file (&lt;i&gt;idresources.nix&lt;/i&gt;) defines three resource pools: &lt;i&gt;ports&lt;/i&gt; is a resource that represents port numbers to be assigned to the webapp processes, &lt;i&gt;uids&lt;/i&gt; refers to user IDs and &lt;i&gt;gids&lt;/i&gt; to group IDs. The group IDs' resource configuration is identical to the users' IDs configuration.&lt;br /&gt;&lt;br /&gt;Each resource attribute refers the following configuration properties:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The &lt;i&gt;min&lt;/i&gt; value specifies the &lt;strong&gt;minimum&lt;/strong&gt; ID to hand out, &lt;i&gt;max&lt;/i&gt; the &lt;strong&gt;maximum&lt;/strong&gt; ID.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;scope&lt;/i&gt; value specifies the &lt;strong&gt;scope&lt;/strong&gt; of the resource pool. &lt;i&gt;global&lt;/i&gt; (which is the default option) means that the IDs assigned from this resource pool to services are globally unique for the entire system.&lt;br /&gt;    &lt;br /&gt;    The &lt;i&gt;machine&lt;/i&gt; scope can be used to assign IDs that are unique for the machine where a service is distributed to. When the latter option is used, services that are distributed two separate machines may have the same ID.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;We can adjust the services/processes model in such a way that every service will use dynamically assigned IDs and that each service specifies for which resources it requires a unique ID:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{ pkgs, system&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;sysvinit&quot;&lt;br /&gt;, ...&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  ids = if builtins.pathExists ./ids.nix then (import ./ids.nix).ids else {};&lt;br /&gt;&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir forceDisableUserChange processManager ids;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  processType = import ../../nixproc/derive-dysnomia-process-type.nix {&lt;br /&gt;    inherit processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp1 = rec {&lt;br /&gt;    name = &quot;webapp1&quot;;&lt;br /&gt;    port = ids.ports.webapp1 or 0;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;1&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;ports&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  webapp2 = rec {&lt;br /&gt;    name = &quot;webapp2&quot;;&lt;br /&gt;    port = ids.ports.webapp2 or 0;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;2&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;ports&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above services/processes model, we have made the following changes:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;In the beginning of the expression, we &lt;strong&gt;import&lt;/strong&gt; the dynamically generated &lt;i&gt;ids.nix&lt;/i&gt; expression that provides ID assignments for each resource. If the &lt;i&gt;ids.nix&lt;/i&gt; file does not exists, we generate an empty attribute set. We implement this construction (in which the absence of &lt;i&gt;ids.nix&lt;/i&gt; can be tolerated) to allow the ID assigner to bootstrap the ID assignment process.&lt;/li&gt;  &lt;li&gt;Every hardcoded &lt;i&gt;port&lt;/i&gt; attribute of every service is replaced by a &lt;strong&gt;reference&lt;/strong&gt; to the &lt;i&gt;ids&lt;/i&gt; attribute set that is dynamically generated by the ID assigner tool. To allow the ID assigner to open the services model in the first run, we provide a fallback port value of 0.&lt;/li&gt;  &lt;li&gt;Every service specifies for which resources it &lt;strong&gt;requires&lt;/strong&gt; a unique ID through the &lt;i&gt;requiresUniqueIdsFor&lt;/i&gt; attribute. In the above example, both service instances require unique IDs to assign a port number, user ID to the user and group ID to the group.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The port assignments are propagated as function parameters to the constructor functions that configure the services (as shown earlier in this blog post).&lt;br /&gt;&lt;br /&gt;We could also implement a similar strategy with the UIDs and GIDs, but a more convenient mechanism is to compose the function that creates the credentials, so that it transparently uses our &lt;i&gt;uids&lt;/i&gt; and &lt;i&gt;gids&lt;/i&gt; assignments.&lt;br /&gt;&lt;br /&gt;As shown in the expression above, the &lt;i&gt;ids&lt;/i&gt; attribute set is also propagated to the constructors expression. The constructors expression indirectly composes the &lt;i&gt;createCredentials&lt;/i&gt; function as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{pkgs, ids ? {}, ...}:&lt;br /&gt;&lt;br /&gt;{&lt;br /&gt;  createCredentials = import ../../create-credentials {&lt;br /&gt;    inherit (pkgs) stdenv;&lt;br /&gt;    inherit ids;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  ...&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The &lt;i&gt;ids&lt;/i&gt; attribute set is propagated to the function that composes the &lt;i&gt;createCredentials&lt;/i&gt; function. As a result, it will automatically assign the UIDs and GIDs in the &lt;i&gt;ids.nix&lt;/i&gt; expression when the user configures a user or group with a name that exists in the &lt;i&gt;uids&lt;/i&gt; and &lt;i&gt;gids&lt;/i&gt; resource pools.&lt;br /&gt;&lt;br /&gt;To make these UIDs and GIDs assignments go smoothly, it is recommended to give a process instance the same process name, instance name, user and group names.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Using the ID assigner tool&lt;/h2&gt;&lt;br /&gt;By combining the ID resources specification with the three Disnix models: a &lt;strong&gt;services model&lt;/strong&gt; (that defines all distributable services, shown above), an &lt;strong&gt;infrastructure model&lt;/strong&gt; (that captures all available target machines) and their properties and a &lt;strong&gt;distribution model&lt;/strong&gt; (that maps services to target machines in the network), we can automatically generate an ids configuration that contains all ID assignments:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;$ dydisnix -s services.nix -i infrastructure.nix -d distribution.nix \&lt;br /&gt;  --id-resources idresources.nix --output-file ids.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above command will generate an ids configuration file (&lt;i&gt;ids.nix&lt;/i&gt;) that provides, for each resource in the ID resources model, a unique assignment to services that are distributed to a target machine in the network. (Services that are not distributed to any machine in the distribution model will be skipped, to not waste too many resources).&lt;br /&gt;&lt;br /&gt;The output file (&lt;i&gt;ids.nix&lt;/i&gt;) has the following structure:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{&lt;br /&gt;  &quot;ids&quot; = {&lt;br /&gt;    &quot;gids&quot; = {&lt;br /&gt;      &quot;webapp1&quot; = 2000;&lt;br /&gt;      &quot;webapp2&quot; = 2001;&lt;br /&gt;    };&lt;br /&gt;    &quot;uids&quot; = {&lt;br /&gt;      &quot;webapp1&quot; = 2000;&lt;br /&gt;      &quot;webapp2&quot; = 2001;&lt;br /&gt;    };&lt;br /&gt;    &quot;ports&quot; = {&lt;br /&gt;      &quot;webapp1&quot; = 5000;&lt;br /&gt;      &quot;webapp2&quot; = 5001;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;  &quot;lastAssignments&quot; = {&lt;br /&gt;    &quot;gids&quot; = 2001;&lt;br /&gt;    &quot;uids&quot; = 2001;&lt;br /&gt;    &quot;ports&quot; = 5001;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The &lt;i&gt;ids&lt;/i&gt; attribute contains for each resource (defined in the ID resources model) the unique ID assignments per service. As shown earlier, both service instances require unique IDs for &lt;i&gt;ports&lt;/i&gt;, &lt;i&gt;uids&lt;/i&gt; and &lt;i&gt;gids&lt;/i&gt;. The above attribute set stores the corresponding ID assignments.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;lastAssignments&lt;/i&gt; attribute memorizes the last ID assignment per resource. Once an ID is assigned, it will not be immediately reused. This is to allow roll backs and to prevent data to incorrectly get owned by the wrong user accounts. Once the maximum ID limit is reached, the ID assigner will start searching for a free assignment from the beginning of the resource pool.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;In addition to assigning IDs to services that are distributed to machines in the network, it is also possible to assign IDs to all services (regardless whether they have been deployed or not):&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;$ dydisnix -s services.nix \&lt;br /&gt;  --id-resources idresources.nix --output-file ids.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Since the above command does not know anything about the target machines, it only works with an ID resources configuration that defines global scope resources.&lt;br /&gt;&lt;br /&gt;When you intend to upgrade an existing deployment, you typically want to retain already assigned IDs, while obsolete ID assignment should be removed, and new IDs should be assigned to services that have none yet. This is to prevent unnecessary redeployments.&lt;br /&gt;&lt;br /&gt;When removing the first webapp service and adding a third instance:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{ pkgs, system&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager ? &quot;sysvinit&quot;&lt;br /&gt;, ...&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  ids = if builtins.pathExists ./ids.nix then (import ./ids.nix).ids else {};&lt;br /&gt;&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir forceDisableUserChange processManager ids;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  processType = import ../../nixproc/derive-dysnomia-process-type.nix {&lt;br /&gt;    inherit processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp2 = rec {&lt;br /&gt;    name = &quot;webapp2&quot;;&lt;br /&gt;    port = ids.ports.webapp2 or 0;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;2&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;ports&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;  &lt;br /&gt;  webapp3 = rec {&lt;br /&gt;    name = &quot;webapp3&quot;;&lt;br /&gt;    port = ids.ports.webapp3 or 0;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;      instanceSuffix = &quot;3&quot;;&lt;br /&gt;    };&lt;br /&gt;    type = processType;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;ports&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;And running the following command (that provides the current &lt;i&gt;ids.nix&lt;/i&gt; as a parameter):&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ dydisnix -s services.nix -i infrastructure.nix -d distribution.nix \&lt;br /&gt;  --id-resources idresources.nix --ids ids.nix --output-file ids.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;we will get the following ID assignment configuration:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{&lt;br /&gt;  &quot;ids&quot; = {&lt;br /&gt;    &quot;gids&quot; = {&lt;br /&gt;      &quot;webapp2&quot; = 2001;&lt;br /&gt;      &quot;webapp3&quot; = 2002;&lt;br /&gt;    };&lt;br /&gt;    &quot;uids&quot; = {&lt;br /&gt;      &quot;webapp2&quot; = 2001;&lt;br /&gt;      &quot;webapp3&quot; = 2002;&lt;br /&gt;    };&lt;br /&gt;    &quot;ports&quot; = {&lt;br /&gt;      &quot;webapp2&quot; = 5001;&lt;br /&gt;      &quot;webapp3&quot; = 5002;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;  &quot;lastAssignments&quot; = {&lt;br /&gt;    &quot;gids&quot; = 2002;&lt;br /&gt;    &quot;uids&quot; = 2002;&lt;br /&gt;    &quot;ports&quot; = 5002;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As may be observed, since the &lt;i&gt;webapp2&lt;/i&gt; process is in both the current and the previous configuration, its ID assignments will be retained. &lt;i&gt;webapp1&lt;/i&gt; gets removed because it is no longer in the services model. &lt;i&gt;webapp3&lt;/i&gt; gets the next numeric IDs from the resources pools.&lt;br /&gt;&lt;br /&gt;Because the configuration of &lt;i&gt;webapp2&lt;/i&gt; stays the same, it does not need to be redeployed.&lt;br /&gt;&lt;br /&gt;The models shown earlier are valid Disnix services models. As a consequence, they can be used with Dynamic Disnix's ID assigner tool: &lt;i&gt;dydisnix-id-assign&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;Although these Disnix services models are also valid processes models (used by the Nix process management framework) not every processes model is guaranteed to be compatible with a Disnix service model.&lt;br /&gt;&lt;br /&gt;For process models that are not compatible, it is possible to use the &lt;i&gt;nixproc-id-assign&lt;/i&gt; tool that acts as a wrapper around &lt;i&gt;dydisnix-id-assign&lt;/i&gt; tool:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nixproc-id-assign --id-resources idresources.nix processes.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Internally, the &lt;i&gt;nixproc-id-assign&lt;/i&gt; tool converts a processes model to a Disnix service model (augmenting the process instance objects with missing properties) and propagates it to the &lt;i&gt;dydisnix-id-assign&lt;/i&gt; tool.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;A more advanced example&lt;/h2&gt;&lt;br /&gt;The &lt;i&gt;webapp&lt;/i&gt; processes example is fairly trivial and only needs unique IDs for three kinds of resources: port numbers, UIDs, and GIDs.&lt;br /&gt;&lt;br /&gt;I have also developed a more complex example for the Nix process management framework that exposes several commonly used system services on Linux systems, such as:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;{ pkgs ? import &amp;lt;nixpkgs&amp;gt; { inherit system; }&lt;br /&gt;, system ? builtins.currentSystem&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  ids = if builtins.pathExists ./ids.nix then (import ./ids.nix).ids else {};&lt;br /&gt;&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir cacheDir forceDisableUserChange processManager ids;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  apache = rec {&lt;br /&gt;    port = ids.httpPorts.apache or 0;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.simpleWebappApache {&lt;br /&gt;      inherit port;&lt;br /&gt;      serverAdmin = &quot;root@localhost&quot;;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;httpPorts&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  postgresql = rec {&lt;br /&gt;    port = ids.postgresqlPorts.postgresql or 0;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.postgresql {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;postgresqlPorts&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  influxdb = rec {&lt;br /&gt;    httpPort = ids.influxdbPorts.influxdb or 0;&lt;br /&gt;    rpcPort = httpPort + 2;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.simpleInfluxdb {&lt;br /&gt;      inherit httpPort rpcPort;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    requiresUniqueIdsFor = [ &quot;influxdbPorts&quot; &quot;uids&quot; &quot;gids&quot; ];&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above processes model exposes three service instances: an Apache HTTP server (that works with a simple configuration that serves web applications from a single virtual host), PostgreSQL and InfluxDB. Each service requires a unique user ID and group ID so that their privileges are separated.&lt;br /&gt;&lt;br /&gt;To make these services more accessible/usable, we do not use a shared ports resource pool. Instead, each service type consumes port numbers from their own resource pools.&lt;br /&gt;&lt;br /&gt;The following ID resources configuration can be used to provision the unique IDs to the services above:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;rec {&lt;br /&gt;  uids = {&lt;br /&gt;    min = 2000;&lt;br /&gt;    max = 3000;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  gids = uids;&lt;br /&gt;&lt;br /&gt;  httpPorts = {&lt;br /&gt;    min = 8080;&lt;br /&gt;    max = 8085;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  postgresqlPorts = {&lt;br /&gt;    min = 5432;&lt;br /&gt;    max = 5532;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  influxdbPorts = {&lt;br /&gt;    min = 8086;&lt;br /&gt;    max = 8096;&lt;br /&gt;    step = 3;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above ID resources configuration defines a shared UIDs and GIDs resource pool, but separate ports resource pools for each service type. This has the following implications if we deploy multiple instances of each service type:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;All Apache HTTP server instances get a TCP port assignment between 8080-8085.&lt;/li&gt;  &lt;li&gt;All PostgreSQL server instances get a TCP port assignment between 5432-5532.&lt;/li&gt;  &lt;li&gt;All InfluxDB server instances get a TCP port assignment between 8086-8096. Since an InfluxDB allocates two port numbers: one for the HTTP server and one for the RPC service (the latter's port number is the base port number + 2). We use a step count of 3 so that we can retain this convention for each InfluxDB instance.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;br /&gt;In this blog post, I have described a new tool: &lt;i&gt;dydisnix-id-assign&lt;/i&gt; that can be used to automatically assign unique numeric IDs to services in Disnix service models.&lt;br /&gt;&lt;br /&gt;Moreover, I have described: &lt;i&gt;nixproc-id-assign&lt;/i&gt; that acts a thin wrapper around this tool to automatically assign numeric IDs to services in the Nix process management framework's processes model.&lt;br /&gt;&lt;br /&gt;This tool replaces the old &lt;i&gt;dydisnix-port-assign&lt;/i&gt; tool in the &lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/08/an-extended-self-adaptive-deployment.html&quot;&gt;Dynamic Disnix toolset&lt;/a&gt; (described in the blog post written five years ago) that is much more limited in its capabilities.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Availability&lt;/h2&gt;&lt;br /&gt;The &lt;i&gt;dydisnix-id-assign&lt;/i&gt; tool is available in the current development version of &lt;a href=&quot;https://github.com/svanderburg/dydisnix&quot;&gt;Dynamic Disnix&lt;/a&gt;. The &lt;i&gt;nixproc-id-assign&lt;/i&gt; is part of the current implementation of the &lt;a href=&quot;https://github.com/svanderburg/nix-processmgmt&quot;&gt;Nix process management framework prototype&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;</description>
	<pubDate>Thu, 24 Sep 2020 18:24:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Tweag I/O: Implicit Dependencies in Build Systems</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-09-16-implicit-build-dependencies/</guid>
	<link>https://tweag.io/blog/2020-09-16-implicit-build-dependencies/</link>
	<description>&lt;p&gt;In making a build system for your software, you codified the dependencies
between its parts. But, did you account for &lt;em&gt;implicit&lt;/em&gt; software dependencies,
like system libraries and compiler toolchains?&lt;/p&gt;
&lt;p&gt;Implicit dependencies give rise to the biggest and most common problem with
software builds - the lack of &lt;em&gt;hermiticity&lt;/em&gt;. Without hermetic builds,
&lt;em&gt;reproducibility&lt;/em&gt; and &lt;em&gt;cacheability&lt;/em&gt; are lost.&lt;/p&gt;
&lt;p&gt;This post motivates the desire for reproducibility and cacheability, and
explains how we achieve hermetic, reproducible, highly cacheable builds by
taking control of implicit dependencies.&lt;/p&gt;
&lt;h3&gt;Reproducibility&lt;/h3&gt;
&lt;p&gt;Consider a developer newly approaching a code repository. After cloning the
repo, the developer must install a long list of “build requirements” and plod
through multiple steps of “setup”, only to find that, yes indeed, the build
fails. Yet, it worked just fine for their colleague! The developer, typically
not expert in build tooling, must debug the mysterious failure not of their
making. This is bad for morale and for productivity.&lt;/p&gt;
&lt;p&gt;This happens because the build is not &lt;em&gt;reproducible&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;One very common reason for the failure is that the compiler toolchain on the
developer’s system is different from that of the colleague. This happens even
with build systems that use sophisticated build software, like &lt;a href=&quot;https://www.tweag.io/blog/tags/bazel&quot;&gt;Bazel&lt;/a&gt;.
Bazel implicitly uses whatever system libraries and compilers are currently
installed in the developer’s environment.&lt;/p&gt;
&lt;p&gt;A common workaround is to provide developers with a Docker image equipped with
a certain compiler toolchain and system libraries, and then to mandate that the
Bazel build occurs in that context.&lt;/p&gt;
&lt;p&gt;That solution has a number of drawbacks. First, if the developer is using
macOS, the virtualized build context runs substantially slower. Second, the
Bazel build cache, developer secrets, and the source code remain outside of the
image and this adds complexity to the Docker invocation. Third, the Docker
image must be rebuilt and redistributed as dependencies change and that’s extra
maintenance. Fourth, and this is the biggest issue, Docker image builds are
themselves not reproducible - they nearly always rely on some external state
that does not remain constant across build invocations, and that means the
build can fail for reasons unrelated to the developer’s code.&lt;/p&gt;
&lt;p&gt;A better solution is to use &lt;a href=&quot;https://www.tweag.io/blog/tags/nix&quot;&gt;Nix&lt;/a&gt; to supply the compiler toolchain and
system library dependencies. Nix is a software package management system
somewhat like Debian’s APT or macOS’s Homebrew. Nix goes much farther to help
developers control their environments. It is unsurpassed when it comes to
reproducible builds of software packages.&lt;/p&gt;
&lt;p&gt;Nix facilitates use of the Nixpkgs package set. That set is &lt;a href=&quot;https://repology.org/repositories/statistics/nonunique&quot;&gt;the largest single
set of software packages&lt;/a&gt;. It is also the &lt;a href=&quot;https://repology.org/repositories/statistics/newest&quot;&gt;freshest&lt;/a&gt; package set. It
provides build instructions that work both on Linux and macOS. Developers can
easily pin any software package at an exact version.&lt;/p&gt;
&lt;p&gt;Learn more about &lt;a href=&quot;https://www.tweag.io/blog/2018-03-15-bazel-nix/&quot;&gt;using Nix with Bazel, here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Cacheability&lt;/h3&gt;
&lt;p&gt;Not only should builds be reproducible, but they should also be fast. Fast
builds are achieved by caching intermediate build results. Cache entries are
keyed based on the precise dependencies as well as the build instructions that
produce the entries. Builds will only benefit from a (shared, distributed)
cache when they have matching dependencies. Otherwise, cache keys (which depend
on the precise dependencies) will be different, and there will be cache misses.
This means that the developer will have to rebuild targets locally. These
unnecessary local rebuilds slow development.&lt;/p&gt;
&lt;p&gt;The solution is to &lt;a href=&quot;https://www.tweag.io/blog/2018-03-15-bazel-nix/&quot;&gt;make the implicit dependencies into explicit ones, again
using Nix&lt;/a&gt;, making sure to configure and use a shared Nix cache.&lt;/p&gt;
&lt;p&gt;Learn more about &lt;a href=&quot;https://www.tweag.io/blog/2020-04-09-bazel-remote-cache/&quot;&gt;configuring a shared Bazel cache, here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;It is important to eliminate implicit dependencies in your build system in
order to retain build reproducibility and cacheability. Identify Nix packages
that can replace the implicit dependencies of your Bazel build and use
&lt;a href=&quot;https://github.com/tweag/rules_nixpkgs&quot;&gt;rules_nixpkgs&lt;/a&gt; to declare them as explicit dependencies. That will yield a
fast, correct, hermetic build.&lt;/p&gt;</description>
	<pubDate>Wed, 16 Sep 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Tweag I/O: Towards a content-addressed model for Nix</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-09-10-nix-cas/</guid>
	<link>https://tweag.io/blog/2020-09-10-nix-cas/</link>
	<description>&lt;p&gt;This is my first post about content-addressability in Nix — a long-awaited feature that is hopefully coming soon!
In this post I will show you how this feature will improve the Nix
infrastructure. I’ll come back in another post to explain the technical challenges of
adding content-addressability to Nix.&lt;/p&gt;
&lt;p&gt;Nix has a wonderful model for handling packages.
Because each derivation is stored under (aka &lt;em&gt;addressed by&lt;/em&gt;) a unique
name, multiple versions of the same library can coexist on the same
system without issues: each version of the library has a distinct
name, as far as Nix is concerned.&lt;/p&gt;
&lt;p&gt;What’s more, if &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; is upgraded in &lt;a href=&quot;https://github.com/NixOS/nixpkgs/&quot;&gt;Nixpkgs&lt;/a&gt;, Nix knows that all the
packages that depend on &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; (i.e., almost everything) must be
rebuilt, if only so that they point at the name of the new &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt;
version. This way, a Nix installation will never feature a package
built for one version of &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt;, but dynamically linked against
another: as a user, it means that you will never have an &lt;em&gt;undefined
symbol&lt;/em&gt; error. Hurray!&lt;/p&gt;
&lt;h2&gt;The input-addressed store&lt;/h2&gt;
&lt;p&gt;How does Nix achieve this feat? The idea is that the name of a package
is derived from all of its inputs (that is, the complete list of
dependencies, as well as the package description). So if you change
the git tag from which &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; is fetched, the name changes, if the
name of &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; changes, then the name of any package which has &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; in
its dependencies changes.&lt;/p&gt;
&lt;p&gt;However this can be very pessimistic: even changes that aren’t
semantically meaningful can imply mass rebuilding and downloading. As
a slightly extreme example, &lt;a href=&quot;https://github.com/NixOS/nixpkgs/pull/83446&quot;&gt;this merge-request on
Nixpkgs&lt;/a&gt; makes a tiny change to the way &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; is built. It doesn’t actually
change &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt;, yet requires rebuilding an insane amount of
packages. Because, as far as Nix is concerned, all these packages have
different names, hence are different packages. In reality, though,
they weren’t.&lt;/p&gt;
&lt;p&gt;Nevertheless, the cost of the rebuild has to be born by the Nix
infrastructure: &lt;a href=&quot;https://hydra.nixos.org&quot;&gt;Hydra&lt;/a&gt; builds all packages to populate the cache,
and all the newly built packages must be stored. It costs both time,
and money (in cpu power, and storage space).&lt;/p&gt;
&lt;h2&gt;Unnecessary rebuilds?&lt;/h2&gt;
&lt;p&gt;Most distributions, by default, don’t rebuild packages when their dependencies change, and have a (more-or-less automated) process to detect changes that require rebuilding reverse dependencies.
For example, Debian &lt;a href=&quot;https://www.debian.org/doc/debian-policy/policy.pdf#81&quot;&gt;tries to detect ABI changes automatically&lt;/a&gt; and Fedora has a &lt;a href=&quot;https://docs.fedoraproject.org/en-US/fesco/Updates_Policy/&quot;&gt;more manual process&lt;/a&gt;.
But Nix doesn’t.&lt;/p&gt;
&lt;p&gt;The issue is that the notion of a “breaking change” is a very fuzzy one.
Should we follow Debian and consider that only ABI changes are breaking?
This criterion only applies for shared libraries, and as the Debian policy acknowledges, only for “well-behaved” programs.
So if we follow this criterion, there’s still need for manual curation, which is &lt;strong&gt;precisely&lt;/strong&gt; what Nix tries to avoid.&lt;/p&gt;
&lt;h2&gt;The content-addressed model&lt;/h2&gt;
&lt;p&gt;Quite happily, there is a criterion to avoid many useless rebuilds without sacrificing correctness: detecting when changes in a package (or one of its dependencies) yields the exact same output.
That might seem like an edge case, but the &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; example above (and many others) shows that there’s a practical application to it.
As another example, &lt;code class=&quot;language-text&quot;&gt;go&lt;/code&gt; depends on &lt;code class=&quot;language-text&quot;&gt;perl&lt;/code&gt; for its tests, so an upgrade of &lt;code class=&quot;language-text&quot;&gt;perl&lt;/code&gt; requires rebuilding all the Go packages in Nixpkgs, although it most likely doesn’t change the output of the &lt;code class=&quot;language-text&quot;&gt;go&lt;/code&gt; derivation.&lt;/p&gt;
&lt;p&gt;But, for Nix to recognise that a package is not a new package, the
new, unchanged, &lt;code class=&quot;language-text&quot;&gt;openssl&lt;/code&gt; or &lt;code class=&quot;language-text&quot;&gt;go&lt;/code&gt; packages must have &lt;em&gt;the same name&lt;/em&gt;
as the old version. Therefore, the name of a package must not be
derived from its inputs which have changed, but, instead, it should be
derived from the content of the compiled package. This is called
content addressing.&lt;/p&gt;
&lt;p&gt;Content addressing is how you can be sure that when you and a
colleague at the other side of the world type &lt;code class=&quot;language-text&quot;&gt;git checkout 7cc16bb8cd38ff5806e40b32978ae64d54023ce0&lt;/code&gt; you actually have the exact
same content in your tree. Git commits are content addressed, therefore the name
&lt;code class=&quot;language-text&quot;&gt;7cc16bb8cd38ff5806e40b32978ae64d54023ce0&lt;/code&gt; refers to that exact
tree.&lt;/p&gt;
&lt;p&gt;Yet another example of content-addressed storage is &lt;a href=&quot;https://ipfs.io/&quot;&gt;IPFS&lt;/a&gt;. In IPFS storage
files can be stored in any number of computers, and even moved from
computer to computer. The content-derived name is used as a way to give
an intrinsic name to a file, regardless of where it is stored.&lt;/p&gt;
&lt;p&gt;In fact, even the particular use case that we are discussing here -
avoiding recompilation when a rebuilt dependency hasn’t changed -
can be found in various build systems such as
&lt;a href=&quot;https://bazel.build/&quot;&gt;Bazel&lt;/a&gt;. In build systems, such recompilation
avoidance is sometimes known as the &lt;em&gt;early cutoff optimization&lt;/em&gt; −
see the &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf&quot;&gt;build systems a la carte paper&lt;/a&gt;
for example).&lt;/p&gt;
&lt;p&gt;So all we need to do is to move the Nix store from an input-addressed
model to a content-addressed model, as used by many tools
already, and we will be able to save a lot of storage space and CPU
usage, by rebuilding many fewer packages. Nixpkgs contributors will
see their CI time improved. It could also allow &lt;a href=&quot;https://github.com/NixOS/nix/issues/859&quot;&gt;serving a binary cache
over IPFS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Well, like many things with computers,
this is actually way harder than it sounds (which explains why this
hasn’t already been done despite being discussed nearly 15 years ago in the
&lt;a href=&quot;https://github.com/edolstra/edolstra.github.io/raw/49a78323f6b319da6e078b4f5f6b3112a30e8db9/pubs/phd-thesis.pdf&quot;&gt;original paper&lt;/a&gt;), but we now believe that there’s &lt;a href=&quot;https://github.com/NixOS/rfcs/pull/62&quot;&gt;a way forward&lt;/a&gt;… more on that in a later post.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;A content-addressed store for Nix would help reduce the insane load
that &lt;a href=&quot;https://hydra.nixos.org&quot;&gt;Hydra&lt;/a&gt; has to sustain. While content-addressing is a common technique both in distributed systems
and build systems (Nix is both!), getting to the point where it was
feasible to integrate content-addressing in Nix has been a long journey.&lt;/p&gt;
&lt;p&gt;In a future post, I’ll explain why it was so hard, and how we finally
managed to propose a viable design for a content-addressed Nix.&lt;/p&gt;</description>
	<pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>nixbuild.net: nixbuild.net is Generally Available</title>
	<guid isPermaLink="true">https://blog.nixbuild.net/posts/2020-08-28-nixbuild-net-is-generally-available.html</guid>
	<link>https://blog.nixbuild.net/posts/2020-08-28-nixbuild-net-is-generally-available.html</link>
	<description>&lt;p&gt;Today, &lt;a href=&quot;https://nixbuild.net&quot;&gt;nixbuild.net&lt;/a&gt; is exiting private beta and made generally available! Anyone can now &lt;a href=&quot;https://nixbuild.net#register&quot;&gt;sign up&lt;/a&gt; for a nixbuild.net account and immediately start building using the free CPU hours included with every account.&lt;/p&gt;
&lt;p&gt;After the free CPU hours have been consumed, the pricing is simple: 0.12 EUR (excl. VAT) per CPU hour consumed, billed monthly.&lt;/p&gt;

&lt;p&gt;As part of this GA announcement, a number of marketing and documentation improvements have been published:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A much improved and redesigned landing page at &lt;a href=&quot;https://nixbuild.net&quot;&gt;https://nixbuild.net&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An extensive &lt;a href=&quot;https://nixbuild.net#faq&quot;&gt;FAQ&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A reworked &lt;a href=&quot;https://docs.nixbuild.net/getting-started&quot;&gt;Getting Started&lt;/a&gt; guide&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Proper documentation of the &lt;a href=&quot;https://docs.nixbuild.net/nixbuild-shell&quot;&gt;nixbuild.net shell&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;We’re really happy for nixbuild.net to enter this new phase — making simple, performant and scalable remote builds available to every Nix user! We’re excited to see how the service is used, and we have lots of plans for the future of nixbuild.net.&lt;/strong&gt;&lt;/p&gt;</description>
	<pubDate>Fri, 28 Aug 2020 00:00:00 +0000</pubDate>
	<author>support@nixbuild.net (nixbuild.net)</author>
</item>
<item>
	<title>Tweag I/O: How Nix grew a marketing team</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-08-20-how-nix-grew-a-marketing-team/</guid>
	<link>https://tweag.io/blog/2020-08-20-how-nix-grew-a-marketing-team/</link>
	<description>&lt;p&gt;Recently I witnessed the moment when a potential Nix user reached eureka.
The moment where everything regarding Nix made sense.
My friend, now a Nix user, screamed from joy: &lt;strong&gt;“We need to Nix–ify everything!”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Moments like these reinforce my belief that Nix is a solution from — and for — the future.
A solution that could reach many more people, only if learning about Nix didn’t demand investing as much time and effort as it does now.&lt;/p&gt;
&lt;p&gt;I think that Nix has the perfect foundation for becoming a success but that it still needs better &lt;em&gt;marketing&lt;/em&gt;.
Many others agree with me, and that’s why we formed the &lt;a href=&quot;https://nixos.org/teams/marketing.html&quot;&gt;Nix marketing team&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would like to convince you that indeed, marketing is the way to go and that it is worth it.
Therefore, in this post I will share my thoughts on what kind of success we aim for, and which marketing efforts we are currently pursuing.
The marketing team is already giving its first results, and with your input, we can go further.&lt;/p&gt;
&lt;h2&gt;What does success look like?&lt;/h2&gt;
&lt;p&gt;At the time of writing this post, I have been using Nix for 10 years.
I organized one and attended most of the Nix conferences since then, and talked to many people in the community.
All of this does not give me the authority to say what success for Nix looks like, but it does give me a great insight into what we — the Nix community — can agree on.&lt;/p&gt;
&lt;p&gt;Success for Nix would be the next time you encounter a project on GitHub, it would already contain a &lt;code class=&quot;language-text&quot;&gt;default.nix&lt;/code&gt; for you to start developing.
Success for Nix would be the next time you try to run a server on the cloud, NixOS would be offered to you.
Or even more ambitious, would be other communities recognising Nix as a &lt;em&gt;de facto&lt;/em&gt; standard that improves the industry as a whole.&lt;/p&gt;
&lt;p&gt;To some, this success statement may seem very obvious.
However, it is important to say it out loud and often, so we can keep focus, and keep working on the parts of Nix that will contribute the most to this success.&lt;/p&gt;
&lt;h2&gt;The importance of marketing&lt;/h2&gt;
&lt;p&gt;Before we delve into what Nix still lacks, I would like to say that we — engineers and developers — should be aware of our bias against marketing.
This bias becomes clear when we think about what we think are the defining aspects for a project’s success.
We tend to believe that code is everything, and that good code leads to good results.
But what if I tell you that good marketing constitutes more than 50% of the success of a project?
Would you be upset?
We have to overcome this bias, since it prevents us from seeing the big picture.&lt;/p&gt;
&lt;p&gt;Putting aside those Sunday afternoons when I code for the pure joy of stretching my mind, most of the time I simply want to solve a problem.
The joy when seeing others realizing that their problem is not a problem anymore, is one of the best feelings I experienced as a developer.
This is what drives me.
Not the act of coding itself, but the act of solving the problem.
Coding is then only part of the solution.
Others need to know about the existence of your code, understand how it can solve their problem and furthermore they need to know how to use it.&lt;/p&gt;
&lt;p&gt;That is why marketing, and, more generally, non-technical work, is at least as important as technical work.
Documentation, writing blog posts, creating content for the website, release announcements, conference talks, conference booths, forums, chat channels, email lists, demo videos, use cases, swag, search engine optimisation, social media presence, engaging with the community…
These are all crucial parts of any successful project.&lt;/p&gt;
&lt;p&gt;Nix needs better marketing, from a better website to better documentation, along with all the ingredients mentioned above.
If we want Nix to grow as a project we need to improve our marketing game, since this is the area of work that is historically receiving the least amount of attention.
And we are starting to work on it.
In the middle of March 2020, a bunch of us got together and &lt;a href=&quot;https://discourse.nixos.org/t/marketing-team-can-we-present-nix-nixos-better/6249&quot;&gt;announced&lt;/a&gt; the creation of &lt;a href=&quot;https://nixos.org/teams/marketing.html&quot;&gt;the Nix marketing team&lt;/a&gt;.
Since then we meet roughly every two weeks to discuss and work on non-technical challenges that the Nix project is facing.&lt;/p&gt;
&lt;p&gt;But before the Nix marketing team could start doing any actual work we had to answer an important question:&lt;/p&gt;
&lt;h2&gt;What is Nix?&lt;/h2&gt;
&lt;p&gt;I want to argue that the Nix community is still missing an answer to an apparently very simple question: &lt;em&gt;What is Nix?&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The reason why &lt;em&gt;what is Nix?&lt;/em&gt; is a harder question than it may appear at first, is that any complete answer has to tell us &lt;em&gt;what&lt;/em&gt; and &lt;em&gt;who&lt;/em&gt; Nix is for.
Knowing the audience and primary use cases is a precondition to improving the website, documentation, or even Nix itself.&lt;/p&gt;
&lt;p&gt;This is what the Nix marketing team &lt;a href=&quot;https://www.youtube.com/watch?list=PLt4-_lkyRrOOO8CYo5XPx6UI05q8kwhj0&quot;&gt;discussed first&lt;/a&gt;. We identified the following audiences and primary use cases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Development environments (audience: developers)&lt;/li&gt;
&lt;li&gt;Deploying to the cloud (audience: system administrators)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It doesn’t mean other use cases are not important — they are.
We are just using the primary use cases as a gateway drug into the rest of the Nix’s ecosystem.
In this way, new users will not be overwhelmed with all the existing options and will have a clear idea where to start.&lt;/p&gt;
&lt;p&gt;Some reasons for selecting the two use cases are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Both use cases are relatively polished solutions.
Clearly, there is still much to be improved, but currently these are the two use cases with the best user experience in the Nix ecosystem.&lt;/li&gt;
&lt;li&gt;One use case is a natural continuation of another.
First, you develop and then you can use the same tools to package and deploy.&lt;/li&gt;
&lt;li&gt;Market size for both use cases is huge, which means there is a big potential.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A differentiating factor — why somebody would choose Nix over others — is Nix’s ability to provide reproducible results.
The promise of reproducibility is the aspect that already attracts the majority of Nix’s user base.
From this, we came up with a slogan for Nix:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Reproducible builds and deploys&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With the basic question answered we started working.&lt;/p&gt;
&lt;h2&gt;What has been done so far? How can I help?&lt;/h2&gt;
&lt;p&gt;So far, the Marketing team focused on improving the website:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Moved the website to Netlify.&lt;/strong&gt;
The important part is not switching to Netlify, but separating the website from the Nix infrastructure.
This removes the fear of a website update bringing down parts of Nix infrastructure.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Simplified navigation.&lt;/strong&gt;
If you remember, the navigation was different for each project that was listed on the website.
We removed the project differentiation and unified navigation.
This will show Nix ecosystem as a unified story and not a collection of projects.
One story is easier to follow than five.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Created a new learn page.&lt;/strong&gt;
Discoverability of documentation was a huge problem.
Links to popular topics in manuals are now more visible.
Some work on entry level tutorials has also started.
Good and beginner friendly learning resources are what is going to create the next generation of Nix users.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Created new team pages.&lt;/strong&gt;
We collected information about different official and less official teams working on Nix.
The work here is not done, but it shows that many teams don’t have clear responsibilities.
It shows how decisions are made and invites new Nix users to become more involved with the project.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Improved landing page.&lt;/strong&gt;
Instead of telling the user what Nix is, they will experience it from the start.
The landing page is filled with examples that will convince visitors to give Nix a try.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The work of the marketing team has just started, and there is still a lot to be done.
We are working hard on &lt;a href=&quot;https://github.com/NixOS/nixos-homepage/issues/449&quot;&gt;redesigning the website&lt;/a&gt; and &lt;a href=&quot;https://github.com/NixOS/nixos-homepage/issues/444&quot;&gt;improving the messaging&lt;/a&gt;.
The &lt;a href=&quot;https://github.com/NixOS/nixos-homepage/milestone/1&quot;&gt;roadmap&lt;/a&gt; will tell you more about what to expect next.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;If you wish to help&lt;/strong&gt; come and say hi to &lt;a href=&quot;irc://irc.freenode.net/#nixos-marketing&quot;&gt;#nixos-marketing on irc.freenode.org&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Marketing, and non-technical work, is all too often an afterthought for developers. I really wish it weren’t the case.
Having clearly defined problems, audience and strategy should be as important to us as having clean and tested code.
This is important for Nix. This is important for any project that aims to succeed.&lt;/p&gt;</description>
	<pubDate>Thu, 20 Aug 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>nixbuild.net: Build Reuse in nixbuild.net</title>
	<guid isPermaLink="true">https://blog.nixbuild.net/posts/2020-08-13-build-reuse-in-nixbuild-net.html</guid>
	<link>https://blog.nixbuild.net/posts/2020-08-13-build-reuse-in-nixbuild-net.html</link>
	<description>&lt;p&gt;Performance and cost-effectiveness are core values for nixbuild.net. How do you make a Nix build as performant and cheap as possible? The answer is — by not running it at all!&lt;/p&gt;
&lt;p&gt;This post goes into some detail about the different ways nixbuild.net is able to safely reuse build results. The post gets technical, but the main message is that nixbuild.net really tries to avoid building if it can, in order to save time and money for its users.&lt;/p&gt;

&lt;h2 id=&quot;binary-caches&quot;&gt;Binary Caches&lt;/h2&gt;
&lt;p&gt;The most obvious way of reusing build results is by utilising binary caches, and an &lt;a href=&quot;https://blog.nixbuild.net/posts/2020-04-18-binary-cache-support.html&quot;&gt;earlier blog post&lt;/a&gt; described how this is supported by nixbuild.net. In short, if something has been built on &lt;code&gt;cache.nixos.org&lt;/code&gt;, nixbuild.net can skip building it and just fetch it. It is also possible to configure other binary caches to use, and even treat the builds of specific nixbuild.net users in the same way as a trusted binary cache.&lt;/p&gt;
&lt;h2 id=&quot;no-shared-uploads&quot;&gt;No Shared Uploads&lt;/h2&gt;
&lt;p&gt;As part of the Nix remote build protocol, inputs (dependencies) can be uploaded directly to nixbuild.net. Those inputs are not necessarily trustworty, because we don’t know how they were produced. Therefore, those inputs are only allowed to be used by the user who uploaded them. The exception is if the uploaded input had a signature from a binary cache key, then we allow it to be used by all accounts that trust that specific key. Also, if explicit trust has been setup between two accounts, uploaded paths will be shared.&lt;/p&gt;
&lt;h2 id=&quot;derivation-sharing&quot;&gt;Derivation Sharing&lt;/h2&gt;
&lt;p&gt;Another method of reuse, unique to nixbuild.net, is the sharing of build results between users that don’t necessarily trust each other. It works like this:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;When we receive a build request, we get a &lt;a href=&quot;https://nixos.org/nixos/nix-pills/our-first-derivation.html&quot;&gt;derivation&lt;/a&gt; from the user’s Nix client. In essence, this derivation describes what inputs (dependencies) the build needs, and what commands must be run to produce the build output.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The inputs are described in the derivation simply as a list of store paths (&lt;code&gt;/nix/store/abc&lt;/code&gt;, &lt;code&gt;/nix/store/xyz&lt;/code&gt;). The way the Nix remote build protocol works, those store paths have already been provided to us, either because we already had trusted variants of them in our storage, or because we’ve downloaded them from binary caches, or because the client uploaded them to us.&lt;/p&gt;
&lt;p&gt;In order for us to be able to run the build, we need to map the input store paths to the actual file contents of the inputs. This mapping can actually vary even though store paths are the same. This is because a Nix store path does not depend on the &lt;em&gt;contents&lt;/em&gt; of the path, but rather on the &lt;em&gt;dependencies&lt;/em&gt; of the path. So we can very well have multiple versions of the same store path in our storage, because multiple users might have uploaded differing builds of the same paths.&lt;/p&gt;
&lt;p&gt;Anyhow, we will end up with a mapping that depends entirely on what paths the user is allowed to use. So, two users may build the exact same derivation but get different store-path-to-content mappings.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;At this stage, we store a representation of both the derivation itself, and the mapping described in previous step. Together, these two pieces represent a unique derivation in nixbuild.net’s database.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now, we can build the derivation. The build runs inside an isolated, virtualized sandbox that has no network access and nothing other than its inputs inside its filesystem.&lt;/p&gt;
&lt;p&gt;The sandbox is of course vital for keeping your builds secure, but it has another application, too: If we already have built a specific derivation (with a specific set of input content), this build result can be reused for &lt;em&gt;any&lt;/em&gt; user that comes along and requests a build of the exact same derivation with the exact same set of input content.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We do not yet have any numbers on how big impact this type of build result sharing has in practice. The effectiveness will depend on how reproducible the builds are, and of course also on how many users that are likely to build the same derivations.&lt;/p&gt;
&lt;p&gt;For an organization with a large set of custom packages that want to share binary builds with contributors and users, it could turn out useful. The benefit for users is that they don’t actually have to blindly trust a binary cache but instead can be sure that they get binaries that correspond to the nix derivations they have evaluated.&lt;/p&gt;</description>
	<pubDate>Thu, 13 Aug 2020 00:00:00 +0000</pubDate>
	<author>support@nixbuild.net (nixbuild.net)</author>
</item>
<item>
	<title>Tweag I/O: Developing Python with Poetry &amp; Poetry2nix: Reproducible flexible Python environments</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-08-12-poetry2nix/</guid>
	<link>https://tweag.io/blog/2020-08-12-poetry2nix/</link>
	<description>&lt;p&gt;Most Python projects are in fact &lt;em&gt;polyglot&lt;/em&gt;.
Indeed, many popular libraries on &lt;a href=&quot;https://pypi.org&quot;&gt;PyPi&lt;/a&gt; are Python wrappers around C code.
This applies particularly to popular scientific computing packages, such as &lt;code class=&quot;language-text&quot;&gt;scipy&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;numpy&lt;/code&gt;.
Normally, this is the terrain where Nix shines, but its support for Python projects has often been labor-intensive, requiring lots of manual fiddling and fine-tuning.
One of the reasons for this is that most Python package management tools do not give enough static information about the project, not offering the determinism needed by Nix.&lt;/p&gt;
&lt;p&gt;Thanks to &lt;a href=&quot;https://python-poetry.org/&quot;&gt;Poetry&lt;/a&gt;, this is a problem of the past — its rich lock file offers more than enough information to get Nix running, with minimal manual intervention.
In this post, I will show how to use Poetry, together with &lt;a href=&quot;https://github.com/nix-community/poetry2nix&quot;&gt;Poetry2nix&lt;/a&gt;, to easily manage Python projects with Nix.
I will show how to package a simple Python application both using the existing support for Python in Nixpkgs, and then using Poetry2nix.
This will both show why Poetry2nix is more convenient, and serve as a short tutorial covering its features.&lt;/p&gt;
&lt;h2&gt;Our application&lt;/h2&gt;
&lt;p&gt;We are going to package a simple application, a &lt;a href=&quot;https://flask.palletsprojects.com&quot;&gt;Flask&lt;/a&gt; server with two endpoints: one returning a static string “Hello World” and another returning a resized image.
This application was chosen because:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It can fit into a single file for the purposes of this post.&lt;/li&gt;
&lt;li&gt;Image resizing using Pillow requires the use of native libraries, which is something of a strength of Nix.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The code for it is in the &lt;code class=&quot;language-text&quot;&gt;imgapp/__init__.py&lt;/code&gt; file:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; send_file
&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Flask
&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; io &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; BytesIO
&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; PIL &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Image
&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; requests


app &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Flask&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__name__&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;


IMAGE_URL &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;https://farm1.staticflickr.com/422/32287743652_9f69a6e9d9_b.jpg&quot;&lt;/span&gt;
IMAGE_SIZE &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;route&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;


&lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;route&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;'/image'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    r &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; requests&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;get&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;IMAGE_URL&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;not&lt;/span&gt; r&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;status_code &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;raise&lt;/span&gt; ValueError&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string-interpolation&quot;&gt;&lt;span class=&quot;token string&quot;&gt;f&quot;Response code was '&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;r&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;status_code&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;'&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    img_io &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; BytesIO&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    img &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Image&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;BytesIO&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;r&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;content&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    img&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;thumbnail&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;IMAGE_SIZE&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    img&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;save&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;img_io&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;'JPEG'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; quality&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;70&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    img_io&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;seek&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; send_file&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;img_io&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; mimetype&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;'image/jpeg'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;run&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; __name__ &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    main&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;The status quo for packaging Python with Nix&lt;/h2&gt;
&lt;p&gt;There are two standard techniques for integrating Python projects with Nix.&lt;/p&gt;
&lt;h3&gt;Nix only&lt;/h3&gt;
&lt;p&gt;The first technique uses only Nix for package management, and is described in the &lt;a href=&quot;https://nixos.org/nixpkgs/manual/#python&quot;&gt;Python section&lt;/a&gt; of the Nix manual.
While it works and may look very appealing on the surface, it uses Nix for all package management needs, which comes with some drawbacks:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We are essentially tied to whatever package version Nixpkgs provides for any given dependency.
This can be worked around with overrides, but those can cause version incompatibilities.
This happens often in complex Python projects, such as data science ones, which tend to be very sensitive to version changes.&lt;/li&gt;
&lt;li&gt;We are tied to using packages already in Nixpkgs.
While Nixpkgs has many Python packages already packaged up (around 3000 right now) there are many packages missing — PyPi, the Python Package Index has more than 200000 packages.
This can of course be worked around with overlays and manual packaging, but this quickly becomes a daunting task.&lt;/li&gt;
&lt;li&gt;In a team setting, every team member wanting to add packages needs to buy in to Nix and at least have some experience using and understanding Nix.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;All these factors lead us to a conclusion: we need to embrace Python tooling so we can efficiently work with the entire Python ecosystem.&lt;/p&gt;
&lt;h3&gt;Pip and Pypi2Nix&lt;/h3&gt;
&lt;p&gt;The second standard method tries to overcome the faults above by using a hybrid approach of Python tooling together with Nix code generation.
Instead of writing dependencies manually in Nix, they are extracted from the &lt;code class=&quot;language-text&quot;&gt;requirements.txt&lt;/code&gt; file that users of Pip and Virtualenv are very used to.
That is, from a &lt;code class=&quot;language-text&quot;&gt;requirements.txt&lt;/code&gt; file containing the necessary dependencies:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-txt&quot;&gt;&lt;code class=&quot;language-txt&quot;&gt;requests
pillow
flask&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we can use &lt;a href=&quot;https://github.com/nix-community/pypi2nix&quot;&gt;pypi2nix&lt;/a&gt; to package our application in a more automatic fashion than before:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;nix-shell -p pypi2nix --run &quot;pypi2nix -r requirements.txt&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, Pip is not a dependency manager and therefore the &lt;code class=&quot;language-text&quot;&gt;requirements.txt&lt;/code&gt; file is not explicit enough — it lacks both exact versions for libraries, and system dependencies.
Therefore, the command above will not produce a working Nix expression.
In order to make pypi2nix work correctly, one has to manually find all dependencies incurred by the use of Pillow:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;nix-shell -p pypi2nix --run &quot;pypi2nix -V 3.8 -E pkgconfig -E freetype -E libjpeg -E openjpeg -E zlib -E libtiff -E libwebp -E tcl -E lcms2 -E xorg.libxcb -r requirements.txt&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will generate a large Nix expression, that will indeed work as expected.
Further use of Pypi2nix is left to the reader, but we can already draw some conclusions about this approach:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Code generation results in huge Nix expressions that can be hard to debug and understand.
These expressions will typically be checked into a project repository, and can get out of sync with actual dependencies.&lt;/li&gt;
&lt;li&gt;It’s very high friction, especially around native dependencies.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Having many large Python projects, I wasn’t satisfied with the status quo around Python package management.
So I looked into what could be done to make the situation better, and which tools could be more appropriate for our use-case.
A potential candidate was &lt;a href=&quot;https://github.com/pypa/pipenv&quot;&gt;Pipenv&lt;/a&gt;, however its dependency
solver and lock file format were difficult to work with.
In particular, Pipenv’s detection of “local” vs “non-local” dependencies did not work properly inside the Nix shell and gave us the wrong dependency graph.
Eventually, I found &lt;a href=&quot;https://python-poetry.org/&quot;&gt;Poetry&lt;/a&gt; and it looked very promising.&lt;/p&gt;
&lt;h2&gt;Poetry and Poetry2nix&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&quot;https://python-poetry.org/docs/&quot;&gt;Poetry package manager&lt;/a&gt; is a relatively recent addition to the Python ecosystem but it is gaining popularity very quickly.
Poetry features a nice CLI with good UX and deterministic builds through lock files.&lt;/p&gt;
&lt;p&gt;Poetry uses &lt;code class=&quot;language-text&quot;&gt;pip&lt;/code&gt; under the hood and, for this reason, inherited some of its shortcomings and lock file design.
I managed to land a few patches in Poetry before the 1.0 release to improve the lock file format, and now it is fit for use in Nix builds.
The result was &lt;a href=&quot;https://github.com/nix-community/poetry2nix&quot;&gt;Poetry2nix&lt;/a&gt;, whose key design goals were:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dead simple API.&lt;/li&gt;
&lt;li&gt;Work with the entire Python ecosystem using regular Python tooling.&lt;/li&gt;
&lt;li&gt;Python developers should not have to be Nix experts, and vice versa.&lt;/li&gt;
&lt;li&gt;Being an expert should allow you to “drop down” into the lower levels of the build and customise it.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Poetry2nix is not a code generation tool — it is implemented in pure Nix.
This fixes many of problems outlined in previous paragraphs, since there is a single point of truth for dependencies and their versions.&lt;/p&gt;
&lt;p&gt;But what about our native dependencies from before?
How does Poetry2nix know about those?
Indeed, Poetry2nix comes with an extensive set of overrides built-in for a lot of common packages, including Pillow.
Users are encouraged to contribute overrides &lt;a href=&quot;https://github.com/nix-community/poetry2nix/blob/master/overrides.nix&quot;&gt;upstream&lt;/a&gt; for popular packages, so everyone can have a better user experience.&lt;/p&gt;
&lt;p&gt;Now, let’s see how Poetry2nix works in practice.&lt;/p&gt;
&lt;h3&gt;Developing with Poetry&lt;/h3&gt;
&lt;p&gt;Let’s start with only our application file above (&lt;code class=&quot;language-text&quot;&gt;imgapp/__init__.py&lt;/code&gt;) and a &lt;code class=&quot;language-text&quot;&gt;shell.nix&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; pkgs &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;nixpkgs&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;

pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mkShell &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

  buildInputs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;python3
    pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;poetry
  &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Poetry comes with some nice helpers to create a project, so we run:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;$ poetry init&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then we’ll add our dependencies:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;$ poetry add requests pillow flask&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We now have two files in the folder:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first one is &lt;code class=&quot;language-text&quot;&gt;pyproject.toml&lt;/code&gt; which not only specifies our dependencies but also replaces &lt;code class=&quot;language-text&quot;&gt;setup.py&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The second is &lt;code class=&quot;language-text&quot;&gt;poetry.lock&lt;/code&gt; which contains our entire pinned Python dependency graph.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For Nix to know which scripts to install in the &lt;code class=&quot;language-text&quot;&gt;bin/&lt;/code&gt; output directory, we also need to add a &lt;code class=&quot;language-text&quot;&gt;scripts&lt;/code&gt; section to &lt;code class=&quot;language-text&quot;&gt;pyproject.toml&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-toml&quot;&gt;&lt;code class=&quot;language-toml&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;tool.poetry&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;imgapp&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;description&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;authors&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;adisbladis &amp;lt;adisbladis@gmail.com&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;tool.poetry.dependencies&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;python&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;^3.7&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;requests&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;^2.23.0&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;pillow&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;^7.1.2&quot;&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;^1.1.2&quot;&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;tool.poetry.dev-dependencies&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;tool.poetry.scripts&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;imgapp&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;'imgapp:main'&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token table class-name&quot;&gt;build-system&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;requires&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;poetry&amp;gt;=0.12&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token key property&quot;&gt;build-backend&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;poetry.masonry.api&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Packaging with Poetry2nix&lt;/h3&gt;
&lt;p&gt;Since Poetry2nix is not a code generation tool but implemented entirely in Nix, this step is trivial.
Create a &lt;code class=&quot;language-text&quot;&gt;default.nix&lt;/code&gt; containing:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; pkgs &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;nixpkgs&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;poetry2nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mkPoetryApplication &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  projectDir &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token url&quot;&gt;./.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can now invoke &lt;code class=&quot;language-text&quot;&gt;nix-build&lt;/code&gt; to build our package defined in &lt;code class=&quot;language-text&quot;&gt;default.nix&lt;/code&gt;.
Poetry2nix will automatically infer package names, dependencies, meta attributes and more from the Poetry metadata.&lt;/p&gt;
&lt;h3&gt;Manipulating overrides&lt;/h3&gt;
&lt;p&gt;Many overrides for system dependencies are already upstream, but what if some are lacking?
These overrides can be manipulated and extended manually:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;poetry2nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mkPoetryApplication &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    projectDir &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token url&quot;&gt;./.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    overrides &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; poetry2nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;overrides&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;withDefaults &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; super&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      foo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;overridePythonAttrs&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oldAttrs&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;By embracing both modern Python package management tooling and the Nix language, we can achieve best-in-class user experience for Python developers and Nix developers alike.&lt;/p&gt;
&lt;p&gt;There are ongoing efforts to make Poetry2nix and other Nix Python tooling work better with data science packages like &lt;code class=&quot;language-text&quot;&gt;numpy&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;scipy&lt;/code&gt;.
I believe that Nix may soon rival Conda on Linux and MacOS for data science.&lt;/p&gt;
&lt;p&gt;Python + Nix has a bright future ahead of it!&lt;/p&gt;</description>
	<pubDate>Wed, 12 Aug 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Sander van der Burg: Experimenting with Nix and the service management properties of Docker</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-4809008011877447165</guid>
	<link>http://sandervanderburg.blogspot.com/2020/08/experimenting-with-nix-and-service.html</link>
	<description>In &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/07/on-using-nix-and-docker-as-deployment.html&quot;&gt;the previous blog post&lt;/a&gt;, I have analyzed &lt;a href=&quot;https://nixos.org/nix&quot;&gt;Nix&lt;/a&gt; and &lt;a href=&quot;https://www.docker.com&quot;&gt;Docker&lt;/a&gt; as deployment solutions and described in what ways these solutions are similar and different.&lt;br /&gt;&lt;br /&gt;To summarize my findings:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://sandervanderburg.blogspot.com/2012/11/an-alternative-explaination-of-nix.html&quot;&gt;Nix&lt;/a&gt; is a &lt;strong&gt;source-based package manager&lt;/strong&gt; responsible for obtaining, installing, configuring and upgrading packages in a reliable and reproducible manner and facilitating the construction of packages from source code and their dependencies.&lt;/li&gt;&lt;li&gt;Docker's purpose is to fully &lt;strong&gt;manage&lt;/strong&gt; the life-cycle of &lt;strong&gt;applications&lt;/strong&gt; (services and ordinary processes) in a reliable and reproducible manner, including their deployments.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;As explained in my previous blog post, two prominent goals both solutions have in common is to facilitate &lt;strong&gt;reliable&lt;/strong&gt; and &lt;strong&gt;reproducible&lt;/strong&gt; deployment. They both use different kinds of techniques to accomplish these goals.&lt;br /&gt;&lt;br /&gt;Although Nix and Docker can be used for a variety of comparable use cases (such as constructing images, deploying test environments, and constructing packages from source code), one prominent feature that the Nix package manager does not provide is &lt;strong&gt;process&lt;/strong&gt; (or service) &lt;strong&gt;management&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;In a Nix-based workflow you need to augment Nix with another solution that can facilitate process management.&lt;br /&gt;&lt;br /&gt;In this blog post, I will investigate how Docker could fulfill this role -- it is pretty much the opposite goal of the combined use cases scenarios I have shown in the previous blog post, in which Nix can overtake the role  of a conventional package manager in supplying packages in the construction process of an image and even the complete construction process of images.&lt;br /&gt;  &lt;br /&gt;&lt;h2&gt;Existing Nix integrations with process management&lt;/h2&gt;&lt;br /&gt;Although Nix does not do any process management, there are sister projects that can, such as:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/01/nixos-purely-functional-linux.html&quot;&gt;&lt;strong&gt;NixOS&lt;/strong&gt;&lt;/a&gt; builds entire machine configurations from a single declarative deployment specification and uses the Nix package manager to deploy and isolate all static artifacts of a system. It will also automatically generate and deploy &lt;a href=&quot;https://freedesktop.org/wiki/Software/systemd/&quot;&gt;systemd&lt;/a&gt; units for services defined in a NixOS configuration.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/LnL7/nix-darwin&quot;&gt;&lt;strong&gt;nix-darwin&lt;/strong&gt;&lt;/a&gt; can be used to specify a collection of services in a deployment specification and uses the Nix package manager to deploy all services and their corresponding &lt;a href=&quot;https://www.launchd.info/&quot;&gt;launchd&lt;/a&gt; configuration files.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Although both projects do a great job (e.g. they both provide a big collection of deployable services) what I consider a disadvantage is that they are &lt;strong&gt;platform specific&lt;/strong&gt; -- both solutions only work on a single operating system (Linux and macOS) and a single process management solution (systemd and launchd).&lt;br /&gt;&lt;br /&gt;If you are using Nix in a different environment, such as a different operating system, a conventional (non-NixOS) Linux distribution, or a different process manager, then there is no off-the-shelf solution that will help you managing services for packages provided by Nix.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Docker functionality&lt;/h2&gt;&lt;br /&gt;Docker could be considered a multi-functional solution for application management. I can categorize its functionality as follows:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Process management&lt;/strong&gt;. The life-cycle of a container is bound to the life-cycle of a root process that needs to be started or stopped.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Dependency management&lt;/strong&gt;. To ensure that applications have all the dependencies that they need and that no dependency is missing, Docker uses &lt;strong&gt;images&lt;/strong&gt; containing a complete root filesystem with all required files to run an application.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Resource isolation&lt;/strong&gt; is heavily used for a variety of different reasons:&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Foremost, to ensure that the root filesystem of the container does not conflict with the host system's root filesystem.&lt;/li&gt;&lt;li&gt;It is also used to prevent conflicts with other kinds of resources. For example, the isolated network interfaces allow services to bind to the same TCP ports that may also be in use by the host system or other containers.&lt;/li&gt;&lt;li&gt;It offers some degree of protection. For example, a malicious process will not be able to see or control a process belonging to the host system or a different container.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Resource restriction&lt;/strong&gt; can be used to limit the amount of system resources that a process can consume, such as the amount of RAM.&lt;br /&gt;&lt;br /&gt;Resource restriction can be useful for a variety of reasons, for example, to prevent a service from eating up all the system's resources affecting the stability of the system as a whole.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Integrations&lt;/strong&gt; with the host system (e.g. volumes) and other services.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;As described in the previous blog post, Docker uses a number key concepts to implement the functionality shown above, such as layers, &lt;a href=&quot;https://man7.org/linux/man-pages/man7/namespaces.7.html&quot;&gt;&lt;strong&gt;namespaces&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://man7.org/linux/man-pages/man7/cgroups.7.html&quot;&gt;&lt;strong&gt;cgroups&lt;/strong&gt;&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Developing a Nix-based process management solution&lt;/h2&gt;&lt;br /&gt;For quite some time, &lt;a href=&quot;https://sandervanderburg.blogspot.com/2019/11/a-nix-based-functional-organization-for.html&quot;&gt;I have been investigating the process management domain&lt;/a&gt; and worked on a &lt;a href=&quot;https://github.com/svanderburg/nix-processmgmt&quot;&gt;prototype solution&lt;/a&gt; to provide a more generalized infrastructure that complements Nix with process management -- I came up with an experimental Nix-based process manager-agnostic framework that has the following objectives:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;It uses Nix to &lt;strong&gt;deploy&lt;/strong&gt; all required &lt;strong&gt;packages&lt;/strong&gt; and other &lt;strong&gt;static artifacts&lt;/strong&gt; (such as configuration files) that a service needs.&lt;/li&gt;&lt;li&gt;It integrates with a &lt;strong&gt;variety&lt;/strong&gt; of process managers on a variety of operating systems. So far, it can work with: sysvinit scripts, BSD rc scripts, supervisord, systemd, cygrunsrv and launchd.&lt;br /&gt;  &lt;br /&gt;  In addition to process managers, it can also &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/05/deploying-heterogeneous-service.html&quot;&gt;automatically convert a processes model to deployment specifications that Disnix can consume&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;It uses &lt;strong&gt;declarative&lt;/strong&gt; specifications to define functions that construct managed processes and process instances.&lt;br /&gt;  &lt;br /&gt;  Processes can be declared in a process-manager specific and &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/02/a-declarative-process-manager-agnostic.html&quot;&gt;process-manager agnostic&lt;/a&gt; way. The latter makes it possible to target all six supported process managers with the same declarative specification, albeit with a limited set of features.&lt;/li&gt;&lt;li&gt;It allows you to run &lt;strong&gt;multiple instances&lt;/strong&gt; of processes, by introducing a convention to cope with potential resource conflicts between process instances -- instance properties and potential conflicts can be configured with function parameters and can be changed in such a way that they do not conflict.&lt;/li&gt;&lt;li&gt;It can facilitate &lt;strong&gt;unprivileged&lt;/strong&gt; user deployments by using Nix's ability to perform unprivileged package deployments and introducing a convention that allows you to disable user switching.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;To summarize how the solution works from a user point of view, we can write a process manager-agnostic constructor function as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{createManagedProcess, tmpDir}:&lt;br /&gt;{port, instanceSuffix ? &quot;&quot;, instanceName ? &quot;webapp${instanceSuffix}&quot;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  webapp = import ../../webapp;&lt;br /&gt;in&lt;br /&gt;createManagedProcess {&lt;br /&gt;  name = instanceName;&lt;br /&gt;  description = &quot;Simple web application&quot;;&lt;br /&gt;  inherit instanceName;&lt;br /&gt;&lt;br /&gt;  process = &quot;${webapp}/bin/webapp&quot;;&lt;br /&gt;  daemonArgs = [ &quot;-D&quot; ];&lt;br /&gt;&lt;br /&gt;  environment = {&lt;br /&gt;    PORT = port;&lt;br /&gt;    PID_FILE = &quot;${tmpDir}/${instanceName}.pid&quot;;&lt;br /&gt;  };&lt;br /&gt;  user = instanceName;&lt;br /&gt;  credentials = {&lt;br /&gt;    groups = {&lt;br /&gt;      &quot;${instanceName}&quot; = {};&lt;br /&gt;    };&lt;br /&gt;    users = {&lt;br /&gt;      &quot;${instanceName}&quot; = {&lt;br /&gt;        group = instanceName;&lt;br /&gt;        description = &quot;Webapp&quot;;&lt;br /&gt;      };&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  overrides = {&lt;br /&gt;    sysvinit = {&lt;br /&gt;      runlevels = [ 3 4 5 ];&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The Nix expression above is a nested function that defines in a process manager-agnostic way a configuration for a web application process containing an embedded web server serving a static HTML page.&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The &lt;strong&gt;outer function header&lt;/strong&gt; (first line) refers to parameters that are &lt;strong&gt;common&lt;/strong&gt; to all process instances: &lt;i&gt;createManagedProcess&lt;/i&gt; is a function that can construct process manager configurations and &lt;i&gt;tmpDir&lt;/i&gt; refers to the directory in which temp files are stored (which is &lt;i&gt;/tmp&lt;/i&gt; in conventional Linux installations).&lt;/li&gt;  &lt;li&gt;The &lt;strong&gt;inner function header&lt;/strong&gt; (second line) refers to &lt;strong&gt;instance parameters&lt;/strong&gt; -- when it is desired to construct multiple instances of this process, we must make sure that we have configured these parameters in such as a way that they do not conflict with other processes.&lt;br /&gt;    &lt;br /&gt;    For example, when we assign a unique TCP port and a unique instance name (a property used by the &lt;a href=&quot;http://www.libslack.org/daemon/&quot;&gt;&lt;i&gt;daemon&lt;/i&gt;&lt;/a&gt; tool to create unique PID files) we can safely have multiple instances of this service co-existing on the same system.&lt;/li&gt;  &lt;li&gt;In the body, we invoke the &lt;i&gt;createManagedProcess&lt;/i&gt; function to generate configurations files for a process manager.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;process&lt;/i&gt; parameter specifies the executable that we need to run to start the process.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;daemonArgs&lt;/i&gt; parameter specifies command-line instructions passed to the the process executable, when the process should daemonize itself (the &lt;i&gt;-D&lt;/i&gt; parameter instructs the webapp process to daemonize).&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;environment&lt;/i&gt; parameter specifies all environment variables. Environment variables are used as a generic configuration facility for the service.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;user&lt;/i&gt; parameter specifies the name the process should run as (each process instance has its own user and group with the same name as the instance).&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;credentials&lt;/i&gt; parameter is used to automatically create the group and user that the process needs.&lt;/li&gt;  &lt;li&gt;The &lt;i&gt;overrides&lt;/i&gt; parameter makes it possible to override the parameters generated by the &lt;i&gt;createManagedProcess&lt;/i&gt; function with process manager-specific overrides, to configure features that are not universally supported.&lt;br /&gt;&lt;br /&gt;In the example above, we use an override to configure the &lt;a href=&quot;https://wiki.debian.org/RunLevel&quot;&gt;runlevels&lt;/a&gt; in which the service should run (runlevels 3-5 are typically used to boot a system that is network capable). Runlevels are a sysvinit-specific concept.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;In addition to defining constructor functions allowing us to construct zero or more process instances, we also need to construct process instances. These can be defined in a &lt;strong&gt;processes model&lt;/strong&gt;:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{ pkgs ? import &amp;lt;nixpkgs&amp;gt; { inherit system; }&lt;br /&gt;, system ? builtins.currentSystem&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;, processManager&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir;&lt;br /&gt;    inherit forceDisableUserChange processManager;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp = rec {&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  nginxReverseProxy = rec {&lt;br /&gt;    port = 8080;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.nginxReverseProxyHostBased {&lt;br /&gt;      webapps = [ webapp ];&lt;br /&gt;      inherit port;&lt;br /&gt;    } {};&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expressions defines two process instances and uses the following conventions:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The first line is a function header in which the function parameters correspond to ajustable properties that apply to all process instances:     &lt;ul&gt;      &lt;li&gt;&lt;i&gt;stateDir&lt;/i&gt; allows you to globally override the base directory in which all state is stored (the default value is: &lt;i&gt;/var&lt;/i&gt;).&lt;/li&gt;      &lt;li&gt;We can also change the locations of each individual state directories: &lt;i&gt;tmpDir&lt;/i&gt;, &lt;i&gt;cacheDir&lt;/i&gt;, &lt;i&gt;logDir&lt;/i&gt;, &lt;i&gt;runtimeDir&lt;/i&gt; etc.) if desired.&lt;/li&gt;      &lt;li&gt;&lt;i&gt;forceDisableUserChange&lt;/i&gt; can be enabled to prevent the process manager to change user permissions and create users and groups. This is useful to facilitate unprivileged user deployments in which the user typically has no rights to change user permissions.&lt;/li&gt;      &lt;li&gt;The &lt;i&gt;processManager&lt;/i&gt; parameter allows you to pick a process manager. All process configurations will be automatically generated for the selected process manager.&lt;br /&gt;      &lt;br /&gt;      For example, if we would pick: &lt;i&gt;systemd&lt;/i&gt; then all configurations get translated to systemd units. &lt;i&gt;supervisord&lt;/i&gt; causes all configurations to be translated to supervisord configuration files.&lt;/li&gt;    &lt;/ul&gt;  &lt;/li&gt;  &lt;li&gt;To get access to constructor functions, we import a &lt;strong&gt;constructors expression&lt;/strong&gt; that composes all constructor functions by calling them with their common parameters (not shown in this blog post).&lt;br /&gt;    &lt;br /&gt;    The constructors expression also contains a reference to the Nix expression that deploys the webapp service, shown in our previous example.&lt;/li&gt;  &lt;li&gt;The processes model defines two processes: a &lt;i&gt;webapp&lt;/i&gt; instance that listens to TCP port 5000 and Nginx that acts as a reverse proxy forwarding requests to &lt;i&gt;webapp&lt;/i&gt; process instances based on the virtual host name.&lt;/li&gt;  &lt;li&gt;&lt;i&gt;webapp&lt;/i&gt; is declared a &lt;strong&gt;dependency&lt;/strong&gt; of the &lt;i&gt;nginxReverseProxy&lt;/i&gt; service (by passing &lt;i&gt;webapp&lt;/i&gt; as a parameter to the constructor function of Nginx). This causes &lt;i&gt;webapp&lt;/i&gt; to be activated before the &lt;i&gt;nginxReverseProxy&lt;/i&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;To deploy all process instances with a process manager, we can invoke a variety of tools that are bundled with the experimental Nix process management framework.&lt;br /&gt;&lt;br /&gt;The process model can be deployed as sysvinit scripts for an unprivileged user, with the following command:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nixproc-sysvinit-switch --state-dir /home/sander/var \&lt;br /&gt;  --force-disable-user-change processes.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above command automatically generates sysvinit scripts, changes the base directory of all state folders to a directory in the user's home directory: &lt;i&gt;/home/sander/var&lt;/i&gt; and disables user changing (and creation) so that an unprivileged user can run it.&lt;br /&gt;&lt;br /&gt;The following command uses systemd as a process manager with the default parameters, for production deployments:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nixproc-systemd-switch processes.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above command automatically generates systemd unit files and invokes systemd to deploy the processes.&lt;br /&gt;&lt;br /&gt;In addition to the examples shown above, the framework contains many more tools, such as: &lt;i&gt;nixproc-supervisord-switch&lt;/i&gt;, &lt;i&gt;nixproc-launchd-switch&lt;/i&gt;, &lt;i&gt;nixproc-bsdrc-switch&lt;/i&gt;, &lt;i&gt;nixproc-cygrunsrv-switch&lt;/i&gt;, and &lt;i&gt;nixproc-disnix-switch&lt;/i&gt; that all work with the same processes model.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Integrating Docker into the process management framework&lt;/h2&gt;&lt;br /&gt;Both Docker and the Nix-based process management framework are multi-functional solutions. After comparing the functionality of Docker and the process management framework, I realized that it is possible to integrate Docker into this framework as well, if I would use it in an unconventional way, by disabling or substituting some if its conflicting features.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Using a shared Nix store&lt;/h3&gt;&lt;br /&gt;As explained in the beginning of this blog post, Docker's primary means to provide dependencies is by using images that are self-contained root file systems containing all necessary files (e.g. packages, configuration files) to allow an application to work.&lt;br /&gt;&lt;br /&gt;In the previous blog post, I have also demonstrated that instead of using traditional &lt;i&gt;Dockerfile&lt;/i&gt;s to construct images, we can also use the Nix package manager as a replacement. A Docker image built by Nix is typically smaller than a conventional Docker image built from a base Linux distribution, because it only contains the runtime dependencies that an application actually needs.&lt;br /&gt;&lt;br /&gt;A major disadvantage of using Nix constructed Docker images is that they only consist of one layer -- as a result, there is no reuse between container instances running different services that use common libraries. To alleviate this problem, Nix can also build layered images, in which common dependencies are isolated in separate layers as much as possible.&lt;br /&gt;&lt;br /&gt;There is even a more optimal reuse strategy possible -- when running Docker on a machine that also has Nix installed, we do not need to put anything that is in the Nix store in a disk image. Instead, we can &lt;strong&gt;share&lt;/strong&gt; the host system's Nix store between Docker containers.&lt;br /&gt;&lt;br /&gt;This may sound scary, but as I have explained in the previous blog post, paths in the Nix store are prefixed with SHA256 hash codes. When two Nix store paths with identical hash codes are built on two different machines, their build results should be (nearly) bit-identical. As a result, it is safe to share the same Nix store path between multiple machines and containers.&lt;br /&gt;&lt;br /&gt;A hacky solution to build a container image, without actually putting any of the Nix built packages in the container, can be done with the following expression:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;with import &amp;lt;nixpkgs&amp;gt; {};&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  cmd = [ &quot;${nginx}/bin/nginx&quot; &quot;-g&quot; &quot;daemon off;&quot; &quot;-c&quot; ./nginx.conf ];&lt;br /&gt;in&lt;br /&gt;dockerTools.buildImage {&lt;br /&gt;  name = &quot;nginxexp&quot;;&lt;br /&gt;  tag = &quot;test&quot;;&lt;br /&gt;&lt;br /&gt;  runAsRoot = ''&lt;br /&gt;    ${dockerTools.shadowSetup}&lt;br /&gt;    groupadd -r nogroup&lt;br /&gt;    useradd -r nobody -g nogroup -d /dev/null&lt;br /&gt;    mkdir -p /var/log/nginx /var/cache/nginx /var/www&lt;br /&gt;    cp ${./index.html} /var/www/index.html&lt;br /&gt;  '';&lt;br /&gt;&lt;br /&gt;  config = {&lt;br /&gt;    Cmd = map (arg: builtins.unsafeDiscardStringContext arg) cmd;&lt;br /&gt;    Expose = {&lt;br /&gt;      &quot;80/tcp&quot; = {};&lt;br /&gt;    };&lt;br /&gt;  };                                                                                                                                                                                                                          &lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above expression is quite similar to the Nix-based Docker image example shown in the previous blog post, that deploys Nginx serving a static HTML page.&lt;br /&gt;&lt;br /&gt;The only difference is how I configure the start command (the &lt;i&gt;Cmd&lt;/i&gt; parameter). In the Nix expression language, &lt;a href=&quot;https://shealevy.com/blog/2018/08/05/understanding-nixs-string-context&quot;&gt;strings have &lt;strong&gt;context&lt;/strong&gt;&lt;/a&gt; -- if a string with context is passed to a build function (any string that contains a value that evaluates to a Nix store path), then the corresponding Nix store paths automatically become a dependency of the package that the build function builds.&lt;br /&gt;&lt;br /&gt;By using the unsafe &lt;i&gt;builtins.unsafeDiscardStringContext&lt;/i&gt; function I can discard the context of strings. As a result, the Nix packages that the image requires are still built. However, because their context is discarded they are no longer considered dependencies of the Docker image. As a consequence, they will not be integrated into the image that the &lt;i&gt;dockerTools.buildImage&lt;/i&gt; creates.&lt;br /&gt;&lt;br /&gt;(As a sidenote: there are still two Nix store paths that end-up in the image, namely &lt;i&gt;bash&lt;/i&gt; and &lt;i&gt;glibc&lt;/i&gt; that is a runtime dependency of &lt;i&gt;bash&lt;/i&gt;. This is caused by the fact that the internals of the &lt;i&gt;dockerTools.buildImage&lt;/i&gt; function make a reference to &lt;i&gt;bash&lt;/i&gt; without discarding its context. In theory, it is also possible to eliminate this dependency as well).&lt;br /&gt;&lt;br /&gt;To run the container and make sure that the required Nix store paths are available, I can mount the host system's Nix store as a shared volume:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run -p 8080:80 -v /nix/store:/nix/store -it nginxexp:latest&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;By mounting the host system's Nix store (with the &lt;i&gt;-v&lt;/i&gt; parameter), Nginx should still behave as expected -- it is not provided by the image, but referenced from the shared Nix store.&lt;br /&gt;&lt;br /&gt;(As a sidenote: mounting the host system's Nix store for sharing is not a new idea. It has already been intensively used by the &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/using-nixos-for-declarative-deployment.html&quot;&gt;NixOS test driver&lt;/a&gt; for many years to rapidly create QEMU virtual machines for system integration tests).&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Using the host system's network&lt;/h3&gt;&lt;br /&gt;As explained in the previous blog post, every Docker container by default runs in its own private network namespace making it possible for services to bind to any port without conflicting with the services on the host system or services provided by any other container.&lt;br /&gt;&lt;br /&gt;The Nix process management framework does not work with private networks, because it is not a generalizable concept (i.e. namespaces are a Linux-only feature). Aside from Docker, the only other process manager supported by the framework that can work with namespaces is systemd.&lt;br /&gt;&lt;br /&gt;To prevent ports and other dynamic resources from conflicting with each other, the process management framework makes it possible to configure them through instance function parameters. If the instance parameters have unique values, they will not conflict with other process instances (based on the assumption that the packager has identified all possible conflicts that a process might have).&lt;br /&gt;&lt;br /&gt;Because we already have a framework that prevents conflicts, we can also instruct Docker to use the host system's network with the &lt;i&gt;--network host&lt;/i&gt; parameter:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run -v /nix/store:/nix/store --network host -it nginxexp:latest&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The only thing the framework cannot provide you is protection -- mallicious services in a private network namespace cannot connect to ports used by other containers or the host system, but the framework cannot protect you from that.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Mapping a base directory for storing state&lt;/h3&gt;&lt;br /&gt;Services that run in containers are not always stateless -- they may rely on data that should be persistently stored, such as databases. &lt;a href=&quot;https://developers.redhat.com/blog/2016/02/24/10-things-to-avoid-in-docker-containers/&quot;&gt;The Docker recommendation to handle persistent state&lt;/a&gt; is not to store it in a container's writable layer, but on a shared volume on the host system.&lt;br /&gt;&lt;br /&gt;Data stored outside the container makes it possible to reliably upgrade a container -- when it is desired to install a newer version of an application, the container can be discarded and recreated from a new image.&lt;br /&gt;&lt;br /&gt;For the Nix process management framework, integration with a state directory outside the container is also useful. With an extra shared volume, we can mount the host system's state directory:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run -v /nix/store:/nix/store \&lt;br /&gt;  -v /var:/var --network host -it nginxexp:latest&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h3&gt;Orchestrating containers&lt;/h3&gt;&lt;br /&gt;The last piece in the puzzle is to orchestrate the containers: we must create or discard them, and start or stop them, and perform all required steps in the right order.&lt;br /&gt;&lt;br /&gt;Moreover, to prevent the Nix packages that a containers needs from being garbage collected, we need to make sure that they are a dependency of a package that is registered as in use.&lt;br /&gt;&lt;br /&gt;I came up with my own convention to implement the container deployment process. When building the processes model for the &lt;i&gt;docker&lt;/i&gt; process manager, the following files are generated that help me orchestrating the deployment process:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;01-webapp-docker-priority&lt;br /&gt;02-nginx-docker-priority&lt;br /&gt;nginx-docker-cmd&lt;br /&gt;nginx-docker-createparams&lt;br /&gt;nginx-docker-settings&lt;br /&gt;webapp-docker-cmd&lt;br /&gt;webapp-docker-createparams&lt;br /&gt;webapp-docker-settings&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above list, we have the following kinds of files:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;The files that have a &lt;i&gt;-docker-settings&lt;/i&gt; suffix contain general properties of the container, such as the image that needs to be used a template.&lt;/li&gt;  &lt;li&gt;The files that have a &lt;i&gt;-docker-createparams&lt;/i&gt; suffix contain the command line parameters that are propagated to &lt;i&gt;docker create&lt;/i&gt; to create the container. If a container with the same name already exists, the container creation is skipped and the existing instance is used instead.&lt;/li&gt;  &lt;li&gt;To prevent the Nix packages that a Docker container needs from being garbage collected the generator creates a file with a &lt;i&gt;-docker-cmd&lt;/i&gt; suffix containing the &lt;i&gt;Cmd&lt;/i&gt; instruction including the full Nix store paths of the packages that a container needs.&lt;br /&gt;    &lt;br /&gt;    Because the strings' contexts are not discarded in the generation process, the packages become a dependency of the configuration file. As long as this configuration file is deployed, the packages will not get garbage collected.&lt;/li&gt;  &lt;li&gt;To ensure that the containers are activated in the right order we have two files that are prefixed with two numeric digits that have a &lt;i&gt;-container-priority&lt;/i&gt; suffix. The numeric digits determine in which order the containers should be activated -- in the above example the webapp process gets activated before Nginx (that acts as a reverse proxy).&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;With the following command, we can automatically generate the configuration files shown above for all our processes in the processes model, and use it to automatically create and start docker containers for all process instances:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;$ nixproc-docker-switch processes.nix&lt;br /&gt;55d833e07428: Loading layer [==================================================&amp;gt;]  46.61MB/46.61MB&lt;br /&gt;Loaded image: webapp:latest&lt;br /&gt;f020f5ecdc6595f029cf46db9cb6f05024892ce6d9b1bbdf9eac78f8a178efd7&lt;br /&gt;nixproc-webapp&lt;br /&gt;95b595c533d4: Loading layer [==================================================&amp;gt;]  46.61MB/46.61MB&lt;br /&gt;Loaded image: nginx:latest&lt;br /&gt;b195cd1fba24d4ec8542c3576b4e3a3889682600f0accc3ba2a195a44bf41846&lt;br /&gt;nixproc-nginx&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The result is two running Docker containers that correspond to the process instances shown in the processes model:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;$ docker ps&lt;br /&gt;CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES                                                   &lt;br /&gt;b195cd1fba24        nginx:latest        &quot;/nix/store/j3v4fz9h…&quot;   15 seconds ago      Up 14 seconds                           nixproc-nginx                                           &lt;br /&gt;f020f5ecdc65        webapp:latest       &quot;/nix/store/b6pz847g…&quot;   16 seconds ago      Up 15 seconds                           nixproc-webapp&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and we should be able to access the example HTML page, by opening the following URL: &lt;i&gt;http://localhost:8080&lt;/i&gt; in a web browser.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Deploying Docker containers in a heteregenous and/or distributed environment&lt;/h2&gt;&lt;br /&gt;As explained in my previous blog posts about the experimental Nix process management framework, the processes model is a sub set of a &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/02/disnix-toolset-for-distributed.html&quot;&gt;Disnix&lt;/a&gt; &lt;strong&gt;services&lt;/strong&gt; model. When it is desired to deploy processes to a network of machines or combine processes with other kinds of services, we can easily turn a processes model into a services model.&lt;br /&gt;&lt;br /&gt;For example, I can change the processes model shown earlier into a services model that deploys Docker containers:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{ pkgs ? import &amp;lt;nixpkgs&amp;gt; { inherit system; }&lt;br /&gt;, system ? builtins.currentSystem&lt;br /&gt;, stateDir ? &quot;/var&quot;&lt;br /&gt;, runtimeDir ? &quot;${stateDir}/run&quot;&lt;br /&gt;, logDir ? &quot;${stateDir}/log&quot;&lt;br /&gt;, cacheDir ? &quot;${stateDir}/cache&quot;&lt;br /&gt;, tmpDir ? (if stateDir == &quot;/var&quot; then &quot;/tmp&quot; else &quot;${stateDir}/tmp&quot;)&lt;br /&gt;, forceDisableUserChange ? false&lt;br /&gt;}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  constructors = import ./constructors.nix {&lt;br /&gt;    inherit pkgs stateDir runtimeDir logDir tmpDir;&lt;br /&gt;    inherit forceDisableUserChange;&lt;br /&gt;    processManager = &quot;docker&quot;;&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;rec {&lt;br /&gt;  webapp = rec {&lt;br /&gt;    name = &quot;webapp&quot;;&lt;br /&gt;&lt;br /&gt;    port = 5000;&lt;br /&gt;    dnsName = &quot;webapp.local&quot;;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.webapp {&lt;br /&gt;      inherit port;&lt;br /&gt;    };&lt;br /&gt;&lt;br /&gt;    type = &quot;docker-container&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  nginxReverseProxy = rec {&lt;br /&gt;    name = &quot;nginxReverseProxy&quot;;&lt;br /&gt;&lt;br /&gt;    port = 8080;&lt;br /&gt;&lt;br /&gt;    pkg = constructors.nginxReverseProxyHostBased {&lt;br /&gt;      webapps = [ webapp ];&lt;br /&gt;      inherit port;&lt;br /&gt;    } {};&lt;br /&gt;&lt;br /&gt;    type = &quot;docker-container&quot;;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above example, I have added a &lt;i&gt;name&lt;/i&gt; attribute to each process (a required property for Disnix service models) and a &lt;i&gt;type&lt;/i&gt; attribute referring to: &lt;i&gt;docker-container&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;In Disnix, a service could take any form. A plugin system (named &lt;a href=&quot;https://sandervanderburg.blogspot.com/2015/07/deploying-state-with-disnix.html&quot;&gt;Dysnomia&lt;/a&gt;) is responsible for managing the life-cycle of a service, such as activating or deactivating it. The &lt;i&gt;type&lt;/i&gt; attribute is used to tell Disnix that we should use the &lt;i&gt;docker-container&lt;/i&gt; Dysnomia module. This module will automatically create and start the container on activation, and stop and discard the container on deactivation.&lt;br /&gt;&lt;br /&gt;To deploy the above services to a network of machines, we require an &lt;strong&gt;infrastructure model&lt;/strong&gt; (that captures the available machines and their relevant deployment properties):&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{&lt;br /&gt;  test1.properties.hostname = &quot;test1&quot;;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above infrastructure model contains only one target machine: &lt;i&gt;test1&lt;/i&gt; with a hostname that is identical to the machine name.&lt;br /&gt;&lt;br /&gt;We also require a &lt;strong&gt;distribution model&lt;/strong&gt; that maps services in the services model to machines in the infrastructure model:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{infrastructure}:&lt;br /&gt;&lt;br /&gt;{&lt;br /&gt;  webapp = [ infrastructure.test1 ];&lt;br /&gt;  nginxReverseProxy = [ infrastructure.test1 ];&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above distribution model, we map the all the processes in the services model to the &lt;i&gt;test1&lt;/i&gt; target machine in the infrastructure model.&lt;br /&gt;&lt;br /&gt;With the following command, we can deploy our Docker containers to the remote &lt;i&gt;test1&lt;/i&gt; target machine:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ disnix-env -s services.nix -i infrastructure.nix -d distribution.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;When the above command succeeds, the &lt;i&gt;test1&lt;/i&gt; target machine provides running &lt;i&gt;webapp&lt;/i&gt; and &lt;i&gt;nginxReverseProxy&lt;/i&gt; containers.&lt;br /&gt;&lt;br /&gt;(As a sidenote: to make Docker container deployments work with Disnix, the Docker service already needs to be predeployed to the target machines in the infrastructure model, or the Docker daemon needs to be deployed as a &lt;a href=&quot;https://sandervanderburg.blogspot.com/2020/04/deploying-container-and-application.html&quot;&gt;container provider&lt;/a&gt;).&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Deploying conventional Docker containers with Disnix&lt;/h2&gt;&lt;br /&gt;The nice thing about the &lt;i&gt;docker-container&lt;/i&gt; Dysnomia module is that it is generic enough to also work with conventional Docker containers (that work with images, not a shared Nix store).&lt;br /&gt;&lt;br /&gt;For example, we can deploy Nginx as a regular container built with the &lt;i&gt;dockerTools.buildImage&lt;/i&gt; function:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;font-size: 90%; overflow: auto;&quot;&gt;&lt;br /&gt;{dockerTools, stdenv, nginx}:&lt;br /&gt;&lt;br /&gt;let&lt;br /&gt;  dockerImage = dockerTools.buildImage {&lt;br /&gt;    name = &quot;nginxexp&quot;;&lt;br /&gt;    tag = &quot;test&quot;;&lt;br /&gt;    contents = nginx;&lt;br /&gt;&lt;br /&gt;    runAsRoot = ''&lt;br /&gt;      ${dockerTools.shadowSetup}&lt;br /&gt;      groupadd -r nogroup&lt;br /&gt;      useradd -r nobody -g nogroup -d /dev/null&lt;br /&gt;      mkdir -p /var/log/nginx /var/cache/nginx /var/www&lt;br /&gt;      cp ${./index.html} /var/www/index.html&lt;br /&gt;    '';&lt;br /&gt;&lt;br /&gt;    config = {&lt;br /&gt;      Cmd = [ &quot;${nginx}/bin/nginx&quot; &quot;-g&quot; &quot;daemon off;&quot; &quot;-c&quot; ./nginx.conf ];&lt;br /&gt;      Expose = {&lt;br /&gt;        &quot;80/tcp&quot; = {};&lt;br /&gt;      };&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;in&lt;br /&gt;stdenv.mkDerivation {&lt;br /&gt;  name = &quot;nginxexp&quot;;&lt;br /&gt;  buildCommand = ''&lt;br /&gt;    mkdir -p $out&lt;br /&gt;    cat &amp;gt; $out/nginxexp-docker-settings &amp;lt;&amp;lt;EOF&lt;br /&gt;    dockerImage=${dockerImage}&lt;br /&gt;    dockerImageTag=nginxexp:test&lt;br /&gt;    EOF&lt;br /&gt;&lt;br /&gt;    cat &amp;gt; $out/nginxexp-docker-createparams &amp;lt;&amp;lt;EOF&lt;br /&gt;    -p&lt;br /&gt;    8080:80&lt;br /&gt;    EOF&lt;br /&gt;  '';&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above example, instead of using the process manager-agnostic &lt;i&gt;createManagedProcess&lt;/i&gt;, I directly construct a Docker-based Nginx image (by using the &lt;i&gt;dockerImage&lt;/i&gt; attribute) and container configuration files (in the &lt;i&gt;buildCommand&lt;/i&gt; parameter) to make the container deployments work with the &lt;i&gt;docker-container&lt;/i&gt; Dysnomia module.&lt;br /&gt;&lt;br /&gt;It is also possible to deploy containers from images that are constructed with &lt;i&gt;Dockerfile&lt;/i&gt;s. After we have built an image in the traditional way, we can export it from Docker with the following command:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker save nginx-debian -o nginx-debian.tar.gz&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and then we can use the following Nix expression to deploy a container using our exported image:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;{dockerTools, stdenv, nginx}:&lt;br /&gt;&lt;br /&gt;stdenv.mkDerivation {&lt;br /&gt;  name = &quot;nginxexp&quot;;&lt;br /&gt;  buildCommand = ''&lt;br /&gt;    mkdir -p $out&lt;br /&gt;    cat &amp;gt; $out/nginxexp-docker-settings &amp;lt;&amp;lt;EOF&lt;br /&gt;    dockerImage=${./nginx-debian.tar.gz}&lt;br /&gt;    dockerImageTag=nginxexp:test&lt;br /&gt;    EOF&lt;br /&gt;&lt;br /&gt;    cat &amp;gt; $out/nginxexp-docker-createparams &amp;lt;&amp;lt;EOF&lt;br /&gt;    -p&lt;br /&gt;    8080:80&lt;br /&gt;    EOF&lt;br /&gt;  '';&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;In the above expression, the &lt;i&gt;dockerImage&lt;/i&gt; property refers to our exported image.&lt;br /&gt;&lt;br /&gt;Although Disnix is flexible enough to also orchestrate Docker containers (thanks to its generalized plugin architecture), I did not develop the &lt;i&gt;docker-container&lt;/i&gt; Dysnomia module to make Disnix compete with existing container orchestration solutions, such as &lt;a href=&quot;https://kubernetes.io/&quot;&gt;Kubernetes&lt;/a&gt; or &lt;a href=&quot;https://docs.docker.com/engine/swarm/&quot;&gt;Docker Swarm&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;Disnix is a heterogeneous deployment tool that can be used to integrate units that have all kinds of shapes and forms on all kinds of operating systems -- having a &lt;i&gt;docker-container&lt;/i&gt; module makes it possible to mix Docker containers with other service types that Disnix and Dysnomia support.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Discussion&lt;/h2&gt;&lt;br /&gt;In this blog post, I have demonstrated that we can integrate Docker as a process management backend option into the experimental Nix process management framework, by substituting some of its conflicting features.&lt;br /&gt;&lt;br /&gt;Moreover, because a Disnix service model is a superset of a processes model, we can also use Disnix as a simple Docker container orchestrator and integrate Docker containers with other kinds of services.&lt;br /&gt;&lt;br /&gt;Compared to Docker, the Nix process management framework supports a number of features that Docker does not:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Docker is heavily developed around Linux-specific concepts, such as namespaces and cgroups. As a result, it can only be used to deploy software built for Linux.&lt;br /&gt;    &lt;br /&gt;    The Nix process management framework should work on any operating system that is supported by the Nix package manager (e.g. Nix also has first class support for macOS, and can also be used on other UNIX-like operating systems such as FreeBSD). The same also applies to Disnix.&lt;/li&gt;  &lt;li&gt;The Nix process management framework can work with &lt;i&gt;sysvinit&lt;/i&gt;, &lt;i&gt;BSD rc&lt;/i&gt; and Disnix process scripts, that do not require any external service to manage a process' life-cycle. This is convenient for local unprivileged user deployments. To deploy Docker containers, you need to have the Docker daemon installed first.&lt;/li&gt;  &lt;li&gt;Docker has an experimental rootless deployment mode, but in the Nix process management framework facilitating unprivileged user deployments is a first class concept.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;On the other hand, the Nix process management framework does not take over all responsibilities of Docker:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;  &lt;li&gt;Docker heavily relies on namespaces to prevent resource conflicts, such as overlapping TCP ports and global state directories. The Nix process management framework solves conflicts by avoiding them (i.e. configuring properties in such a way that they are unique). The conflict avoidance approach works as long as a service is well-specified. Unfortunately, preventing conflicts is not a hard guarantee that the tool can provide you.&lt;/li&gt;  &lt;li&gt;Docker also provides some degree of protection by using namespaces and cgroups. The Nix process management framework does not support this out of the box, because these concepts are not generalizable over all the process management backends it supports. (As a sidenote: it is still possible to use these concepts by defining process manager-specific overrides).&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;From a functionality perspective, &lt;a href=&quot;https://docs.docker.com/compose&quot;&gt;&lt;i&gt;docker-compose&lt;/i&gt;&lt;/a&gt; comes close to the features that the experimental Nix process management framework supports. &lt;i&gt;docker-compose&lt;/i&gt; allows you to declaratively define container instances and their dependencies, and automatically deploy them.&lt;br /&gt;&lt;br /&gt;However, as its name implies &lt;i&gt;docker-compose&lt;/i&gt; is specifically designed for deploying Docker containers whereas the Nix process management framework is more general -- it should work with all kinds of process managers, uses Nix as the primary means to provide dependencies, it uses the Nix expression language for configuration and it should work on a variety of operating systems.&lt;br /&gt;&lt;br /&gt;The fact that Docker (and containers in general) are multi-functional solutions is not an observation only made by me. For example, &lt;a href=&quot;https://iximiuz.com/en/posts/you-dont-need-an-image-to-run-a-container&quot;&gt;this blog post&lt;/a&gt; also demonstrates that containers can work without images.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Availability&lt;/h2&gt;&lt;br /&gt;The Docker backend has been integrated into the &lt;a href=&quot;https://github.com/svanderburg/nix-processmgmt&quot;&gt;latest development version&lt;/a&gt; of the Nix process management framework.&lt;br /&gt;&lt;br /&gt;To use the &lt;i&gt;docker-container&lt;/i&gt; Dysnomia module (so that Disnix can deploy Docker containers), you need to install the latest development version of Dysnomia.&lt;br /&gt;</description>
	<pubDate>Tue, 11 Aug 2020 19:18:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Matej Cotman: Neovim, WSL and Nix</title>
	<guid isPermaLink="true">https://blog.matejc.com/blogs/myblog/neovim-wsl-and-nix</guid>
	<link>https://blog.matejc.com/blogs/myblog/neovim-wsl-and-nix</link>
	<description>&lt;p&gt;How to use Neovim (Neovim-Qt) under WSL 1/2 with the power of Nix&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Well we all know that generally development on Linux is easier than on Windows, but sometimes you are forced to use Windows. But that does not mean that all those nice tools from Linux are not available to you, as we will see in this post.&lt;/p&gt;

&lt;p&gt;Windows has some thing called WSL which enables you to run Linux tools natively in the Windows subsystem.
Not all is without issues, you can not run graphical Linux applications because Windows does not run Xorg server, yeah you have Xorg ports that run there but that is in this case just one more unwanted layer, remember, building efficient solutions is what every engineer should strive to.&lt;/p&gt;

&lt;p&gt;What I did is to use Windows pre-built binaries of Neovim-Qt and run the Neovim installed with Nix inside WSL.&lt;/p&gt;

&lt;p&gt;Ok, you could say then, why not use VS Code with some Vim/Neovim plugin and use so called Remote-WSL plugin to access WSL… Well yes, but at least me I stumble upon few issues.
First was that CPU usage was through the roof when Remote-WSL extension was in use on WSL1 (I could not just run Windows Update on client’s managed computer) and the fix was to install specific version of libc with dpkg (which is absurd in the first place because this is a good way to ruin your whole environment).
Applying this fix did the trick for lowering the CPU usage. The second issue come right after, when I wanted to install some package with APT package manager, like I predicted, libc install did its damage, I could not install or un-install anything with APT. Nix comes again to the rescue.&lt;/p&gt;

&lt;p&gt;By the way the &lt;strong&gt;sleep&lt;/strong&gt; command forgot how to work under WSL and Ubuntu 20.04 &lt;a href=&quot;https://askubuntu.com/questions/1230252/sleep-doesnt-work-on-ubuntu-20-04-wsl&quot;&gt;Source&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;lets-see-the-solution&quot;&gt;Let’s see the solution&lt;/h2&gt;

&lt;h3 id=&quot;neovim-qt&quot;&gt;Neovim-Qt&lt;/h3&gt;

&lt;p&gt;Neovim-Qt has nicely built binaries on their GitHub page for Windows, so I just downloaded that zip and unpacked it into &lt;strong&gt;C:/Program Files/neovim-qt/&lt;/strong&gt;. But any location could do.&lt;/p&gt;

&lt;h3 id=&quot;wsl&quot;&gt;WSL&lt;/h3&gt;

&lt;p&gt;Open PowerShell as Administrator and run:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-powershell&quot;&gt;&lt;span class=&quot;nf&quot;&gt;dism.exe&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;/online&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;/enable-feature&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;/featurename:Microsoft-Windows-Subsystem-Linux&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;/all&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;/norestart&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you do not have up to date Windows for any kind of reason to install WLS2 then reboot now.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reboot Time&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You should have now enabled the WSL1 and you can proceed to install Ubuntu 20.04 (or any other Linux distro you like) from Microsoft store.
Do not forget to click Launch after installing it (it will ask you to create a user).&lt;/p&gt;

&lt;h3 id=&quot;nix&quot;&gt;Nix&lt;/h3&gt;

&lt;p&gt;To install Nix, you need to first open some terminal emulator and run &lt;strong&gt;wsl.exe&lt;/strong&gt;, but you can also just run it from Start menu.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;bash &amp;lt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt; https://nixos.org/nix/install&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To finish you can just close the terminal and open wsl.exe again.&lt;/p&gt;

&lt;p&gt;Thats it.&lt;/p&gt;

&lt;h3 id=&quot;the-nix-script&quot;&gt;The Nix script&lt;/h3&gt;

&lt;p&gt;Now here is the absolutely most awesome part that connects everything together.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;pkgs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;nixpkgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}:&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;pkgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;writeScript&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;run-neovim-qt.sh&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    #!&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pkgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;stdenv&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;shell&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    set -e&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    # get random free port&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    export NVIM_LISTEN=&quot;127.0.0.1:$(&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pkgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;python3Packages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;python&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/bin/python -c 'import socket; s=socket.socket(); s.bind((&quot;&quot;, 0)); print(s.getsockname()[1]); s.close()')&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    # use python's sleep, because coreutils' sleep does not function under Ubuntu 20.04 and WSL&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    #   after delay start nvim-qt - so that nvim starts before the GUI&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    { &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pkgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;python3Packages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;python&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/bin/python -c 'import time; time.sleep(1)'; &quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;''$&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;{NVIM_QT_PATH}&quot; --server &quot;$NVIM_LISTEN&quot;; } &amp;amp;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    # start nvim&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pkgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;neovim&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/bin/nvim --listen &quot;$NVIM_LISTEN&quot; --headless &quot;$@&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;''&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Save it to your drive or download with &lt;strong&gt;wget&lt;/strong&gt; under WSL:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;wget https://raw.githubusercontent.com/matejc/helper_scripts/master/nixes/neovim-qt.nix &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Then build the command with:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-build ./neovim-qt.nix&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The resulting script is &lt;strong&gt;./result&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;/h3&gt;

&lt;p&gt;First we need to tell the script where is the Neovim-qt located:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;NVIM_QT_PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'/mnt/c/Program Files/neovim-qt/bin/nvim-qt.exe'&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can save this into &lt;strong&gt;.bashrc&lt;/strong&gt; or &lt;strong&gt;.profile&lt;/strong&gt; and restart the terminal so that you do not need to repeat the step every time you run wsl shell.&lt;/p&gt;

&lt;p&gt;The final step is:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;./result my/awesome/code.py&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Too much work? You think? Well how much more time you would use using and configuring VS Code or Atom to work under similar environment?
And what about Nix? You can install it without the use of native package managers (in case the native one is b0rked) and once you do, you have the power to install your favorite development environment with single command.&lt;/p&gt;

&lt;p&gt;I like this solution, in my eyes its simple and efficient, what are your thoughts?&lt;/p&gt;

&lt;p&gt;Until next time… I wish you happy hacking!&lt;/p&gt;

&lt;h2 id=&quot;links&quot;&gt;Links&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/vscode-remote-release/issues/2921&quot;&gt;High cpu usage of node process in Remote-WSL extension #2921&lt;/a&gt;
&lt;a href=&quot;https://github.com/equalsraf/neovim-qt/releases&quot;&gt;Neovim-Qt Releases&lt;/a&gt;
&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/wsl/install-win10&quot;&gt;WSL on Windows 10&lt;/a&gt;
&lt;a href=&quot;https://nixos.org/nix/manual/#chap-quick-start&quot;&gt;Quick start with Nix&lt;/a&gt;&lt;/p&gt;</description>
	<pubDate>Fri, 07 Aug 2020 22:00:00 +0000</pubDate>
</item>
<item>
	<title>Tweag I/O: Nix Flakes, Part 3: Managing NixOS systems</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-07-31-nixos-flakes/</guid>
	<link>https://tweag.io/blog/2020-07-31-nixos-flakes/</link>
	<description>&lt;p&gt;This is the third in a series of blog posts about &lt;a href=&quot;https://github.com/NixOS/rfcs/pull/49&quot;&gt;&lt;em&gt;Nix
flakes&lt;/em&gt;&lt;/a&gt;. The &lt;a href=&quot;https://www.tweag.io/../2020-05-25-flakes&quot;&gt;first
part&lt;/a&gt; motivated why we developed flakes — to
improve Nix’s reproducibility, composability and usability — and gave
a short tutorial on how to use flakes. The &lt;a href=&quot;https://www.tweag.io/../2020-06-25-eval-cache&quot;&gt;second
part&lt;/a&gt; showed how flakes enable reliable
caching of Nix evaluation results. In this post, we show how flakes
can be used to manage NixOS systems in a reproducible and composable
way.&lt;/p&gt;
&lt;h2&gt;What problems are we trying to solve?&lt;/h2&gt;
&lt;h3&gt;Lack of reproducibility&lt;/h3&gt;
&lt;p&gt;One of the main selling points of NixOS is reproducibility: given a
specification of a system, if you run &lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt; to deploy it,
you should always get the same &lt;em&gt;actual&lt;/em&gt; system (modulo mutable state
such as the contents of databases). For instance, we should be able to
reproduce in a production environment the exact same configuration
that we’ve previously validated in a test environment.&lt;/p&gt;
&lt;p&gt;However, the default NixOS workflow doesn’t provide reproducible
system configurations out of the box. Consider a typical sequence of
commands to upgrade a NixOS system:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You edit &lt;code class=&quot;language-text&quot;&gt;/etc/nixos/configuration.nix&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;You run &lt;code class=&quot;language-text&quot;&gt;nix-channel --update&lt;/code&gt; to get the latest version of the
&lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; repository (which contains the NixOS sources).&lt;/li&gt;
&lt;li&gt;You run &lt;code class=&quot;language-text&quot;&gt;nixos-rebuild switch&lt;/code&gt;, which evaluates and builds a
function in the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; repository that takes
&lt;code class=&quot;language-text&quot;&gt;/etc/nixos/configuration.nix&lt;/code&gt; as an input.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this workflow, &lt;code class=&quot;language-text&quot;&gt;/etc/nixos/configuration.nix&lt;/code&gt; might not be under
configuration management (e.g. point to a Git repository), or if it
is, it might be a dirty working tree. Furthermore, &lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt;
doesn’t specify what Git revision of &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; to use; so if somebody
else deploys the same &lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt;, they might get a very
different result.&lt;/p&gt;
&lt;h3&gt;Lack of traceability&lt;/h3&gt;
&lt;p&gt;The ability to reproduce a configuration is not very useful if you
can’t tell what configuration you’re actually running. That is, from a
running system, you should be able to get back to its
specification. So there is a lack of &lt;em&gt;traceability&lt;/em&gt;: the ability to
trace derived artifacts back to their sources. This is an essential
property of good configuration management, since without it, we don’t
know &lt;em&gt;what&lt;/em&gt; we’re actually running in production, so reproducing or
fixing problems becomes much harder.&lt;/p&gt;
&lt;p&gt;NixOS currently doesn’t not have very good traceability. You can ask a
NixOS system what version of Nixpkgs it was built from:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nixos-version --json | jq -r .nixpkgsRevision
a84b797b28eb104db758b5cb2b61ba8face6744b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately, this doesn’t allow you to recover &lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt;
or any other external NixOS modules that were used by the
configuration.&lt;/p&gt;
&lt;h3&gt;Lack of composability&lt;/h3&gt;
&lt;p&gt;It’s easy to enable a package or system service in a NixOS
configuration if it is part of the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; repository: you just add
a line like &lt;code class=&quot;language-text&quot;&gt;environment.systemPackages = [ pkgs.hello ];&lt;/code&gt; or
&lt;code class=&quot;language-text&quot;&gt;services.postgresql.enable = true;&lt;/code&gt; to your &lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt;. But
what if we want to use a package or service that &lt;em&gt;isn’t&lt;/em&gt; part of
Nixpkgs? Then we’re forced to use mechanisms like &lt;code class=&quot;language-text&quot;&gt;$NIX_PATH&lt;/code&gt;,
&lt;code class=&quot;language-text&quot;&gt;builtins.fetchGit&lt;/code&gt;, imports using relative paths, and so on. These
are not standardized (since everybody uses different conventions) and
are inconvenient to use (for example, when using &lt;code class=&quot;language-text&quot;&gt;$NIX_PATH&lt;/code&gt;, it’s the
user’s responsibility to put external repositories in the right
directories).&lt;/p&gt;
&lt;p&gt;Put another way: NixOS is currently built around a &lt;em&gt;monorepo&lt;/em&gt; workflow
— the entire universe should be added to the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; repository,
because anything that isn’t, is much harder to use.&lt;/p&gt;
&lt;p&gt;It’s worth noting that any NixOS system configuration already violates
the monorepo assumption: your system’s &lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt; is not part
of the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; repository.&lt;/p&gt;
&lt;h2&gt;Using flakes for NixOS configurations&lt;/h2&gt;
&lt;p&gt;In the previous post, we saw that flakes are (typically) Git
repositories that have a file named &lt;code class=&quot;language-text&quot;&gt;flake.nix&lt;/code&gt;, providing a
standardized interface to Nix artifacts. We saw flakes that provide
packages and development environments; now we’ll use them to provide
&lt;em&gt;NixOS system configurations&lt;/em&gt;. This solves the problems described
above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Reproducibility&lt;/em&gt;: the entire system configuration (including
everything it depends on) is captured by the flake and its lock
file. So if two people check out the same Git revision of a flake
and build it, they should get the same result.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Traceability&lt;/em&gt;: &lt;code class=&quot;language-text&quot;&gt;nixos-version&lt;/code&gt; prints the Git revision of the
top-level configuration flake, not its &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; input.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Composability&lt;/em&gt;: it’s easy to pull in packages and modules from other
repositories as flake inputs.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;Flake support has been added as an experimental feature to NixOS
20.03. However, flake support is not part of the current stable
release of Nix (2.3). So to get a NixOS system that supports flakes,
you first need to switch to the &lt;code class=&quot;language-text&quot;&gt;nixUnstable&lt;/code&gt; package and enable some
experimental features. This can be done by adding the following to
&lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;package &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; pkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nixUnstable&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;extraOptions &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;''
  experimental-features = nix-command flakes
''&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Creating a NixOS configuration flake&lt;/h2&gt;
&lt;p&gt;Let’s create a flake that contains the configuration for a NixOS
container.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ git init my-flake
$ cd my-flake
$ nix flake init -t templates#simpleContainer
$ git commit -a -m 'Initial version'&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the &lt;code class=&quot;language-text&quot;&gt;-t&lt;/code&gt; flag to &lt;code class=&quot;language-text&quot;&gt;nix flake init&lt;/code&gt; specifies a &lt;em&gt;template&lt;/em&gt;
from which to copy the initial contents of the flake. This is useful
for getting started. To see what templates are available, you can run:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nix flake show templates&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For reference, this is what the initial &lt;code class=&quot;language-text&quot;&gt;flake.nix&lt;/code&gt; looks like:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  inputs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;url &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;github:NixOS/nixpkgs/nixos-20.03&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  outputs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nixpkgs &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

    nixosConfigurations&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;container &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lib&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nixosSystem &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      system &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;x86_64-linux&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      modules &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; pkgs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            boot&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;isContainer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;token comment&quot;&gt;# Let 'nixos-version --json' know about the Git revision&lt;/span&gt;
            &lt;span class=&quot;token comment&quot;&gt;# of this flake.&lt;/span&gt;
            system&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;configurationRevision &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lib&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mkIf &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; rev&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;rev&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;token comment&quot;&gt;# Network configuration.&lt;/span&gt;
            networking&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;useDHCP &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            networking&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firewall&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;allowedTCPPorts &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;80&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;token comment&quot;&gt;# Enable a web server.&lt;/span&gt;
            services&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;httpd &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
              enable &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
              adminAddr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;morty@example.org&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That is, the flake has one input, namely &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; - specifically the
20.03 branch. It has one output, &lt;code class=&quot;language-text&quot;&gt;nixosConfigurations.container&lt;/code&gt;, which
evaluates a NixOS configuration for tools like
&lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;nixos-container&lt;/code&gt;. The main argument is &lt;code class=&quot;language-text&quot;&gt;modules&lt;/code&gt;,
which is a list of NixOS configuration modules. This takes the place
of the file &lt;code class=&quot;language-text&quot;&gt;configuration.nix&lt;/code&gt; in non-flake deployments. (In fact,
you can write &lt;code class=&quot;language-text&quot;&gt;modules = [ ./configuration.nix ]&lt;/code&gt; if you’re converting
a pre-flake NixOS configuration.)&lt;/p&gt;
&lt;p&gt;Let’s create and start the container! (Note that &lt;code class=&quot;language-text&quot;&gt;nixos-container&lt;/code&gt;
currently requires you to be &lt;code class=&quot;language-text&quot;&gt;root&lt;/code&gt;.)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-container create flake-test --flake /path/to/my-flake
host IP is 10.233.4.1, container IP is 10.233.4.2

# nixos-container start flake-test&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To check whether the container works, let’s try to connect to it:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ curl http://flake-test/
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;It works!&amp;lt;/h1&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As an aside, if you just want to &lt;em&gt;build&lt;/em&gt; the container without the
&lt;code class=&quot;language-text&quot;&gt;nixos-container&lt;/code&gt; command, you can do so as follows:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nix build /path/to/my-flake#nixosConfigurations.container.config.system.build.toplevel&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code class=&quot;language-text&quot;&gt;system.build.toplevel&lt;/code&gt; is an internal NixOS option that
evaluates to the “system” derivation that commands like
&lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;nixos-install&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;nixos-container&lt;/code&gt; build and
activate. The symlink &lt;code class=&quot;language-text&quot;&gt;/run/current-system&lt;/code&gt; points to the output of
this derivation.&lt;/p&gt;
&lt;h2&gt;Hermetic evaluation&lt;/h2&gt;
&lt;p&gt;One big difference between “regular” NixOS systems and flake-based
NixOS systems is that the latter record the Git revisions from which
they were built. We can query this as follows:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-container run flake-test -- nixos-version --json
{&quot;configurationRevision&quot;:&quot;9190c396f4dcfc734e554768c53a81d1c231c6a7&quot;
,&quot;nixosVersion&quot;:&quot;20.03.20200622.13c15f2&quot;
,&quot;nixpkgsRevision&quot;:&quot;13c15f26d44cf7f54197891a6f0c78ce8149b037&quot;}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, &lt;code class=&quot;language-text&quot;&gt;configurationRevision&lt;/code&gt; is the Git revision of the repository
&lt;code class=&quot;language-text&quot;&gt;/path/to/my-flake&lt;/code&gt;. Because evaluation is hermetic, and the lock file
locks all flake inputs such as &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt;, knowing the revision
&lt;code class=&quot;language-text&quot;&gt;9190c39…&lt;/code&gt; allows you to completely reconstruct this configuration at
a later point in time. For example, if you want to deploy this
particular configuration to a container, you can do:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-container update flake-test \
    --flake /path/to/my-flake?rev=9190c396f4dcfc734e554768c53a81d1c231c6a7&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Dirty configurations&lt;/h2&gt;
&lt;p&gt;It’s not required that you commit all changes to a configuration
before deploying it. For example, if you change the &lt;code class=&quot;language-text&quot;&gt;adminAddr&lt;/code&gt; line
in &lt;code class=&quot;language-text&quot;&gt;flake.nix&lt;/code&gt; to&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;adminAddr &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;rick@example.org&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and redeploy the container, you will get:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-container update flake-test
warning: Git tree '/path/to/my-flake' is dirty
...
reloading container...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the container will no longer have a configuration Git revision:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-container run flake-test -- nixos-version --json | jq .configurationRevision
null&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While this may be convenient for testing, in production we really want
to ensure that systems are deployed from clean Git trees. One way is
to disallow dirty trees on the command line:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-container update flake-test --no-allow-dirty
error: --- Error -------------------- nix
Git tree '/path/to/my-flake' is dirty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another is to require a clean Git tree in &lt;code class=&quot;language-text&quot;&gt;flake.nix&lt;/code&gt;, for instance by
adding a check to the definition of &lt;code class=&quot;language-text&quot;&gt;system.configurationRevision&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;system&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;configurationRevision &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; self &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; rev
  &lt;span class=&quot;token keyword&quot;&gt;then&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;rev
  &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Refusing to build from a dirty Git tree!&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Adding modules from third-party flakes&lt;/h2&gt;
&lt;p&gt;One of the main goals of flake-based NixOS is to make it easier to use
packages and modules that are not included in the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt;
repository. As an example, we’ll add
&lt;a href=&quot;https://github.com/NixOS/hydra/blob/master/flake.nix&quot;&gt;Hydra&lt;/a&gt; (a
continuous integration server) to our container.&lt;/p&gt;
&lt;p&gt;Here’s how we add it to our container. We specify it as an additional input:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;  inputs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hydra&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;url &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;github:NixOS/hydra&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and as a corresponding function argument to the &lt;code class=&quot;language-text&quot;&gt;outputs&lt;/code&gt; function:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;  outputs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; hydra &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, we enable the NixOS module provided by the &lt;code class=&quot;language-text&quot;&gt;hydra&lt;/code&gt; flake:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;      modules &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; hydra&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nixosModules&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hydraTest

          &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; pkgs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; our own configuration &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;

            &lt;span class=&quot;token comment&quot;&gt;# Hydra runs on port 3000 by default, so open it in the firewall.&lt;/span&gt;
            networking&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;firewall&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;allowedTCPPorts &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we can discover the name of this module by using &lt;code class=&quot;language-text&quot;&gt;nix flake show&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nix flake show github:NixOS/hydra
github:NixOS/hydra/d0deebc4fc95dbeb0249f7b774b03d366596fbed
├───…
├───nixosModules
│   ├───hydra: NixOS module
│   ├───hydraProxy: NixOS module
│   └───hydraTest: NixOS module
└───overlay: Nixpkgs overlay&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After committing this change and running &lt;code class=&quot;language-text&quot;&gt;nixos-container update&lt;/code&gt;, we
can check whether &lt;code class=&quot;language-text&quot;&gt;hydra&lt;/code&gt; is working in the container by visiting
&lt;a href=&quot;http://flake-test:3000/&quot;&gt;http://flake-test:3000/&lt;/a&gt; in a web browser.&lt;/p&gt;
&lt;h2&gt;Working with lock files&lt;/h2&gt;
&lt;p&gt;There are a few command line flags accepted by &lt;code class=&quot;language-text&quot;&gt;nix&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt;
and &lt;code class=&quot;language-text&quot;&gt;nixos-container&lt;/code&gt; that make updating lock file more
convenient. A very common action is to update a flake input to the
latest version; for example,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nixos-container update flake-test --update-input nixpkgs --commit-lock-file&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;updates the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; input to the latest revision on the
&lt;code class=&quot;language-text&quot;&gt;nixos-20.03&lt;/code&gt; branch, and commits the new lock file with a commit
message that records the input change.&lt;/p&gt;
&lt;p&gt;A useful flag during development is &lt;code class=&quot;language-text&quot;&gt;--override-input&lt;/code&gt;, which allows
you to point a flake input to another location, completely overriding
the input location specified by &lt;code class=&quot;language-text&quot;&gt;flake.nix&lt;/code&gt;. For example, this is how
you can build the container against a local Git checkout of Hydra:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;$ nixos-container update flake-test --override-input hydra /path/to/my/hydra&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Adding overlays from third-party flakes&lt;/h2&gt;
&lt;p&gt;Similarly, we can add Nixpkgs overlays from other flakes. (Nixpkgs
overlays add or override packages in the &lt;code class=&quot;language-text&quot;&gt;pkgs&lt;/code&gt; set.) For example,
here is how you add the overlay provided by &lt;a href=&quot;https://github.com/NixOS/nix/blob/flakes/flake.nix&quot;&gt;the &lt;code class=&quot;language-text&quot;&gt;nix&lt;/code&gt;
flake&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;  outputs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; nix &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    nixosConfigurations&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;container &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lib&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nixosSystem &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
      modules &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
          &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; pkgs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;overlays &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt; nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;overlay &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
          &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Using &lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Above we saw how to manage NixOS containers using flakes. Managing
“real” NixOS systems works much the same, except using &lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt;
instead of &lt;code class=&quot;language-text&quot;&gt;nixos-container&lt;/code&gt;. For example,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-console&quot;&gt;&lt;code class=&quot;language-console&quot;&gt;# nixos-rebuild switch --flake /path/to/my-flake#my-machine&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;builds and activates the configuration specified by the flake output
&lt;code class=&quot;language-text&quot;&gt;nixosConfigurations.my-machine&lt;/code&gt;. If you omit the name of the
configuration (&lt;code class=&quot;language-text&quot;&gt;#my-machine&lt;/code&gt;), &lt;code class=&quot;language-text&quot;&gt;nixos-rebuild&lt;/code&gt; defaults to using the
current host name.&lt;/p&gt;
&lt;h2&gt;Pinning Nixpkgs&lt;/h2&gt;
&lt;p&gt;It’s often convenient to &lt;em&gt;pin&lt;/em&gt; the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; flake to the exact
version of &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; used to build the system. This ensures that
commands like &lt;code class=&quot;language-text&quot;&gt;nix shell nixpkgs#&amp;lt;package&amp;gt;&lt;/code&gt; work more efficiently
since many or all of the dependencies of &lt;code class=&quot;language-text&quot;&gt;&amp;lt;package&amp;gt;&lt;/code&gt; will already be
present. Here is a bit of NixOS configuration that pins &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; in
the system-wide flake registry:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;nix&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;registry&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;flake &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nixpkgs&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that this only affects commands that reference &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; without
further qualifiers; more specific flake references like
&lt;code class=&quot;language-text&quot;&gt;nixpkgs/nixos-20.03&lt;/code&gt; or
&lt;code class=&quot;language-text&quot;&gt;nixpkgs/348503b6345947082ff8be933dda7ebeddbb2762&lt;/code&gt; are unaffected.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In this blog post we saw how Nix flakes make NixOS configurations
hermetic and reproducible. In a future post, we’ll show how we can do
the same for cloud deployments using NixOps.&lt;/p&gt;
&lt;p&gt;Acknowledgment: The development of flakes was partially funded by
Target Corporation.&lt;/p&gt;</description>
	<pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Sander van der Burg: On using Nix and Docker as deployment automation solutions: similarities and differences</title>
	<guid isPermaLink="false">tag:blogger.com,1999:blog-1397115249631682228.post-1542344007221596374</guid>
	<link>http://sandervanderburg.blogspot.com/2020/07/on-using-nix-and-docker-as-deployment.html</link>
	<description>As frequent readers of my blog may probably already know, I have been using &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/01/nix-package-manager.html&quot;&gt;Nix-related&lt;/a&gt; tools for quite some time to solve many of my deployment automation problems.&lt;br /&gt;&lt;br /&gt;Although I have worked in environments in which Nix and its &lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/03/the-nixos-project-and-deploying-systems.html&quot;&gt;related sub projects&lt;/a&gt; are well-known, when I show some of Nix's use cases to larger groups of DevOps-minded people, a frequent answer I that have been hearing is that it looks very similar to &lt;a href=&quot;https://www.docker.com&quot;&gt;Docker&lt;/a&gt;. People also often ask me what advantages Nix has over Docker.&lt;br /&gt;&lt;br /&gt;So far, I have not even covered Docker once on my blog, despite its popularity, including very popular sister projects such as &lt;a href=&quot;https://docs.docker.com/compose&quot;&gt;docker-compose&lt;/a&gt; and &lt;a href=&quot;https://kubernetes.io&quot;&gt;Kubernetes&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;The main reason why I never wrote anything about Docker is not because I do not know about it or how to use it, but simply because I never had any notable use cases that would lead to something publishable -- most of my problems for which Docker could be a solution, I solved it by other means, typically by using a Nix-based solution somewhere in the solution stack.&lt;br /&gt;&lt;br /&gt;Docker is a container-based deployment solution, that was not the first (&lt;a href=&quot;https://blog.aquasec.com/a-brief-history-of-containers-from-1970s-chroot-to-docker-2016&quot;&gt;neither in the Linux world, nor in the UNIX-world in general&lt;/a&gt;), but since its introduction in 2013 it has grown very rapidly in popularity. I believe its popularity can be mainly attributed to its ease of usage and its extendable images ecosystem: &lt;a href=&quot;https://hub.docker.com&quot;&gt;Docker Hub&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;In fact, Docker (and Kubernetes, a container orchestration solution that incorporates Docker) have become so popular, that they have set a new standard when it comes to organizing systems and automating deployment -- today, in many environments, I have the feeling that it is no longer the question what kind of deployment solution is best for a particular system and organization, but rather: &quot;how do we get it into containers?&quot;.&lt;br /&gt;&lt;br /&gt;The same thing applies to the &quot;&lt;a href=&quot;https://martinfowler.com/articles/microservices.html&quot;&gt;microservices paradigm&lt;/a&gt;&quot; that should facilitate modular systems. If I compare the characteristics of microservices with the definition a &quot;software component&quot; by &lt;a href=&quot;https://dl.acm.org/doi/book/10.5555/515228&quot;&gt;Clemens Szyperski's Component Software book&lt;/a&gt;, then I would argue that they have more in common than they are different.&lt;br /&gt;&lt;br /&gt;One of the reasons why I think microservices are considered to be a success (or at least considered moderately more successful by some over older concepts, such as web services and software components) is because they easily map to a container, that can be conveniently managed with Docker. For some people, a microservice and a Docker container are pretty much the same things.&lt;br /&gt;&lt;br /&gt;Modular software systems have all kinds of advantages, but its biggest disadvantage is that the deployment of a system becomes more complicated as the amount of components and dependencies grow. With Docker containers this problem can be (somewhat) addressed in a convenient way.&lt;br /&gt;&lt;br /&gt;In this blog post, I will provide my view on Nix and Docker -- I will elaborate about some of their key concepts, explain in what ways they are different and similar, and I will show some use-cases in which both solutions can be combined to achieve interesting results.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Application domains&lt;/h2&gt;&lt;br /&gt;Nix and Docker are both deployment solutions for slightly different, but also somewhat overlapping, application domains.&lt;br /&gt;&lt;br /&gt;The Nix package manager (on the recently &lt;a href=&quot;https://nixos.org&quot;&gt;revised homepage&lt;/a&gt;) advertises itself as follows:&lt;br /&gt;&lt;br /&gt;&lt;blockquote&gt;Nix is a powerful package manager for Linux and other Unix systems that makes package management reliable and reproducible. Share your development and build environments across different machines. &lt;/blockquote&gt;&lt;br /&gt;whereas Docker advertises itself as follows (in the &lt;a href=&quot;https://docs.docker.com/get-started/overview/&quot;&gt;getting started guide&lt;/a&gt;):&lt;br /&gt;&lt;br /&gt;&lt;blockquote&gt;Docker is an open platform for developing, shipping, and running applications. &lt;/blockquote&gt;&lt;br /&gt;To summarize my interpretations of the descriptions:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Nix's chief responsibility is as its description implies: &lt;strong&gt;package management&lt;/strong&gt; and provides a collection of software tools that automates the process of installing, upgrading, configuring, and removing computer programs for a computer's operating system in a consistent manner.&lt;br /&gt;&lt;br /&gt;There are two properties that set Nix apart from most other package management solutions. First, Nix is also a &lt;strong&gt;source-based&lt;/strong&gt; package manager -- it can be used as a tool to construct packages from source code and their dependencies, by invoking build scripts in &quot;pure build environments&quot;.&lt;br /&gt;&lt;br /&gt;Moreover, &lt;a href=&quot;https://sandervanderburg.blogspot.com/2012/11/an-alternative-explaination-of-nix.html&quot;&gt;it borrows concepts from purely functional programming languages&lt;/a&gt; to make deployments reproducible, reliable and efficient.&lt;/li&gt;&lt;li&gt;Docker's chief responsibility is much broader than package management -- Docker facilitates full process/service &lt;strong&gt;life-cycle management&lt;/strong&gt;. Package management can be considered to be a sub problem of this domain, as I will explain later in this blog post.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Although both solutions map to slightly different domains, there is one prominent objective that both solutions have in common. They both facilitate &lt;strong&gt;reproducible deployment&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;With Nix the goal is that if you build a package from source code and a set of dependencies and perform the same build with the same inputs on a different machine, their build results should be (nearly) bit-identical.&lt;br /&gt;&lt;br /&gt;With Docker, the objective is to facilitate reproducible environments for running applications -- when running an application container on one machine that provides Docker, and running the same application container on another machine, they both should work in an identical way.&lt;br /&gt;&lt;br /&gt;Although both solutions facilitate reproducible deployments, their reproducibility properties are based on different kinds of concepts. I will explain more about them in the next sections.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Nix concepts&lt;/h2&gt;&lt;br /&gt;As explained earlier, Nix is a source-based package manager that borrows concepts from purely functional programming languages. Packages are built from build recipes called Nix expressions, such as:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;with import &amp;lt;nixpkgs&amp;gt; {};&lt;br /&gt;&lt;br /&gt;stdenv.mkDerivation {&lt;br /&gt;  name = &quot;file-5.38&quot;;&lt;br /&gt;&lt;br /&gt;  src = fetchurl {&lt;br /&gt;    url = &quot;ftp://ftp.astron.com/pub/file/file-5.38.tar.gz&quot;;&lt;br /&gt;    sha256 = &quot;0d7s376b4xqymnrsjxi3nsv3f5v89pzfspzml2pcajdk5by2yg2r&quot;;&lt;br /&gt;  };&lt;br /&gt;&lt;br /&gt;  buildInputs = [ zlib ];&lt;br /&gt;&lt;br /&gt;  meta = {&lt;br /&gt;    homepage = https://darwinsys.com/file;&lt;br /&gt;    description = &quot;A program that shows the type of files&quot;;&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression invokes the function: &lt;i&gt;stdenv.mkDerivation&lt;/i&gt; that creates a build environment in which we build the package: &lt;a href=&quot;https://www.darwinsys.com/file&quot;&gt;&lt;i&gt;file&lt;/i&gt;&lt;/a&gt; from source code:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;The &lt;i&gt;name&lt;/i&gt; parameter provides the package name.&lt;/li&gt;&lt;li&gt;The &lt;i&gt;src&lt;/i&gt; parameter invokes the &lt;i&gt;fetchurl&lt;/i&gt; function that specifies where to download the source tarball from.&lt;/li&gt;&lt;li&gt;&lt;i&gt;buildInputs&lt;/i&gt; refers to the build-time dependencies that the package needs. The file package only uses one dependency: &lt;a href=&quot;https://zlib.net&quot;&gt;&lt;i&gt;zlib&lt;/i&gt;&lt;/a&gt; that provides deflate compression support.&lt;br /&gt;&lt;br /&gt;The &lt;i&gt;buildInputs&lt;/i&gt; parameter is used to automatically configure the build environment in such a way that &lt;i&gt;zlib&lt;/i&gt; can be found as a library dependency by the build script.&lt;/li&gt;&lt;li&gt;The &lt;i&gt;meta&lt;/i&gt; parameter specifies the package's meta data. Meta data is used by Nix to provide information about the package, but it is not used by the build script.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The Nix expression does not specify any build instructions -- if no build instructions were provided, the &lt;i&gt;stdenv.mkDerivation&lt;/i&gt; function will execute the standard &lt;a href=&quot;https://www.sourceware.org/autobook&quot;&gt;GNU Autotools&lt;/a&gt; build procedure: &lt;i&gt;./configure; make; make install&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;Nix combines several concepts to make builds more reliable and reproducible.&lt;br /&gt;&lt;br /&gt;Foremost, packages managed by Nix are stored in a so-called &lt;strong&gt;Nix store&lt;/strong&gt; (&lt;i&gt;/nix/store&lt;/i&gt;) in which every package build resides in its own directory.&lt;br /&gt;&lt;br /&gt;When we build the above Nix expression with the following command:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nix-build file.nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;then we may get the following Nix store path as output:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;/nix/store/6rcg0zgqyn2v1ypd46hlvngaf5lgqk9g-file-5.38&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Each entry in the Nix store has a SHA256 hash prefix (e.g. &lt;i&gt;ypag3bh7y7i15xf24zihr343wi6x5i6g&lt;/i&gt;) that is derived from all &lt;strong&gt;build inputs&lt;/strong&gt; used to build a package.&lt;br /&gt;&lt;br /&gt;If we would build &lt;i&gt;file&lt;/i&gt;, for example, with a different build script or different version of &lt;i&gt;zlib&lt;/i&gt; then the resulting Nix store prefix will be different. As a result, we can safely store multiple versions and variants of the same package next to each other, because they will never share the same name.&lt;br /&gt;&lt;br /&gt;Because each package resides in its own directory in the Nix store, rather than global directories that are commonly used on conventional Linux systems, such as &lt;i&gt;/bin&lt;/i&gt; and &lt;i&gt;/lib&lt;/i&gt;, we get stricter &lt;strong&gt;purity&lt;/strong&gt; guarantees -- dependencies can typically not be found if they have not been specified in any of the search environment variables (e.g. &lt;i&gt;PATH&lt;/i&gt;) or provided as build parameters.&lt;br /&gt;&lt;br /&gt;In conventional Linux systems, package builds might still accidentally succeed if they unknowingly use an undeclared dependency. When deploying such a package to another system that does not have this undeclared dependency installed, the package might not work properly or not all.&lt;br /&gt;&lt;br /&gt;In simple single-user Nix installations, builds typically get executed in an environment in which most environment variables (including search path environment variables, such as &lt;i&gt;PATH&lt;/i&gt;) are &lt;strong&gt;cleared&lt;/strong&gt; or set to dummy variables.&lt;br /&gt;&lt;br /&gt;Build abstraction functions (such as &lt;i&gt;stdenv.mkDerivation&lt;/i&gt;) will populate the search path environment variables (e.g. &lt;i&gt;PATH&lt;/i&gt;, &lt;i&gt;CLASSPATH&lt;/i&gt;, &lt;i&gt;PYTHONPATH&lt;/i&gt; etc.) and configure build parameters to ensure that the dependencies in the Nix store can be found.&lt;br /&gt;&lt;br /&gt;Builds are only allowed to write in the build directory or designated output folders in the Nix store.&lt;br /&gt;&lt;br /&gt;When a build has completed successfully, their results are made immutable (by removing their write permission bits in the Nix store) and their timestamps are reset to 1 second after the &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;epoch&lt;/a&gt; (to improve build determinism).&lt;br /&gt;&lt;br /&gt;Storing packages in isolation and providing an environment with cleared environment variables is obviously not a guarantee that builds will be pure. For example, build scripts may still have hard-coded absolute paths to executables on the host system, such as &lt;i&gt;/bin/install&lt;/i&gt; and a C compiler may still implicitly search for headers in &lt;i&gt;/usr/include&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;To alleviate the problem with hard-coded global directory references, some common build utilities, such as GCC, deployed by Nix have been patched to ignore global directories, such as &lt;i&gt;/usr/include&lt;/i&gt;.&lt;br /&gt;&lt;br /&gt;When using &lt;a href=&quot;https://sandervanderburg.blogspot.com/2013/06/setting-up-multi-user-nix-installation.html&quot;&gt;Nix in multi-user mode&lt;/a&gt;, extra precautions have been taken to ensure build purity:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Each build will run as an &lt;strong&gt;unprivileged&lt;/strong&gt; user, that do not have any write access to any directory but its own build directory and the designated output Nix store paths.&lt;/li&gt;&lt;li&gt;On Linux, optionally a build can run in a &lt;a href=&quot;https://en.wikipedia.org/wiki/Chroot&quot;&gt;&lt;strong&gt;chroot&lt;/strong&gt;&lt;/a&gt; environment, that completely disables access to all global directories in the build process. In addition, all Nix store paths of all dependencies will be &lt;strong&gt;bind mounted&lt;/strong&gt;, preventing the build process to still access undeclared dependencies in the Nix store (changes will be slim that you encounter such a build, but still...)&lt;/li&gt;&lt;li&gt;On Linux kernels that support &lt;a href=&quot;https://man7.org/linux/man-pages/man7/namespaces.7.html&quot;&gt;&lt;strong&gt;namespaces&lt;/strong&gt;&lt;/a&gt;, the Nix build environment will use them to improve build purity.&lt;br /&gt;&lt;br /&gt;The network namespace helps the Nix builder to prevent a build process from accessing the network -- when a build process downloads an undeclared dependency from a remote location, we cannot be sure that we get a predictable result.&lt;br /&gt;&lt;br /&gt;In Nix, only builds that are so-called &lt;strong&gt;fixed output derivations&lt;/strong&gt; (whose output hashes need to be known in advance) are allowed to download files from remote locations, because their output results can be verified.&lt;br /&gt;&lt;br /&gt;(As a sidenote: namespaces are also intensively used by Docker containers, as I will explain in the next section.)&lt;/li&gt;&lt;li&gt;On macOS, builds can optionally be executed in an &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Security/Conceptual/AppSandboxDesignGuide/AboutAppSandbox/AboutAppSandbox.html&quot;&gt;&lt;strong&gt;app sandbox&lt;/strong&gt;&lt;/a&gt;, that can also be used to restrict access to various kinds of shared resources, such as network access.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Besides isolation, using hash code prefixes have another advantage. Because every build with the same hash code is (nearly) bit identical, it also provides a nice optimization feature.&lt;br /&gt;&lt;br /&gt;When we evaluate a Nix expression and the resulting hash code is identical to a valid Nix store path, then we do not have to build the package again -- because it is bit identical, we can simply return the Nix store path of the package that is already in the Nix store.&lt;br /&gt;&lt;br /&gt;This property is also used by Nix to facilitate transparent &lt;strong&gt;binary package deployments&lt;/strong&gt;. If we want to build a package with a certain hash prefix, and we know that another machine or binary cache already has this package in its Nix store, then we can download a binary &lt;strong&gt;substitute&lt;/strong&gt;.&lt;br /&gt;  &lt;br /&gt;Another interesting benefit of using hash codes is that we can also identify the &lt;strong&gt;runtime dependencies&lt;/strong&gt; that a package needs -- if a Nix store path contains references to other Nix store paths, then we know that these are runtime dependencies of the corresponding package.&lt;br /&gt;&lt;br /&gt;Scanning for Nix store paths may sound scary, but there is a very slim change that a hash code string represents something else. In practice, it works really well.&lt;br /&gt;&lt;br /&gt;For example, the following shell command shows all the runtime dependencies of the &lt;i&gt;file&lt;/i&gt; package:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nix-store -qR /nix/store/6rcg0zgqyn2v1ypd46hlvngaf5lgqk9g-file-5.38&lt;br /&gt;/nix/store/y8n2b9nwjrgfx3kvi3vywvfib2cw5xa6-libunistring-0.9.10&lt;br /&gt;/nix/store/fhg84pzckx2igmcsvg92x1wpvl1dmybf-libidn2-2.3.0&lt;br /&gt;/nix/store/bqbg6hb2jsl3kvf6jgmgfdqy06fpjrrn-glibc-2.30&lt;br /&gt;/nix/store/5x6l9xm5dp6v113dpfv673qvhwjyb7p5-zlib-1.2.11&lt;br /&gt;/nix/store/6rcg0zgqyn2v1ypd46hlvngaf5lgqk9g-file-5.38&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;If we query the dependencies of another package that is built from the same Nix packages set, such as &lt;i&gt;cpio&lt;/i&gt;:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ nix-store -qR /nix/store/bzm0mszhvbr6hp4gmar4czsn52hz07q1-cpio-2.13&lt;br /&gt;/nix/store/y8n2b9nwjrgfx3kvi3vywvfib2cw5xa6-libunistring-0.9.10&lt;br /&gt;/nix/store/fhg84pzckx2igmcsvg92x1wpvl1dmybf-libidn2-2.3.0&lt;br /&gt;/nix/store/bqbg6hb2jsl3kvf6jgmgfdqy06fpjrrn-glibc-2.30&lt;br /&gt;/nix/store/bzm0mszhvbr6hp4gmar4czsn52hz07q1-cpio-2.13&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;When looking at the outputs above, you may probably notice that both &lt;i&gt;bash&lt;/i&gt; and &lt;i&gt;cpio&lt;/i&gt; share the same kinds of dependencies (e.g. &lt;i&gt;libidn2&lt;/i&gt;, &lt;i&gt;libunisting&lt;/i&gt; and &lt;i&gt;glibc&lt;/i&gt;), with the same hash code prefixes. Because they are same Nix store paths, they are shared on disk (and in RAM, because the operating system caches the same files in memory) leading to more efficient disk and RAM usage.&lt;br /&gt;&lt;br /&gt;The fact that we can detect references to Nix store paths is because packages in the Nix package repository use an unorthodox form of &lt;strong&gt;static linking&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;For example, ELF executables built with Nix have the store paths of their library dependencies in their &lt;i&gt;RPATH&lt;/i&gt; header values (the &lt;i&gt;ld&lt;/i&gt; command in Nixpkgs has been wrapped to transparently augment libraries to a binary's RPATH).&lt;br /&gt;&lt;br /&gt;Python programs (and other programs written in interpreted languages) typically use wrapper scripts that set the &lt;i&gt;PYTHONPATH&lt;/i&gt; (or equivalent) environment variables to contain Nix store paths providing the dependencies.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Docker concepts&lt;/h2&gt;&lt;br /&gt;The &lt;a href=&quot;https://docs.docker.com/get-started/overview&quot;&gt;Docker overview page&lt;/a&gt; states the following about what Docker can do:&lt;br /&gt;&lt;br /&gt;&lt;blockquote&gt;When you use Docker, you are creating and using images, containers, networks, volumes, plugins, and other objects. &lt;/blockquote&gt;&lt;br /&gt;Although you can create many kinds of objects with Docker, the two most important objects are the following:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Images&lt;/strong&gt;. The overview page states: &quot;An image is a read-only template with instructions for creating a Docker container.&quot;.&lt;br /&gt;&lt;br /&gt;To more accurately describe what this means is that images are created from build recipes called &lt;a href=&quot;https://docs.docker.com/engine/reference/builder&quot;&gt;&lt;i&gt;Dockerfile&lt;/i&gt;s&lt;/a&gt;. They produce self-contained root file systems containing all necessary files to run a program, such as binaries, libraries, configuration files etc. The resulting image itself is immutable (read only) and cannot change after it has been built.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Containers&lt;/strong&gt;. The overview gives the following description: &quot;A container is a runnable instance of an image&quot;.&lt;br /&gt;&lt;br /&gt;More specifically, this means that the life-cycle (whether a container is in a started or stopped state) is bound to the life-cycle of a root process, that runs in a (somewhat) isolated environment using the content of a Docker image as its root file system.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Besides the object types explained above, there are many more kinds objects, such as volumes (that can mount a directory from the host file system to a path in the container), and port forwardings from the host system to a container. For more information about these remaining objects, consult the Docker documentation.&lt;br /&gt;&lt;br /&gt;Docker combines several concepts to facilitate reproducible and reliable container deployment. To be able to isolate containers from each other, it uses several kinds of Linux namespaces:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;The mount namespace: This is in IMO the most important name space. After setting up a private mount namespace, every subsequent mount that we make will be visible in the container, but not to other containers/processes that are in a different mount name space.&lt;br /&gt;&lt;br /&gt;A private mount namespace is used to mount a new root file system (the contents of the Docker image) with all essential system software and other artifacts to run an application, that is different from the host system's root file system.&lt;/li&gt;&lt;li&gt;The Process ID (PID) namespace facilitates process isolation. A process/container with a private PID namespace will not be able to see or control the host system's processes (the opposite is actually possible).&lt;/li&gt;&lt;li&gt;The network namespace separates network interfaces from the host system. In a private network namespace, a container has one or more private network interfaces with their own IP addresses, port assignments and firewall settings.&lt;br /&gt;&lt;br /&gt;As a result, a service such as the Apache HTTP server in a Docker container can bind to port 80 without conflicting with another HTTP server that binds to the same port on the host system or in another container instance.&lt;/li&gt;&lt;li&gt;The Inter-Process Communication (IPC) namespace separates the ability for processes to communicate with each other via the SHM family of functions to establish a range of shared memory between the two processes.&lt;/li&gt;&lt;li&gt;The UTS namespace isolates kernel and version identifiers.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Another important concept that containers use are &lt;a href=&quot;https://man7.org/linux/man-pages/man7/cgroups.7.html&quot;&gt;&lt;strong&gt;cgroups&lt;/strong&gt;&lt;/a&gt; that can be use to limit the amount of system resources that containers can use, such as the amount of RAM.&lt;br /&gt;&lt;br /&gt;Finally, to optimize/reduce storage overhead, Docker uses layers and a union filesystem (there are a variety of file system options for this) to combine these layers by &quot;stacking&quot; them on top of each other.&lt;br /&gt;&lt;br /&gt;A running container basically mounts an image's read-only layers on top of each other, and keeps the final layer writable so that processes in the container can create and modify files on the system.&lt;br /&gt;&lt;br /&gt;Whenever you construct an image from a &lt;i&gt;Dockerfile&lt;/i&gt;, each modification operation generates a new layer. Each layer is immutable (it will never change after it has been created) and is uniquely identifiable with a hash code, similar to Nix store paths.&lt;br /&gt;&lt;br /&gt;For example, we can build an image with the following &lt;i&gt;Dockerfile&lt;/i&gt; that deploys and runs the Apache HTTP server on a &lt;a href=&quot;https://debian.org&quot;&gt;Debian&lt;/a&gt; Buster Linux distribution:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;FROM debian:buster&lt;br /&gt;&lt;br /&gt;RUN apt-get update&lt;br /&gt;RUN apt-get install -y apache2&lt;br /&gt;ADD index.html /var/www/html&lt;br /&gt;CMD [&quot;apachectl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]&lt;br /&gt;EXPOSE 80/tcp&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above &lt;i&gt;Dockerfile&lt;/i&gt; executes the following steps:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;It takes the &lt;i&gt;debian:buster&lt;/i&gt; image from Docker Hub as a base image.&lt;/li&gt;&lt;li&gt;It updates the Debian package database (&lt;i&gt;apt-get update&lt;/i&gt;) and installs the Apache HTTPD server package from the Debian package repository.&lt;/li&gt;&lt;li&gt;It uploads an example page (&lt;i&gt;index.html&lt;/i&gt;) to the document root folder.&lt;/li&gt;&lt;li&gt;It executes the: &lt;i&gt;apachectl -D FOREGROUND&lt;/i&gt; command-line instruction to start the Apache HTTP server in foreground mode. The container's life-cycle is bound to the life-cycle of this foreground process.&lt;/li&gt;&lt;li&gt;It informs Docker that the container listens to TCP port: 80. Connecting to port 80 makes it possible for a user to retrieve the example &lt;i&gt;index.html&lt;/i&gt; page.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;With the following command we can build the image:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker build . -t debian-apache&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Resulting in the following layers:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto; font-size: 90%;&quot;&gt;&lt;br /&gt;$ docker history debian-nginx:latest&lt;br /&gt;IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT&lt;br /&gt;a72c04bd48d6        About an hour ago   /bin/sh -c #(nop)  EXPOSE 80/tcp                0B                  &lt;br /&gt;325875da0f6d        About an hour ago   /bin/sh -c #(nop)  CMD [&quot;apachectl&quot; &quot;-D&quot; &quot;FO…   0B                  &lt;br /&gt;35d9a1dca334        About an hour ago   /bin/sh -c #(nop) ADD file:18aed37573327bee1…   129B                &lt;br /&gt;59ee7771f1bc        About an hour ago   /bin/sh -c apt-get install -y apache2           112MB               &lt;br /&gt;c355fe9a587f        2 hours ago         /bin/sh -c apt-get update                       17.4MB              &lt;br /&gt;ae8514941ea4        33 hours ago        /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B                  &lt;br /&gt;&amp;lt;missing&amp;gt;           33 hours ago        /bin/sh -c #(nop) ADD file:89dfd7d3ed77fd5e0…   114MB&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As may be observed, the base Debian Buster image and every change made in the &lt;i&gt;Dockerfile&lt;/i&gt; results in a new layer with a new hash code, as shown in the &lt;i&gt;IMAGE&lt;/i&gt; column.&lt;br /&gt;&lt;br /&gt;Layers and Nix store paths share the similarity that they are immutable and they can both be identified with hash codes.&lt;br /&gt;&lt;br /&gt;They are also different -- first, a Nix store path is the result of building a package or a static artifact, whereas a layer is the result of making a filesystem modification. Second, for a Nix store path, the hash code is derived from all inputs, whereas the hash code of a layer is derived from the output: its contents.&lt;br /&gt;&lt;br /&gt;Furthermore, Nix store paths are always isolated because they reside in a unique directory (enforced by the hash prefixes), whereas a layer might have files that overlap with files in other layers. In Docker, when a conflict is encountered the files in the layer that gets added on top of it take precedence.&lt;br /&gt;&lt;br /&gt;We can construct a second image using the same Debian Linux distribution image that runs Nginx with the following &lt;i&gt;Dockerfile&lt;/i&gt;:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;FROM debian:buster&lt;br /&gt;&lt;br /&gt;RUN apt-get update&lt;br /&gt;RUN apt-get install -y nginx&lt;br /&gt;ADD nginx.conf /etc&lt;br /&gt;ADD index.html /var/www&lt;br /&gt;CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;, &quot;-c&quot;, &quot;/etc/nginx.conf&quot;]&lt;br /&gt;EXPOSE 80/tcp&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above &lt;i&gt;Dockerfile&lt;/i&gt; looks similar to the previous, except that we install the Nginx package from the Debian package repository and we use a different command-line instruction to start Nginx in foreground mode.&lt;br /&gt;&lt;br /&gt;When building the image, its storage will be optimized -- both images share the same base layer (the Debian Buster Linux base distribution):&lt;br /&gt;  &lt;br /&gt;&lt;pre style=&quot;overflow: auto; font-size: 90%;&quot;&gt;&lt;br /&gt;$ docker history debian-nginx:latest&lt;br /&gt;IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT&lt;br /&gt;b7ae6f38ae77        2 hours ago         /bin/sh -c #(nop)  EXPOSE 80/tcp                0B                  &lt;br /&gt;17027888ce23        2 hours ago         /bin/sh -c #(nop)  CMD [&quot;nginx&quot; &quot;-g&quot; &quot;daemon…   0B                  &lt;br /&gt;41a50a3fa73c        2 hours ago         /bin/sh -c #(nop) ADD file:18aed37573327bee1…   129B                &lt;br /&gt;0f5b2fdcb207        2 hours ago         /bin/sh -c #(nop) ADD file:f18afd18cfe2728b3…   189B                &lt;br /&gt;e49bbb46138b        2 hours ago         /bin/sh -c apt-get install -y nginx             64.2MB              &lt;br /&gt;c355fe9a587f        2 hours ago         /bin/sh -c apt-get update                       17.4MB              &lt;br /&gt;ae8514941ea4        33 hours ago        /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B                  &lt;br /&gt;&amp;lt;missing&amp;gt;           33 hours ago        /bin/sh -c #(nop) ADD file:89dfd7d3ed77fd5e0…   114MB&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;If you compare the above output with the previous &lt;i&gt;docker history&lt;/i&gt; output, then you will notice that the bottom layer (last row) refers to the same layer using the same hash code behind the &lt;i&gt;ADD file:&lt;/i&gt; statement in the &lt;i&gt;CREATED BY&lt;/i&gt; column.&lt;br /&gt;&lt;br /&gt;This ability to share the base distribution prevents us from storing another 114MB Debian Buster image, saving us storage and RAM.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Some common misconceptions&lt;/h2&gt;&lt;br /&gt;What I have noticed is that quite a few people compare containers to virtual machines (and even give containers that name, incorrectly suggesting that they are the same thing!).&lt;br /&gt;&lt;br /&gt;A container is not a virtual machine, because it does not emulate or virtualize hardware -- virtual machines have a virtual CPU, virtual memory, virtual disk etc. that have similar capabilities and limitations as real hardware.&lt;br /&gt;&lt;br /&gt;Furthermore, containers do not run a full operating system -- they run processes managed by the host system's Linux kernel. As a result, Docker containers will only deploy software that runs on Linux, and not software that was built for other operating systems.&lt;br /&gt;&lt;br /&gt;(As a sidenote: Docker can also be used on Windows and macOS -- on these non-Linux platforms, &lt;a href=&quot;https://docs.docker.com/docker-for-windows/troubleshoot/#virtualization&quot;&gt;a virtualized Linux system&lt;/a&gt; is used for hosting the containers, but the containers themselves are not separated by using virtualization).&lt;br /&gt;&lt;br /&gt;Containers cannot even be considered &quot;light weight virtual machines&quot;.&lt;br /&gt;&lt;br /&gt;The means to isolate containers from each other only apply to a limited number of potentially shared resources. For example, a resource that could not be unshared is the system's clock, although this may change in the near future, because in March 2020 a &lt;a href=&quot;https://lore.kernel.org/lkml/158016896588.31887.14143226032971732742.tglx@nanos.tec.linutronix.de/&quot;&gt;time namespace has been added&lt;/a&gt; to the newest Linux kernel version. I believe this namespace is not yet offered as a generally available feature in Docker.&lt;br /&gt;&lt;br /&gt;Moreover, namespaces, that normally provide separation/isolation between containers, &lt;a href=&quot;https://blog.jessfraz.com/post/containers-zones-jails-vms/&quot;&gt;are objects&lt;/a&gt; and these objects can also be shared among multiple container instances (this is a uncommon use-case, because by default every container has its own private namespaces).&lt;br /&gt;&lt;br /&gt;For example, it is also possible for two containers to share the same IPC namespace -- then processes in both containers will be able to communicate with each other with a shared-memory IPC mechanism, but they cannot do any IPC with processes on the host system or containers not sharing the same namespace.&lt;br /&gt;&lt;br /&gt;Finally, certain system resources are not constrained by default unlike a virtual machine -- for example, a container is allowed to consume all the RAM of the host machine unless a RAM restriction has been configured. An unrestricted container could potentially affect the machine's stability as a whole and other containers running on the same machine.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;A comparison of use cases&lt;/h2&gt;&lt;br /&gt;As mentioned in the introduction, when I show people Nix, then I often get a remark that it looks very similar to Docker.&lt;br /&gt;&lt;br /&gt;In this section, I will compare some of their common use cases.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Managing services&lt;/h3&gt;&lt;br /&gt;In addition to building a Docker image, I believe the most common use case for Docker is to &lt;strong&gt;manage services&lt;/strong&gt;, such as custom REST API services (that are self-contained processes with an embedded web server), web servers or database management systems.&lt;br /&gt;&lt;br /&gt;For example, after building an Nginx Docker image (as shown in the section about Docker concepts), we can also launch a container instance using the previously constructed image to serve our example HTML page:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run -p 8080:80 --name nginx-container -it debian-nginx&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above command create a new container instance using our Nginx image as a root file system and then starts the container in interactive mode -- the command's execution will block and display the output of the Nginx process on the terminal.&lt;br /&gt;&lt;br /&gt;If we would omit the &lt;i&gt;-it&lt;/i&gt; parameters then the container will run in the background.&lt;br /&gt;&lt;br /&gt;The &lt;i&gt;-p&lt;/i&gt; parameter configures a port forwarding from the host system to the container: traffic to the host system's port 8080 gets forwarded to port 80 in the container where the Nginx server listens to.&lt;br /&gt;&lt;br /&gt;We should be able to see the example HTML page, by opening the following URL in a web browser:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;http://localhost:8080&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;After stopping the container, its state will be retained. We can remove the container permanently, by running:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker rm nginx-container&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The Nix package manager has no equivalent use case for manging running processes, because its purpose is package management and not process/service life-cycle management.&lt;br /&gt;&lt;br /&gt;However, some projects based on Nix, such as &lt;a href=&quot;https://sandervanderburg.blogspot.com/2011/01/nixos-purely-functional-linux.html&quot;&gt;NixOS&lt;/a&gt;: a Linux distribution built around the Nix package manager using a single declarative configuration file to capture a machine's configuration, generates &lt;a href=&quot;https://www.freedesktop.org/wiki/Software/systemd&quot;&gt;&lt;i&gt;systemd&lt;/i&gt;&lt;/a&gt; unit files to manage services' life-cycles.&lt;br /&gt;&lt;br /&gt;The Nix package manager can also be used on other operating systems, such as conventional Linux distributions, macOS and other UNIX-like systems. There is no universal solution that allows you to complement Nix with service manage support on all platforms that Nix supports.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Experimenting with packages&lt;/h3&gt;&lt;br /&gt;Another common use case is using Docker to experiment with packages that should not remain permanently installed on a system.&lt;br /&gt;&lt;br /&gt;One way of doing this is by directly pulling a Linux distribution image (such as Debian Buster):&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker pull debian:buster&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and then starting a container in an interactive shell session, in which we install the packages that we want to experiment with:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run --name myexperiment -it debian:buster /bin/sh&lt;br /&gt;$ apt-get update&lt;br /&gt;$ apt-get install -y file&lt;br /&gt;# file --version&lt;br /&gt;file-5.22&lt;br /&gt;magic file from /etc/magic:/usr/share/misc/magic&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above example suffices to experiment with the &lt;i&gt;file&lt;/i&gt; package, but its deployment is not guaranteed to be reproducible.&lt;br /&gt;&lt;br /&gt;For example, the result of running my &lt;i&gt;apt-get&lt;/i&gt; instructions shown above is file version 5.22. If I would, for example, run the same instructions a week later, then I might get a different version (e.g. 5.23).&lt;br /&gt;&lt;br /&gt;The Docker-way of making such a deployment scenario reproducible, is by installing the packages in a &lt;i&gt;Dockerfile&lt;/i&gt; as part of the container's image construction process:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;FROM debian:buster&lt;br /&gt;&lt;br /&gt;RUN apt-get update&lt;br /&gt;RUN apt-get install -y file&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;we can build the container image, with our &lt;i&gt;file&lt;/i&gt; package as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker build . -t file-experiment&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and then deploy a container that uses that image:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run --name myexperiment -it debian:buster /bin/sh&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As long as we deploy a container with the same image, we will always have the same version of the &lt;i&gt;file&lt;/i&gt; executable:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run --name myexperiment -it file-experiment /bin/sh&lt;br /&gt;# file --version&lt;br /&gt;file-5.22&lt;br /&gt;magic file from /etc/magic:/usr/share/misc/magic&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;With Nix, &lt;a href=&quot;https://sandervanderburg.blogspot.com/2013/12/using-nix-while-doing-development.html&quot;&gt;generating reproducible development environments with packages&lt;/a&gt; is a first-class feature.&lt;br /&gt;&lt;br /&gt;For example, to launch a shell session providing the &lt;i&gt;file&lt;/i&gt; package from the Nixpkgs collection, we can simply run:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto;&quot;&gt;&lt;br /&gt;$ nix-shell -p file&lt;br /&gt;$ file --version&lt;br /&gt;file-5.39&lt;br /&gt;magic file from /nix/store/j4jj3slm15940mpmympb0z99a2ghg49q-file-5.39/share/misc/magic&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As long as the Nix expression sources remain the same (e.g. the Nix channel is not updated, or &lt;i&gt;NIX_PATH&lt;/i&gt; is hardwired to a certain Git revision of Nixpkgs), the deployment of the development environment is reproducible -- we should always get the same &lt;i&gt;file&lt;/i&gt; package with the same Nix store path.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Building development projects/arbitrary packages&lt;/h2&gt;&lt;br /&gt;As shown in the section about Nix's concepts, one of Nix's key features is to generate build environments for building packages and other software projects. I have shown that with a simple Nix expression consisting of only a few lines of code, we can build the &lt;i&gt;file&lt;/i&gt; package from source code and its build dependencies in such a dedicated build environment.&lt;br /&gt;&lt;br /&gt;In Docker, only building images is a first-class concept. However, building arbitrary software projects and packages is also something you can do by using Docker containers in a specific way.&lt;br /&gt;&lt;br /&gt;For example, we can create a bash script that builds the same example package (&lt;i&gt;file&lt;/i&gt;) shown in the section that explains Nix's concepts:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;#!/bin/bash -e&lt;br /&gt;&lt;br /&gt;mkdir -p /build&lt;br /&gt;cd /build&lt;br /&gt;&lt;br /&gt;wget ftp://ftp.astron.com/pub/file/file-5.38.tar.gz&lt;br /&gt;&lt;br /&gt;tar xfv file-5.38.tar.gz&lt;br /&gt;cd file-5.38&lt;br /&gt;./configure --prefix=/opt/file&lt;br /&gt;make&lt;br /&gt;make install&lt;br /&gt;&lt;br /&gt;tar cfvz /out/file-5.38-binaries.tar.gz /opt/file&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Compared to its Nix expression counterpart, the build script above does not use any abstractions -- as a consequence, we have to explicitly write all steps that executes the required build steps to build the package:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;Create a dedicated build directory.&lt;/li&gt;&lt;li&gt;Download the source tarball from the FTP server&lt;/li&gt;&lt;li&gt;Unpack the tarball&lt;/li&gt;&lt;li&gt;Execute the standard GNU Autotools build procedure: &lt;i&gt;./configure; make; make install&lt;/i&gt; and install the binaries in an isolated folder (&lt;i&gt;/opt/file&lt;/i&gt;).&lt;/li&gt;&lt;li&gt;Create a binary tarball from the &lt;i&gt;/opt/file&lt;/i&gt; folder and store it in the &lt;i&gt;/out&lt;/i&gt; directory (that is a volume shared between the container and the host system).&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;To create a container that runs the build script and to provide its dependencies in a reproducible way, we need to construct an image from the following &lt;i&gt;Dockerfile&lt;/i&gt;:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;FROM debian:buster&lt;br /&gt;&lt;br /&gt;RUN apt-get update&lt;br /&gt;RUN apt-get install -y wget gcc make libz-dev&lt;br /&gt;ADD ./build.sh /&lt;br /&gt;CMD /build.sh&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Dockerfile builds an image using the Debian Buster Linux distribution, installs all mandatory build utilities (&lt;i&gt;wget&lt;/i&gt;, &lt;i&gt;gcc&lt;/i&gt;, and &lt;i&gt;make&lt;/i&gt;) and library dependencies (&lt;i&gt;libz-dev&lt;/i&gt;), and executes the build script shown above.&lt;br /&gt;&lt;br /&gt;With the following command, we can build the image:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker build . -t buildenv&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and with the following command, we can create and launch the container that executes the build script (and automatically discard it as soon as it finishes its task):&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run -v $(pwd)/out:/out --rm -t buildenv&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;To make sure that we can keep our resulting binary tarball after the container gets discarded, we have created a shared volume that maps the &lt;i&gt;out&lt;/i&gt; directory in our current working directory onto the &lt;i&gt;/out&lt;/i&gt; directory in the container.&lt;br /&gt;&lt;br /&gt;When the build script finishes, the output directory should contain our generated binary tarball:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;ls out/&lt;br /&gt;file-5.38-binaries.tar.gz&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Although both Nix and Docker both can provide reproducible environments for building packages (in the case of Docker, we need to make sure that all dependencies are provided by the Docker image), builds performed in a Docker container are not guaranteed to be pure, because it does not take the same precautions that Nix takes:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;In the build script, we download the source tarball without checking its integrity. This might cause an impurity, because the tarball on the remote server could change (this could happen for non-mallicious as well as mallicous reasons).&lt;/li&gt;&lt;li&gt;While running the build, we have unrestricted network access. The build script might unknowingly download all kinds of undeclared/unknown dependencies from external sites whose results are not deterministic.&lt;/li&gt;&lt;li&gt;We do not reset any timestamps -- as a result, when performing the same build twice in a row, the second result might be slightly different because of the timestamps integrated in the build product.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Coping with these impurities in a Docker workflow is the responsibility of the build script implementer. With Nix, most of it is transparently handled for you.&lt;br /&gt;&lt;br /&gt;Moreover, the build script implementer is also responsible to retrieve the build artifact and store it somewhere, e.g. in a directory outside the container or uploading it to a remote artifactory repository.&lt;br /&gt;&lt;br /&gt;In Nix, the result of a build process is automatically stored in isolation in the Nix store. We can also quite easily turn a Nix store into a binary cache and let other Nix consumers download from it, e.g. by installing &lt;a href=&quot;https://github.com/edolstra/nix-serve&quot;&gt;&lt;i&gt;nix-serve&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;https://sandervanderburg.blogspot.com/2013/04/setting-up-hydra-build-cluster-for.html&quot;&gt;Hydra: the Nix-based continuous integration service&lt;/a&gt;, &lt;a href=&quot;https://cachix.org/&quot;&gt;cachix&lt;/a&gt;, or by &lt;a href=&quot;https://sandervanderburg.blogspot.com/2016/10/push-and-pull-deployment-of-nix-packages.html&quot;&gt;manually generating a static binary cache&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;Beyond the ability to execute builds, Nix has another great advantage for building packages from source code. On Linux systems, the Nixpkgs collection is entirely &lt;strong&gt;bootstrapped&lt;/strong&gt;, except for the bootstrap binaries -- this provides us almost full traceability of all dependencies and transitive dependencies used at build-time.&lt;br /&gt;&lt;br /&gt;With Docker you typically do not have such insights -- images get constructed from binaries obtained from arbitrary locations (e.g. binary packages that originate from Linux distributions' package repositories). As a result, it is impossible to get any insights on how these package dependencies were constructed from source code.&lt;br /&gt;&lt;br /&gt;For most people, knowing exactly from which sources a package has been built is not considered important, but it can still be useful for more specialized use cases. For example, to determine if your system is constructed from trustable/audited sources and &lt;a href=&quot;https://sandervanderburg.blogspot.com/2012/04/dynamic-analysis-of-build-processes-to.html&quot;&gt;whether you did not violate a license of a third-party library&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Combined use cases&lt;/h2&gt;&lt;br /&gt;As explained earlier in this blog post, Nix and Docker are deployment solutions for sightly different application domains.&lt;br /&gt;&lt;br /&gt;There are quite a few solutions developed by the Nix community that can combine Nix and Docker in interesting ways.&lt;br /&gt;&lt;br /&gt;In this section, I will show some of them.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Experimenting with the Nix package manager in a Docker container&lt;/h3&gt;&lt;br /&gt;Since Docker is such a common solution to provide environments in which users can experiment with packages, the Nix community also provides a &lt;a href=&quot;https://hub.docker.com/r/nixos/nix&quot;&gt;Nix Docker image&lt;/a&gt;, that allows you to conveniently experiment with the Nix package manager in a Docker container.&lt;br /&gt;&lt;br /&gt;We can pull this image as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker pull nixos/nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Then launch a container interactively:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run -it nixos/nix&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;And finally, pull the package specifications from the Nix channel and install any Nix package that we want in the container:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto; font-size: 90%;&quot;&gt;&lt;br /&gt;$ nix-channel --add https://nixos.org/channels/nixpkgs-unstable nixpkgs&lt;br /&gt;$ nix-channel --update&lt;br /&gt;$ nix-env -f '&amp;lt;nixpkgs&amp;gt;' -iA file&lt;br /&gt;$ file --version&lt;br /&gt;file-5.39&lt;br /&gt;magic file from /nix/store/bx9l7vrcb9izgjgwkjwvryxsdqdd5zba-file-5.39/share/misc/magic&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h3&gt;Using the Nix package manager to deliver the required packages to construct an image&lt;/h3&gt;&lt;br /&gt;In the examples that construct Docker images for Nginx and the Apache HTTP server, I use the Debian Buster Linux distribution as base images in which I add the required packages to run the services from the Debian package repository.&lt;br /&gt;&lt;br /&gt;This is a common practice to construct Docker images -- as I have already explained in section that covers its concepts, package management is a sub problem of the process/service life-cycle management problem, but Docker leaves solving this problem to the Linux distribution's package manager.&lt;br /&gt;&lt;br /&gt;Instead of using conventional Linux distributions and their package management solutions, such as Debian, Ubuntu (using &lt;i&gt;apt-get&lt;/i&gt;), Fedora (using &lt;i&gt;yum&lt;/i&gt;) or Alpine Linux (using &lt;i&gt;apk&lt;/i&gt;), it is also possible to use Nix.&lt;br /&gt;&lt;br /&gt;The following &lt;i&gt;Dockerfile&lt;/i&gt; can be used to create an image that uses Nginx deployed by the Nix package manager:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto; font-size: 90%;&quot;&gt;&lt;br /&gt;FROM nixos/nix&lt;br /&gt;&lt;br /&gt;RUN nix-channel --add https://nixos.org/channels/nixpkgs-unstable nixpkgs&lt;br /&gt;RUN nix-channel --update&lt;br /&gt;RUN nix-env -f '&amp;lt;nixpkgs&amp;gt;' -iA nginx&lt;br /&gt;&lt;br /&gt;RUN mkdir -p /var/log/nginx /var/cache/nginx /var/www&lt;br /&gt;ADD nginx.conf /etc&lt;br /&gt;ADD index.html /var/www&lt;br /&gt;&lt;br /&gt;CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;, &quot;-c&quot;, &quot;/etc/nginx.conf&quot;]&lt;br /&gt;EXPOSE 80/tcp&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h3&gt;Using Nix to build Docker images&lt;/h3&gt;&lt;br /&gt;Ealier, I have shown that the Nix package manager can also be used in a &lt;i&gt;Dockerfile&lt;/i&gt; to obtain all required packages to run a service.&lt;br /&gt;&lt;br /&gt;In addition to building software packages, Nix can also build all kinds of static artifacts, such as disk images, DVD ROM ISO  images, and virtual machine configurations.&lt;br /&gt;&lt;br /&gt;The Nixpkgs repository also contains &lt;a href=&quot;http://lethalman.blogspot.com/2016/04/cheap-docker-images-with-nix_15.html&quot;&gt;an abstraction function to build Docker images&lt;/a&gt; that does not require any Docker utilities.&lt;br /&gt;&lt;br /&gt;For example, with the following Nix expression, we can build a Docker image that deploys Nginx:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;with import &amp;lt;nixpkgs&amp;gt; {};&lt;br /&gt;&lt;br /&gt;dockerTools.buildImage {&lt;br /&gt;  name = &quot;nginxexp&quot;;&lt;br /&gt;  tag = &quot;test&quot;;&lt;br /&gt;&lt;br /&gt;  contents = nginx;&lt;br /&gt;&lt;br /&gt;  runAsRoot = ''&lt;br /&gt;    ${dockerTools.shadowSetup}&lt;br /&gt;    groupadd -r nogroup&lt;br /&gt;    useradd -r nobody -g nogroup -d /dev/null&lt;br /&gt;    mkdir -p /var/log/nginx /var/cache/nginx /var/www&lt;br /&gt;    cp ${./index.html} /var/www/index.html&lt;br /&gt;  '';&lt;br /&gt;&lt;br /&gt;  config = {&lt;br /&gt;    Cmd = [ &quot;${nginx}/bin/nginx&quot; &quot;-g&quot; &quot;daemon off;&quot; &quot;-c&quot; ./nginx.conf ];&lt;br /&gt;    Expose = {&lt;br /&gt;      &quot;80/tcp&quot; = {};&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above expression propagates the following parameters to the &lt;i&gt;dockerTools.buildImage&lt;/i&gt; function:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;The name of the image is: &lt;i&gt;nginxexp&lt;/i&gt; using the tag: &lt;i&gt;test&lt;/i&gt;.&lt;/li&gt;&lt;li&gt;The &lt;i&gt;contents&lt;/i&gt; parameter specifies all Nix packages that should be installed in the Docker image.&lt;/li&gt;&lt;li&gt;The &lt;i&gt;runAsRoot&lt;/i&gt; refers to a script that runs as root user in a QEMU virtual machine. This virtual machine is used to provide the dynamic parts of a Docker image, setting up user accounts and configuring the state of the Nginx service.&lt;/li&gt;&lt;li&gt;The &lt;i&gt;config&lt;/i&gt; parameter specifies image configuration properties, such as the command to execute and which TCP ports should be exposed.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;Running the following command:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto; font-size: 90%;&quot;&gt;&lt;br /&gt;$ nix-build&lt;br /&gt;/nix/store/qx9cpvdxj78d98rwfk6a5z2qsmqvgzvk-docker-image-nginxexp.tar.gz&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;Produces a compressed tarball that contains all files belonging to the Docker image. We can load the image into Docker with the following command:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker load -i \&lt;br /&gt;  /nix/store/qx9cpvdxj78d98rwfk6a5z2qsmqvgzvk-docker-image-nginxexp.tar.gz&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;and then launch a container instance that uses the Nix-generated image:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker run -p 8080:80/tcp -it nginxexp:test&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;When we look at the Docker images overview:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;font-size: 90%; overflow: auto;&quot;&gt;&lt;br /&gt;$ docker images&lt;br /&gt;REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE&lt;br /&gt;nginxexp            test                cde8298f025f        50 years ago        61MB&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;There are two properties that stand out when you compare the Nix generated Docker image to conventional Docker images:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;The first odd property is that the overview says that the image that was created 50 years ago. This is explainable: to make Nix builds pure and deterministic, time stamps are typically reset to 1 second after the epoch (Januarty 1st 1970), to ensure that we always get the same bit-identical build result.&lt;/li&gt;&lt;li&gt;The second property is the size of the image: 61MB is considerably smaller than our Debian-based Docker image.&lt;br /&gt;&lt;br /&gt;To give you a comparison: the &lt;i&gt;docker history&lt;/i&gt; command-line invocation (shown earlier in this blog post) that displays the layers of which the Debian-based Nginx image consists, shows that the base Linux distribution image consumes 114 MB, the update layer 17.4 MB and the layer that provides the Nginx package is 64.2 MB.&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The reason why Nix-generated images are so small is because Nix exactly knows all runtime dependencies required to run Nginx. As a result, we can restrict the image to only contain Nginx and its required runtime dependencies, leaving all unnecessary software out.&lt;br /&gt;&lt;br /&gt;The Debian-based Nginx container is much bigger, because it also contains a base Debian Linux system with all kinds of command-line utilities and libraries, that are not required to run Nginx.&lt;br /&gt;&lt;br /&gt;The same limitation also applies to the Nix Docker image shown in the previous sections -- the Nix Docker image was constructed from an Alpine Linux image and contains a small, but fully functional Linux distribution. As a result, it is bigger than the Docker image directly generated from a Nix expression.&lt;br /&gt;&lt;br /&gt;Although a Nix-generated Docker image is smaller than most conventional images, one of its disadvantages is that the image consists of only one single layer -- as we have seen in the section about Nix concepts, many services typically share the same runtime dependencies (such as &lt;i&gt;glibc&lt;/i&gt;). Because these common dependencies are not in a reusable layer, they cannot be shared.&lt;br /&gt;&lt;br /&gt;To optimize reuse, it is also possible to &lt;a href=&quot;https://grahamc.com/blog/nix-and-layered-docker-images&quot;&gt;build layered Docker images with Nix&lt;/a&gt;:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;with import &amp;lt;nixpkgs&amp;gt; {};&lt;br /&gt;&lt;br /&gt;dockerTools.buildLayeredImage {&lt;br /&gt;  name = &quot;nginxexp&quot;;&lt;br /&gt;  tag = &quot;test&quot;;&lt;br /&gt;&lt;br /&gt;  contents = nginx;&lt;br /&gt;&lt;br /&gt;  maxLayers = 100;&lt;br /&gt;&lt;br /&gt;  extraCommands = ''&lt;br /&gt;    mkdir -p var/log/nginx var/cache/nginx var/www&lt;br /&gt;    cp ${./index.html} var/www/index.html&lt;br /&gt;  '';&lt;br /&gt;&lt;br /&gt;  config = {&lt;br /&gt;    Cmd = [ &quot;${nginx}/bin/nginx&quot; &quot;-g&quot; &quot;daemon off;&quot; &quot;-c&quot; ./nginx.conf ];&lt;br /&gt;    Expose = {&lt;br /&gt;      &quot;80/tcp&quot; = {};&lt;br /&gt;    };&lt;br /&gt;  };&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;The above Nix expression is similar to the previous. but uses &lt;i&gt;dockerTools.buildLayeredImage&lt;/i&gt; to construct a layered image.&lt;br /&gt;&lt;br /&gt;We can build and load the image as follows:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;$ docker load -i $(nix-build layered.nix)&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;When we retieve the history of the image, then we will see the following:&lt;br /&gt;&lt;br /&gt;&lt;pre style=&quot;overflow: auto; font-size: 90%;&quot;&gt;&lt;br /&gt;$ docker history nginxexp:test&lt;br /&gt;IMAGE               CREATED             CREATED BY          SIZE                COMMENT&lt;br /&gt;b91799a04b99        50 years ago                            1.47kB              store paths: ['/nix/store/snxpdsksd4wxcn3niiyck0fry3wzri96-nginxexp-customisation-layer']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            200B                store paths: ['/nix/store/6npz42nl2hhsrs98bq45aqkqsndpwvp1-nginx-root.conf']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            1.79MB              store paths: ['/nix/store/qsq6ni4lxd8i4g9g4dvh3y7v1f43fqsp-nginx-1.18.0']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            71.3kB              store paths: ['/nix/store/n14bjnksgk2phl8n69m4yabmds7f0jj2-source']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            166kB               store paths: ['/nix/store/jsqrk045m09i136mgcfjfai8i05nq14c-source']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            1.3MB               store paths: ['/nix/store/4w2zbpv9ihl36kbpp6w5d1x33gp5ivfh-source']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            492kB               store paths: ['/nix/store/kdrdxhswaqm4dgdqs1vs2l4b4md7djma-pcre-8.44']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            4.17MB              store paths: ['/nix/store/6glpgx3pypxzb09wxdqyagv33rrj03qp-openssl-1.1.1g']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            385kB               store paths: ['/nix/store/7n56vmgraagsl55aarx4qbigdmcvx345-libxslt-1.1.34']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            324kB               store paths: ['/nix/store/1f8z1lc748w8clv1523lma4w31klrdpc-geoip-1.6.12']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            429kB               store paths: ['/nix/store/wnrjhy16qzbhn2qdxqd6yrp76yghhkrg-gd-2.3.0']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            1.22MB              store paths: ['/nix/store/hqd0i3nyb0717kqcm1v80x54ipkp4bv6-libwebp-1.0.3']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            327kB               store paths: ['/nix/store/79nj0nblmb44v15kymha0489sw1l7fa0-fontconfig-2.12.6-lib']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            1.7MB               store paths: ['/nix/store/6m9isbbvj78pjngmh0q5qr5cy5y1kzyw-libxml2-2.9.10']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            580kB               store paths: ['/nix/store/2xmw4nxgfximk8v1rkw74490rfzz2gjp-libtiff-4.1.0']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            404kB               store paths: ['/nix/store/vbxifzrl7i5nvh3h505kyw325da9k47n-giflib-5.2.1']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            79.8kB              store paths: ['/nix/store/jc5bd71qcjshdjgzx9xdfrnc9hsi2qc3-fontconfig-2.12.6']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            236kB               store paths: ['/nix/store/9q5gjvrabnr74vinmjzkkljbpxi8zk5j-expat-2.2.8']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            482kB               store paths: ['/nix/store/0d6vl8gzwqc3bdkgj5qmmn8v67611znm-xz-5.2.5']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            6.28MB              store paths: ['/nix/store/rmn2n2sycqviyccnhg85zangw1qpidx0-gcc-9.3.0-lib']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            1.98MB              store paths: ['/nix/store/fnhsqz8a120qwgyyaiczv3lq4bjim780-freetype-2.10.2']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            757kB               store paths: ['/nix/store/9ifada2prgfg7zm5ba0as6404rz6zy9w-dejavu-fonts-minimal-2.37']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            1.51MB              store paths: ['/nix/store/yj40ch9rhkqwyjn920imxm1zcrvazsn3-libjpeg-turbo-2.0.4']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            79.8kB              store paths: ['/nix/store/1lxskkhsfimhpg4fd7zqnynsmplvwqxz-bzip2-1.0.6.0.1']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            255kB               store paths: ['/nix/store/adldw22awj7n65688smv19mdwvi1crsl-libpng-apng-1.6.37']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            123kB               store paths: ['/nix/store/5x6l9xm5dp6v113dpfv673qvhwjyb7p5-zlib-1.2.11']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            30.9MB              store paths: ['/nix/store/bqbg6hb2jsl3kvf6jgmgfdqy06fpjrrn-glibc-2.30']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            209kB               store paths: ['/nix/store/fhg84pzckx2igmcsvg92x1wpvl1dmybf-libidn2-2.3.0']&lt;br /&gt;&amp;lt;missing&amp;gt;           50 years ago                            1.63MB              store paths: ['/nix/store/y8n2b9nwjrgfx3kvi3vywvfib2cw5xa6-libunistring-0.9.10']&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;As you may notice, all Nix store paths are in their own layers. If we would also build a layered Docker image for the Apache HTTP service, we end up using less disk space (because common dependencies such as &lt;i&gt;glibc&lt;/i&gt; can be reused), and less RAM (because these common dependencies can be shared in RAM).&lt;br /&gt;&lt;br /&gt;Mapping Nix store paths onto layers obviously has limitations -- there is a maximum number of layers that Docker can use (in the Nix expression, I have imposed a limit of 100 layers, recent versions of Docker support a somewhat higher number).&lt;br /&gt;&lt;br /&gt;Complex systems packaged with Nix typically have much more dependencies than the number of layers that Docker can mount. To cope with this limitation, the &lt;i&gt;dockerTools.buildLayerImage&lt;/i&gt; abstraction function tries to merge infrequently used dependencies into a shared layers. More information about this process can be found in Graham Christensen's blog post.&lt;br /&gt;&lt;br /&gt;Besides the use cases shown in the examples above, &lt;a href=&quot;https://nixos.org/nixpkgs/manual/#sec-pkgs-dockerTools&quot;&gt;there is much more you can do with the &lt;i&gt;dockerTools&lt;/i&gt; functions in Nixpkgs&lt;/a&gt; -- you can also pull images from Docker Hub (with the &lt;i&gt;dockerTools.pullImage&lt;/i&gt; function) and use the &lt;i&gt;dockerTools.buildImage&lt;/i&gt; function to use existing Docker images as a basis to create hybrids combining conventional Linux software with Nix packages.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;&lt;br /&gt;In this blog post, I have elaborated about using Nix and Docker as deployment solutions.&lt;br /&gt;&lt;br /&gt;What they both have in common is that they facilitate reliable and reproducible deployment.&lt;br /&gt;&lt;br /&gt;They can be used for a variety of use cases in two different domains (package management and process/service management). Some of these use cases are common to both Nix and Docker.&lt;br /&gt;&lt;br /&gt;Nix and Docker can also be combined in several interesting ways -- Nix can be used as a package manager to deliver package dependencies in the construction process of an image, and Nix can also be used directly to build images, as a replacement for Dockerfiles.&lt;br /&gt;&lt;br /&gt;This table summarizes the conceptual differences between Nix and Docker covered in this blog post:&lt;br /&gt;&lt;br /&gt;&lt;table style=&quot;border-style: solid; border-width: 1px;&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;&lt;/th&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Nix&lt;/th&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Docker&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Application domain&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Package management&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Process/service management&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Storage units&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Package build results&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;File system changes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Storage model&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Isolated Nix store paths&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Layers + union file system&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Component addressing&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Hashes computed from inputs&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Hashes computed from a layer's contents&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Service/process management&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Unsupported&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;First-class feature&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Package management&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;First class support&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Delegated responsibility to a distro's package manager&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Development environments&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;&lt;i&gt;nix-shell&lt;/i&gt;&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Create image with dependencies + run shell session in container&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Build management (images)&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;&lt;i&gt;Dockerfile&lt;/i&gt;&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;&lt;i&gt;dockerTools.buildImage {}&lt;br /&gt;&lt;i&gt;dockerTools.buildLayeredImage {}&lt;/i&gt;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Build management (packages)&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;First class function support&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Implementer's responsibility, can be simulated&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Build environment purity&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Many precautions taken&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Only images provide some reproducibility, implementer's responsibility&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Full source traceability&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Yes (on Linux)&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;No&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th style=&quot;border-style: solid; border-width: 1px;&quot;&gt;OS support&lt;/th&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Many UNIX-like systems&lt;/td&gt;&lt;td style=&quot;border-style: solid; border-width: 1px;&quot;&gt;Linux (real system or virtualized)&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;br /&gt;I believe the last item in the table deserves a bit of clarification -- Nix works on other operating systems than Linux, e.g. macOS, and can also deploy binaries for those platforms.&lt;br /&gt;&lt;br /&gt;Docker can be used on Windows and macOS, but it still deploys Linux software -- on Windows and macOS containers are deployed to a virtualized Linux environment. Docker containers can only work on Linux, because they heavily rely on Linux-specific concepts: namespaces and cgroups.&lt;br /&gt;&lt;br /&gt;Aside from the functional parts, Nix and Docker also have some fundamental non-functional differences. One of them is usability.&lt;br /&gt;&lt;br /&gt;Although I am a long-time Nix user (since 2007). Docker is very popular because it is well-known and provides quite an optimized user experience. It does not deviate much from the way traditional Linux systems are managed -- this probably explains why so many users incorrectly call containers &quot;virtual machines&quot;, because they manifest themselves as units that provide almost fully functional Linux distributions.&lt;br /&gt;&lt;br /&gt;From &lt;a href=&quot;https://sandervanderburg.blogspot.com/2015/02/a-sales-pitch-explanation-of-nixos.html&quot;&gt;my own experiences&lt;/a&gt;, it is typically more challenging to convince a new audience to adopt Nix -- getting an audience used to the fact that a package build can be modeled as a pure function invocation (in which the function parameters are a package's build inputs) and that a specialized Nix store is used to store all static artifacts, is sometimes difficult.&lt;br /&gt;&lt;br /&gt;Both Nix and Docker support reuse: the former by means of using identical Nix store paths and the latter by using identical layers. For both solutions, these objects can be identified with hash codes.&lt;br /&gt;&lt;br /&gt;In practice, reuse with Docker is not always optimal -- for frequently used services, such as Nginx and Apache HTTP server, is not a common practice to manually derive these images from a Linux distribution base image.&lt;br /&gt;&lt;br /&gt;Instead, most Docker users will obtain specialized Nginx and Apache HTTP images. The &lt;a href=&quot;https://hub.docker.com/_/nginx&quot;&gt;official Docker Nginx images&lt;/a&gt; are constructed from Debian Buster and Alpine Linux, whereas &lt;a href=&quot;https://hub.docker.com/_/httpd&quot;&gt;the official Apache HTTP images&lt;/a&gt; only support Alpine Linux. Sharing common dependencies between these two images will only be possible if we install the Alpine Linux-based images.&lt;br /&gt;&lt;br /&gt;In practice, it happens quite frequently that people run images constructed from all kinds of different base images, making it very difficult to share common dependencies.&lt;br /&gt;&lt;br /&gt;Another impractical aspect of Nix is that it works conveniently for software compiled from source code, but packaging and deploying pre-built binaries is typically a challenge -- ELF binaries typically do not work out of the box and &lt;a href=&quot;https://sandervanderburg.blogspot.com/2015/10/deploying-prebuilt-binary-software-with.html&quot;&gt;need to be patched&lt;/a&gt;, or deployed to &lt;a href=&quot;https://sandervanderburg.blogspot.com/2013/09/composing-fhs-compatible-chroot.html&quot;&gt;an FHS user environment&lt;/a&gt; in which dependencies can be found in their &quot;usual&quot; locations (e.g. &lt;i&gt;/bin&lt;/i&gt;, &lt;i&gt;/lib&lt;/i&gt; etc.).&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Related work&lt;/h2&gt;&lt;br /&gt;In this blog post, I have restricted my analysis to Nix and Docker. Both tools are useful on their own, but they are also the foundations of entire solution eco-systems. I did not elaborate much about solutions in these extended eco-systems.&lt;br /&gt;&lt;br /&gt;For example, Nix does not do any process/service management, but there are Nix-related projects that can address this concern. Most notably: NixOS: a Linux-distribution fully managed by Nix, uses systemd to manage services.&lt;br /&gt;&lt;br /&gt;For Nix users on macOS, there is a project called &lt;a href=&quot;https://github.com/LnL7/nix-darwin&quot;&gt;nix-darwin&lt;/a&gt; that integrates with &lt;i&gt;launchd&lt;/i&gt;, which is the default service manager on macOS.&lt;br /&gt;&lt;br /&gt;There also used to be an interesting cross-over project between Nix and Docker (called &lt;a href=&quot;https://github.com/zefhemel/nix-docker&quot;&gt;nix-docker&lt;/a&gt;) combining the Nix's package management capabilities, with Docker's isolation capabilities, and &lt;a href=&quot;http://supervisord.org&quot;&gt;supervisord&lt;/a&gt;'s ability to manage multiple services in a container -- it takes a configuration file (that looks similar to a NixOS configuration) defining a set of services, fully generates a supervisord configuration (with all required services and dependencies) and deploys them to a container. Unfortunately, the project is no longer maintained.&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;https://nixery.dev&quot;&gt;Nixery&lt;/a&gt; is a Docker-compatible container registry that is capable of transparently building and serving container images using Nix.&lt;br /&gt;&lt;br /&gt;Docker is also an interesting foundation for an entire eco-system of solutions. Most notably Kubernetes, a container-orchestrating system that works with a variety of container tools including Docker. &lt;i&gt;docker-compose&lt;/i&gt; makes it possible to manage collections of Docker containers and dependencies between containers.&lt;br /&gt;&lt;br /&gt;There are also many solutions available to make building development projects with Docker (and other container technologies) more convenient than my &lt;i&gt;file&lt;/i&gt; package build example. &lt;a href=&quot;https://docs.gitlab.com/ee/ci/&quot;&gt;Gitlab CI&lt;/a&gt;, for example, provides first-class Docker integration. &lt;a href=&quot;https://cloud.google.com/tekton&quot;&gt;Tekton&lt;/a&gt; is a Kubernetes-based framework that can be used to build CI/CD systems.&lt;br /&gt;&lt;br /&gt;There are also quite a few Nix cross-over projects that integrate with the extended containers eco-system, such as Kubernetes and &lt;i&gt;docker-compose&lt;/i&gt;. For example, &lt;a href=&quot;https://github.com/hercules-ci/arion&quot;&gt;arion&lt;/a&gt; can generate &lt;i&gt;docker-compose&lt;/i&gt; configuration files with specialized containers from NixOS modules. &lt;a href=&quot;https://github.com/saschagrunert/kubernix&quot;&gt;KuberNix&lt;/a&gt; can be used to bootstrap a Kubernetes cluster with the Nix package manager, and &lt;a href=&quot;https://github.com/xtruder/kubenix&quot;&gt;Kubenix&lt;/a&gt; can be used to build Kubernetes resources with Nix.&lt;br /&gt;&lt;br /&gt;As explained in my comparisons, package management is not something that Docker supports as a first-class feature, but Docker has been an inspiration for package management solutions as well.&lt;br /&gt;&lt;br /&gt;Most notably, several years ago &lt;a href=&quot;https://sandervanderburg.blogspot.com/2015/04/an-evaluation-and-comparison-of-snappy.html&quot;&gt;I did a comparison between Nix and Ubuntu's Snappy package manager&lt;/a&gt;. The latter deploys every package (and all its required dependencies) as a container.&lt;br /&gt;&lt;br /&gt;In this comparison blog post, I raised a number of concerns about reuse. Snappy does not have any means to share common dependencies between packages, and as a result, Snaps can be quite disk space and memory consuming.&lt;br /&gt;&lt;br /&gt;&lt;a href=&quot;https://flatpak.org&quot;&gt;Flatpak&lt;/a&gt; can be considered an alternative and more open solution to Snappy.&lt;br /&gt;&lt;br /&gt;I still do not understand why these Docker-inspired package management solutions have not used Nix (e.g. storing packages in insolated folders) or Docker (e.g. using layers) as an inspiration to optimize reuse and simplify the construction of packages.&lt;br /&gt;&lt;br /&gt;&lt;h2&gt;Future work&lt;/h2&gt;&lt;br /&gt;In the next blog post, I will elaborate more about integrating the Nix package manager with tools that can address the process/service management concern.&lt;br /&gt;&lt;br /&gt;</description>
	<pubDate>Wed, 29 Jul 2020 20:57:00 +0000</pubDate>
	<author>noreply@blogger.com (Sander van der Burg)</author>
</item>
<item>
	<title>Cachix: Upstream caches: avoiding pushing paths in cache.nixos.org</title>
	<guid isPermaLink="true">https://blog.cachix.org/posts/2020-07-28-upstream-caches-avoiding-pushing-paths-in-cache-nixos-org/</guid>
	<link>https://blog.cachix.org/posts/2020-07-28-upstream-caches-avoiding-pushing-paths-in-cache-nixos-org/</link>
	<description>One of the most requested features, the so-called upstream caches was released today.
It is enabled by default for all caches, and the owner of the binary cache can disable it via Settings.
When you push store paths to Cachix, querying cache.nixos.org adds overhead of multiples of 100ms, but you save storage and possibly minutes for avoiding the pushing of already available paths.
Queries to cache.nixos.org are also cached, so that subsequent push operations do not have the overhead.</description>
	<pubDate>Tue, 28 Jul 2020 14:30:00 +0000</pubDate>
	<author>support@cachix.org (Domen Kožar)</author>
</item>
<item>
	<title>Cachix: Documentation and More Documentation</title>
	<guid isPermaLink="true">https://blog.cachix.org/posts/2020-07-20-documentation-and-more-documentation/</guid>
	<link>https://blog.cachix.org/posts/2020-07-20-documentation-and-more-documentation/</link>
	<description>Documentation is an important ingredient of a successful software project.
Last few weeks I’ve worked on improving status quo on two fronts:
1) https://nix.dev is an opinionated guide for developers getting things done using the Nix ecosystem.
A few highlights:
 Getting started repository template with a tutorial for using declarative and reproducible developer environments
 Setting up GitHub Actions with Nix
 Nix language anti-patterns to avoid and recommended alternatives</description>
	<pubDate>Mon, 20 Jul 2020 14:45:00 +0000</pubDate>
	<author>support@cachix.org (Domen Kožar)</author>
</item>
<item>
	<title>Tweag I/O: Setting up Buildkite for Nix-based projects using Terraform and GCP</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-07-08-buildkite-for-nix-ci/</guid>
	<link>https://tweag.io/blog/2020-07-08-buildkite-for-nix-ci/</link>
	<description>&lt;p&gt;In this post I’m going to show how to setup, with Terraform, a Buildkite-based CI using your
own workers that run on GCP. For reference, the complete
Terraform configuration for this post is available in &lt;a href=&quot;https://github.com/tweag/blog-resources/tree/master/buildkite-for-nix-ci&quot;&gt;this
repository&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The setup gives you complete control on how fast your worker are.&lt;/li&gt;
&lt;li&gt;The workers come with Nix pre-installed, so you won’t need to spend
time downloading the same docker container again and again on every
push as would usually happen with most cloud CI providers.&lt;/li&gt;
&lt;li&gt;The workers come with a distributed Nix cache set up. So
authors of CI scripts won’t have to bother about caching at all.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Secrets&lt;/h2&gt;
&lt;p&gt;We are going to need to import two &lt;a href=&quot;https://www.tweag.io/posts/2019-04-03-terraform-provider-secret.html&quot;&gt;secret resources&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-hcl&quot;&gt;&lt;code class=&quot;language-hcl&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;resource &lt;span class=&quot;token type variable&quot;&gt;&quot;secret_resource&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;buildkite_agent_token&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;resource &lt;span class=&quot;token type variable&quot;&gt;&quot;secret_resource&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;nix_signing_key&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To initialize the resources, execute the following from the root directory of your project:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;$ terraform &lt;span class=&quot;token function&quot;&gt;import&lt;/span&gt; secret_resource.&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;name&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;value&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;buildkite_agent_token&lt;/code&gt; is obtained from the &lt;a href=&quot;https://buildkite.com&quot;&gt;Buildkite site&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;nix_signing_key&lt;/code&gt; can be generated by running:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;nix-store --generate-binary-cache-key &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;your-key-name&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; key.private key.public&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code class=&quot;language-text&quot;&gt;key.private&lt;/code&gt; file will contain the value for the signing key. I’ll
explain later in the post how to use the contents of the &lt;code class=&quot;language-text&quot;&gt;key.public&lt;/code&gt;
file.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Custom NixOS image&lt;/h2&gt;
&lt;p&gt;The next step is to use the &lt;a href=&quot;https://github.com/tweag/terraform-nixos/tree/master/google_image_nixos_custom&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;nixos_image_custom&lt;/code&gt;&lt;/a&gt;
module to create a NixOS image with custom configuration.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-hcl&quot;&gt;&lt;code class=&quot;language-hcl&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;resource &lt;span class=&quot;token type variable&quot;&gt;&quot;google_storage_bucket&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;nixos_image&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;name&lt;/span&gt;     &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;buildkite-nixos-image-bucket-name&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;EU&quot;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;module&lt;span class=&quot;token type variable&quot;&gt; &quot;nixos_image_custom&quot; &lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;source&lt;/span&gt;      &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;git::https://github.com/tweag/terraform-nixos.git//google_image_nixos_custom?ref=40fedb1fae7df5bd7ad9defdd71eb06b7252810f&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;bucket_name&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;google_storage_bucket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nixos_image&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;nixos_config&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token type variable&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;/nixos-config.nix&quot;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The snippet above first creates a bucket &lt;code class=&quot;language-text&quot;&gt;nixos_image&lt;/code&gt; where the generated
image will be uploaded, then it uses the &lt;code class=&quot;language-text&quot;&gt;nixos_image_custom&lt;/code&gt; module, which
handles generation of the image using the configuration from the
&lt;code class=&quot;language-text&quot;&gt;nixos-config.nix&lt;/code&gt; file. The file is assumed to be in the same directory as
the Terraform configuration, hence &lt;code class=&quot;language-text&quot;&gt;${path.module}/&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Service account and cache bucket&lt;/h2&gt;
&lt;p&gt;To control access to different resources we will also need a service
account:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-hcl&quot;&gt;&lt;code class=&quot;language-hcl&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;resource &lt;span class=&quot;token type variable&quot;&gt;&quot;google_service_account&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;buildkite_agent&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;account_id&lt;/span&gt;   &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;buildkite-agent&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;display_name&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Buildkite agent&quot;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can use it to set access permissions for the storage bucket that will contain the
Nix cache:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-hcl&quot;&gt;&lt;code class=&quot;language-hcl&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;resource &lt;span class=&quot;token type variable&quot;&gt;&quot;google_storage_bucket&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;nix_cache_bucket&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;name&lt;/span&gt;     &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;nix-cache-bucket-name&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;EU&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;force_destroy&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;retention_policy&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;retention_period&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;7889238&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# three months&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;resource &lt;span class=&quot;token type variable&quot;&gt;&quot;google_storage_bucket_iam_member&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;buildkite_nix_cache_writer&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;bucket&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;google_storage_bucket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nix_cache_bucket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;roles/storage.objectAdmin&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;member&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;serviceAccount:&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;google_service_account&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;buildkite_agent&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;email&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;resource &lt;span class=&quot;token type variable&quot;&gt;&quot;google_storage_bucket_iam_member&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;buildkite_nix_cache_reader&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;bucket&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;google_storage_bucket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nix_cache_bucket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;role&lt;/span&gt;   &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;roles/storage.objectViewer&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;member&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;allUsers&quot;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The bucket is configured to automatically delete objects that are older than
3 months. We give the service account the ability to write to and read from
the bucket (the &lt;code class=&quot;language-text&quot;&gt;roles/storage.objectAdmin&lt;/code&gt; role). The rest of the world
gets the ability to read from the bucket (the &lt;code class=&quot;language-text&quot;&gt;roles/storage.objectViewer&lt;/code&gt;
role).&lt;/p&gt;
&lt;h2&gt;NixOS configuration&lt;/h2&gt;
&lt;p&gt;Here is the content of my &lt;code class=&quot;language-text&quot;&gt;nixos-config.nix&lt;/code&gt;. This NixOS configuration
can serve as a starting point for writing your own. The numbered
points refer to the notes below.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-nix&quot;&gt;&lt;code class=&quot;language-nix&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; modulesPath&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; pkgs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  imports &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token antiquotation variable&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;modulesPath&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;/virtualisation/google-compute-image.nix&quot;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  virtualisation&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;googleComputeImage&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;diskSize &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  virtualisation&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;docker&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;enable &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  services &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    buildkite&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;agents&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;agent &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      enable &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      extraConfig &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;''
      tags-from-gcp=true
      ''&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      tags &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        os &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;nixos&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        nix &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      tokenPath &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;/run/keys/buildkite-agent-token&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# (1)&lt;/span&gt;
      runtimePackages &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;with&lt;/span&gt; pkgs&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
        bash
        curl
        gcc
        gnutar
        gzip
        ncurses
        nix
        python3
        xz
        &lt;span class=&quot;token comment&quot;&gt;# (2) extend as necessary&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    nix&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;store&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;gcs&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;proxy &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      nix&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;cache&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;bucket&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# (3)&lt;/span&gt;
        address &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;localhost:3000&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  nix &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    binaryCaches &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;https://cache.nixos.org/&quot;&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;https://storage.googleapis.com/nix-cache-bucket-name&quot;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# (4)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    binaryCachePublicKeys &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=&quot;&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;&amp;lt;insert your public signing key here&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# (5)&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    extraOptions &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;''
      post-build-hook = /etc/nix/upload-to-cache.sh # (6)
    ''&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  security&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sudo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;enable &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  services&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;openssh&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;passwordAuthentication &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  security&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sudo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;wheelNeedsPassword &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;This file will be created later by the startup script (see below).&lt;/li&gt;
&lt;li&gt;The collection of packages that are available to the Buildkite script can
be edited here.&lt;/li&gt;
&lt;li&gt;Replace &lt;code class=&quot;language-text&quot;&gt;nix-cache-bucket-name&lt;/code&gt; by the name of the bucket used for the
Nix cache.&lt;/li&gt;
&lt;li&gt;Similarly to (3) replace &lt;code class=&quot;language-text&quot;&gt;nix-cache-bucket-name&lt;/code&gt; in the URL.&lt;/li&gt;
&lt;li&gt;Insert the contents of the &lt;code class=&quot;language-text&quot;&gt;key.public&lt;/code&gt; file you generated earlier.&lt;/li&gt;
&lt;li&gt;The file will be created later by the startup script.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Compute instances and startup script&lt;/h2&gt;
&lt;p&gt;The following snippet sets up an instance group manager which controls
multiple (3 in this example) Buildkite agents. The numbered
points refer to the notes below.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-hcl&quot;&gt;&lt;code class=&quot;language-hcl&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;data &lt;span class=&quot;token type variable&quot;&gt;&quot;template_file&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;buildkite_nixos_startup&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# (1)&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;${path.module}/files/buildkite_nixos_startup.sh&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;

  &lt;span class=&quot;token property&quot;&gt;vars&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;buildkite_agent_token&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;secret_resource&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;buildkite_agent_token&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;nix_signing_key&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;secret_resource&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;nix_signing_key&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;resource &lt;span class=&quot;token type variable&quot;&gt;&quot;google_compute_instance_template&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;buildkite_nixos&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;name_prefix&lt;/span&gt;  &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;buildkite-nixos-&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;machine_type&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;n1-standard-8&quot;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;disk&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;boot&lt;/span&gt;         &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;disk_size_gb&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;source_image&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token type variable&quot;&gt;nixos_image_custom&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;self_link&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token property&quot;&gt;metadata_startup_script&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token type variable&quot;&gt;template_file&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;buildkite_nixos_startup&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;rendered&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;network_interface&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;network&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;default&quot;&lt;/span&gt;

    &lt;span class=&quot;token property&quot;&gt;access_config&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;metadata&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;enable-oslogin&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;service_account&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;email&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;google_service_account&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;buildkite_agent&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;email&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;

    &lt;span class=&quot;token property&quot;&gt;scopes&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;token string&quot;&gt;&quot;compute-ro&quot;&lt;/span&gt;,
      &lt;span class=&quot;token string&quot;&gt;&quot;logging-write&quot;&lt;/span&gt;,
      &lt;span class=&quot;token string&quot;&gt;&quot;storage-rw&quot;&lt;/span&gt;,
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;scheduling&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;automatic_restart&lt;/span&gt;   &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;on_host_maintenance&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;TERMINATE&quot;&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;preemptible&lt;/span&gt;         &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# (2)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;lifecycle&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;create_before_destroy&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;resource &lt;span class=&quot;token type variable&quot;&gt;&quot;google_compute_instance_group_manager&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;buildkite_nixos&quot;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;provider&lt;/span&gt;           &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;google-beta&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;name&lt;/span&gt;               &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;buildkite-nixos&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;base_instance_name&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;buildkite-nixos&quot;&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;target_size&lt;/span&gt;        &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;3&quot;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# (3)&lt;/span&gt;
  &lt;span class=&quot;token property&quot;&gt;zone&lt;/span&gt;               &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&amp;lt;your-zone&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# (4)&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;name&lt;/span&gt;              &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;buildkite_nixos&quot;&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;instance_template&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;google_compute_instance_template&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;buildkite_nixos&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;self_link&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;update_policy&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;type&lt;/span&gt;                  &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;PROACTIVE&quot;&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;minimal_action&lt;/span&gt;        &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;REPLACE&quot;&lt;/span&gt;
    &lt;span class=&quot;token property&quot;&gt;max_unavailable_fixed&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The file &lt;code class=&quot;language-text&quot;&gt;files/buildkite_nixos_startup.sh&lt;/code&gt; is shown below.&lt;/li&gt;
&lt;li&gt;Because of the remote Nix cache, the nodes can be preemptible
(short-lived, never lasting longer than 24 hours), which results in much
lower GCP costs.&lt;/li&gt;
&lt;li&gt;Changing &lt;code class=&quot;language-text&quot;&gt;target_size&lt;/code&gt; allows you to scale the system. This is the number
of instances that are controlled by the instance group manager.&lt;/li&gt;
&lt;li&gt;Insert your desired zone here.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Finally, here is the startup script:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;# workaround https://github.com/NixOS/nixpkgs/issues/42344&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;chown&lt;/span&gt; root:keys /run/keys
&lt;span class=&quot;token function&quot;&gt;chmod&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;750&lt;/span&gt; /run/keys
&lt;span class=&quot;token builtin class-name&quot;&gt;umask&lt;/span&gt; 037
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&lt;span class=&quot;token variable&quot;&gt;${buildkite_agent_token}&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; /run/keys/buildkite-agent-token
&lt;span class=&quot;token function&quot;&gt;chown&lt;/span&gt; root:keys /run/keys/buildkite-agent-token
&lt;span class=&quot;token builtin class-name&quot;&gt;umask&lt;/span&gt; 077
&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;'&lt;span class=&quot;token variable&quot;&gt;${nix_signing_key}&lt;/span&gt;'&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; /run/keys/nix_signing_key
&lt;span class=&quot;token function&quot;&gt;chown&lt;/span&gt; root:keys /run/keys/nix-signing-key

&lt;span class=&quot;token function&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;EOF &lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;/span&gt; /etc/nix/upload-to-cache.sh
&lt;span class=&quot;token comment&quot;&gt;#!/bin/sh&lt;/span&gt;

&lt;span class=&quot;token builtin class-name&quot;&gt;set&lt;/span&gt; -eu
&lt;span class=&quot;token builtin class-name&quot;&gt;set&lt;/span&gt; -f &lt;span class=&quot;token comment&quot;&gt;# disable globbing&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;token assign-left variable&quot;&gt;&lt;span class=&quot;token environment constant&quot;&gt;IFS&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;' '&lt;/span&gt;

&lt;span class=&quot;token builtin class-name&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Uploading paths&quot;&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$OUT_PATHS&lt;/span&gt;
&lt;span class=&quot;token builtin class-name&quot;&gt;exec&lt;/span&gt; nix copy --to http://localhost:3000?secret-key&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;/run/keys/nix_signing_key &lt;span class=&quot;token punctuation&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$OUT_PATHS&lt;/span&gt;
EOF
&lt;span class=&quot;token function&quot;&gt;chmod&lt;/span&gt; +x /etc/nix/upload-to-cache.sh&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This script uses the Nix &lt;a href=&quot;https://www.tweag.io/posts/2019-11-21-untrusted-ci.html&quot;&gt;post build hook&lt;/a&gt; approach for
uploading to the cache without polluting the CI script.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The setup allows us to run Nix builds in an environment where Nix tooling is
available. It also provides a remote Nix cache which does not require
that the
authors of CI scripts set it up or, even, be aware of it at all. We use this setup on
many of Tweag’s projects and found that both mental and performance overheads are
minimal. A typical CI script looks like this:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-yaml&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;&lt;span class=&quot;token key atrule&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token key atrule&quot;&gt;label&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; Build and test
    &lt;span class=&quot;token key atrule&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; nix&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;build &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;A distributed&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;closure &lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;no&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;-&lt;/span&gt;link&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Builds with up-to-date cache that does not cause re-builds may finish in
literally 1 second.&lt;/p&gt;</description>
	<pubDate>Wed, 08 Jul 2020 00:00:00 +0000</pubDate>
</item>
<item>
	<title>Tweag I/O: Nix Flakes, Part 2: Evaluation caching</title>
	<guid isPermaLink="true">https://tweag.io/blog/2020-06-25-eval-cache/</guid>
	<link>https://tweag.io/blog/2020-06-25-eval-cache/</link>
	<description>&lt;p&gt;Nix evaluation is often quite slow. In this blog post, we’ll have a
look at a nice advantage of the hermetic evaluation model enforced by
flakes: the ability to cache evaluation results reliably. For a short
introduction to flakes, see our &lt;a href=&quot;https://www.tweag.io/blog/2020-05-25-flakes/&quot;&gt;previous blog post&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Why Nix evaluation is slow&lt;/h2&gt;
&lt;p&gt;Nix uses a simple, interpreted, purely functional language to describe
package dependency graphs and NixOS system configurations. So to get
any information about those things, Nix first needs to &lt;em&gt;evaluate&lt;/em&gt; a
substantial Nix program. This involves parsing potentially thousands
of .nix files and running a Turing-complete language.&lt;/p&gt;
&lt;p&gt;For example, the command &lt;code class=&quot;language-text&quot;&gt;nix-env -qa&lt;/code&gt; shows you which packages are
available in Nixpkgs. But this is quite slow and takes a lot of memory:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-shell-session&quot;&gt;&lt;code class=&quot;language-shell-session&quot;&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token shell-symbol important&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;token bash language-bash&quot;&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;time&lt;/span&gt; nix-env -qa &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;wc&lt;/span&gt; -l&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token output&quot;&gt;5.09user 0.49system 0:05.59elapsed 99%CPU (0avgtext+0avgdata 1522792maxresident)k
28012&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Evaluating individual packages or configurations can also be slow. For
example, using &lt;code class=&quot;language-text&quot;&gt;nix-shell&lt;/code&gt; to enter a development environment for
&lt;a href=&quot;https://github.com/NixOS/hydra&quot;&gt;Hydra&lt;/a&gt;, we have to wait a bit, even
if all dependencies are present in the Nix store:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-shell-session&quot;&gt;&lt;code class=&quot;language-shell-session&quot;&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token shell-symbol important&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;token bash language-bash&quot;&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;time&lt;/span&gt; nix-shell --command &lt;span class=&quot;token string&quot;&gt;'exit 0'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token output&quot;&gt;1.34user 0.18system 0:01.69elapsed 89%CPU (0avgtext+0avgdata 434808maxresident)k&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That might be okay for occasional use but a wait of one or more
seconds may well be unacceptably slow in scripts.&lt;/p&gt;
&lt;p&gt;Note that the evaluation overhead is completely independent from the
time it takes to actually build or download a package or
configuration. If something is already present in the Nix store, Nix
won’t build or download it again. But it still needs to re-evaluate
the Nix files to determine &lt;em&gt;which&lt;/em&gt; Nix store paths are needed.&lt;/p&gt;
&lt;h2&gt;Caching evaluation results&lt;/h2&gt;
&lt;p&gt;So can’t we speed things up by &lt;em&gt;caching&lt;/em&gt; evaluation results? After
all, the Nix language is purely functional, so it seems that
re-evaluation should produce the same result, every time. Naively,
maybe we can keep a cache that records that attribute A of file X
evaluates to derivation D (or whatever metadata we want to cache).
Unfortunately, it’s not that simple; cache invalidation is, after all,
one of the &lt;a href=&quot;https://martinfowler.com/bliki/TwoHardThings.html&quot;&gt;only two hard problems in computer
science&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The reason this didn’t work is that in the past Nix evaluation was not
&lt;em&gt;hermetic&lt;/em&gt;. For example, a &lt;code class=&quot;language-text&quot;&gt;.nix&lt;/code&gt; file can import other Nix files
through relative or absolute paths (such as
&lt;code class=&quot;language-text&quot;&gt;~/.config/nixpkgs/config.nix&lt;/code&gt; for Nixpkgs) or by looking them up in
the Nix search path (&lt;code class=&quot;language-text&quot;&gt;$NIX_PATH&lt;/code&gt;). So unless we perfectly keep track
of &lt;em&gt;all&lt;/em&gt; the files used during evaluation, a cached result might be
inconsistent with the current input.&lt;/p&gt;
&lt;p&gt;(As an aside: for a while, Nix has had an experimental replacement for
&lt;code class=&quot;language-text&quot;&gt;nix-env -qa&lt;/code&gt; called &lt;code class=&quot;language-text&quot;&gt;nix search&lt;/code&gt;, which used an ad hoc cache for
package metadata. It had exactly this cache invalidation problem: it
wasn’t smart enough to figure out whether its cache was up to date
with whatever revision of Nixpkgs you were using. So it had a manual
flag &lt;code class=&quot;language-text&quot;&gt;--update-cache&lt;/code&gt; to allow the user to force cache invalidation.)&lt;/p&gt;
&lt;h2&gt;Flakes to the rescue&lt;/h2&gt;
&lt;p&gt;Flakes solve this problem by ensuring fully hermetic evaluation. When
you evaluate an output attribute of a particular flake (e.g. the
attribute &lt;code class=&quot;language-text&quot;&gt;defaultPackage.x86_64-linux&lt;/code&gt; of the &lt;code class=&quot;language-text&quot;&gt;dwarffs&lt;/code&gt; flake), Nix
disallows access to any files outside that flake or its
dependencies. It also disallows impure or platform-dependent features
such as access to environment variables or the current system type.&lt;/p&gt;
&lt;p&gt;This allows the &lt;code class=&quot;language-text&quot;&gt;nix&lt;/code&gt; command to aggressively cache evaluation results
without fear of cache invalidation problems. Let’s see this in action
by running Firefox from the &lt;code class=&quot;language-text&quot;&gt;nixpkgs&lt;/code&gt; flake. If we do this with an
empty evaluation cache, Nix needs to evaluate the entire dependency
graph of Firefox, which takes a quarter of a second:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ command time nix shell nixpkgs#firefox -c firefox --version
Mozilla Firefox 75.0
0.26user 0.05system 0:00.39elapsed 82%CPU (0avgtext+0avgdata 115224maxresident)k&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But if we do it again, it’s almost instantaneous (and takes less
memory):&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;$ command time nix shell nixpkgs#firefox -c firefox --version
Mozilla Firefox 75.0
0.01user 0.01system 0:00.03elapsed 93%CPU (0avgtext+0avgdata 25840maxresident)k&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The cache is implemented using a simple SQLite database that stores the
values of flake output attributes. After the first command above, the
cache looks like this:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-shell-session&quot;&gt;&lt;code class=&quot;language-shell-session&quot;&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token shell-symbol important&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;token bash language-bash&quot;&gt;sqlite3 ~/.cache/nix/eval-cache-v1/302043eedfbce13ecd8169612849f6ce789c26365c9aa0e6cfd3a772d746e3ba.sqlite .dump&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token output&quot;&gt;PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE Attributes (
    parent      integer not null,
    name        text,
    type        integer not null,
    value       text,
    primary key (parent, name)
);
INSERT INTO Attributes VALUES(0,'',0,NULL);
INSERT INTO Attributes VALUES(1,'packages',3,NULL);
INSERT INTO Attributes VALUES(1,'legacyPackages',0,NULL);
INSERT INTO Attributes VALUES(3,'x86_64-linux',0,NULL);
INSERT INTO Attributes VALUES(4,'firefox',0,NULL);
INSERT INTO Attributes VALUES(5,'type',2,'derivation');
INSERT INTO Attributes VALUES(5,'drvPath',2,'/nix/store/7mz8pkgpl24wyab8nny0zclvca7ki2m8-firefox-75.0.drv');
INSERT INTO Attributes VALUES(5,'outPath',2,'/nix/store/5x1i2gp8k95f2mihd6aj61b5lydpz5dy-firefox-75.0');
INSERT INTO Attributes VALUES(5,'outputName',2,'out');
COMMIT;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In other words, the cache stores all the attributes that &lt;code class=&quot;language-text&quot;&gt;nix shell&lt;/code&gt;
had to evaluate, in particular
&lt;code class=&quot;language-text&quot;&gt;legacyPackages.x86_64-linux.firefox.{type,drvPath,outPath,outputName}&lt;/code&gt;. It
also stores negative lookups, that is, attributes that don’t exist
(such as &lt;code class=&quot;language-text&quot;&gt;packages&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The name of the SQLite database, &lt;code class=&quot;language-text&quot;&gt;302043eedf….sqlite&lt;/code&gt; in this example,
is derived from the contents of the top-level flake. Since the flake’s
lock file contains content hashes of all dependencies, this is enough
to efficiently and completely capture all files that might influence
the evaluation result. (In the future, we’ll optimise this a bit more:
for example, if the flake is a Git repository, we can simply use the
Git revision as the cache name.)&lt;/p&gt;
&lt;p&gt;The &lt;code class=&quot;language-text&quot;&gt;nix search&lt;/code&gt; command has been updated to use the new evaluation
cache instead of its previous ad hoc cache. For example, searching for
Blender is slow the first time:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-shell-session&quot;&gt;&lt;code class=&quot;language-shell-session&quot;&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token shell-symbol important&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;token bash language-bash&quot;&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;time&lt;/span&gt; nix search nixpkgs blender&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token output&quot;&gt;* legacyPackages.x86_64-linux.blender (2.82a)
  3D Creation/Animation/Publishing System
5.55user 0.63system 0:06.17elapsed 100%CPU (0avgtext+0avgdata 1491912maxresident)k&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;but the second time it is pretty fast and uses much less memory:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot;&gt;&lt;pre class=&quot;language-shell-session&quot;&gt;&lt;code class=&quot;language-shell-session&quot;&gt;&lt;span class=&quot;token command&quot;&gt;&lt;span class=&quot;token shell-symbol important&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;token bash language-bash&quot;&gt;&lt;span class=&quot;token builtin class-name&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;time&lt;/span&gt; nix search nixpkgs blender&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token output&quot;&gt;* legacyPackages.x86_64-linux.blender (2.82a)
  3D Creation/Animation/Publishing System
0.41user 0.00system 0:00.42elapsed 99%CPU (0avgtext+0avgdata 21100maxresident)k&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The evaluation cache at this point is about 10.9 MiB in size. The
overhead for creating the cache is fairly modest: with the flag
&lt;code class=&quot;language-text&quot;&gt;--no-eval-cache&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;nix search nixpkgs blender&lt;/code&gt; takes 4.9 seconds.&lt;/p&gt;
&lt;h2&gt;Caching and store derivations&lt;/h2&gt;
&lt;p&gt;There is only one way in which cached results can become “stale”, in a
way. Nix evaluation produces store derivations such as
&lt;code class=&quot;language-text&quot;&gt;/nix/store/7mz8pkgpl24wyab8nny0zclvca7ki2m8-firefox-75.0.drv&lt;/code&gt; as a
side effect. (&lt;code class=&quot;language-text&quot;&gt;.drv&lt;/code&gt; files are essentially a serialization of the
dependency graph of a package.) These store derivations may be
garbage-collected. In that case, the evaluation cache points to a path
that no longer exists. Thus, Nix checks whether the &lt;code class=&quot;language-text&quot;&gt;.drv&lt;/code&gt; file still
exist, and if not, falls back to evaluating normally.&lt;/p&gt;
&lt;h2&gt;Future improvements&lt;/h2&gt;
&lt;p&gt;Currently, the evaluation cache is only created and used
locally. However, Nix could automatically &lt;em&gt;download&lt;/em&gt; precomputed
caches, similar to how it has a binary cache for the contents of store
paths. That is, if we need a cache like &lt;code class=&quot;language-text&quot;&gt;302043eedf….sqlite&lt;/code&gt;, we could
first check if it’s available on &lt;code class=&quot;language-text&quot;&gt;cache.nixos.org&lt;/code&gt; and if so fetch it
from there. In this way, when we run a command such as &lt;code class=&quot;language-text&quot;&gt;nix shell nixpkgs#firefox&lt;/code&gt;, we could even avoid the need to fetch the actual
source of the flake!&lt;/p&gt;
&lt;p&gt;Another future improvement is to populate and use the cache in the
evaluator itself. Currently the cache is populated and cached in the
user interface (that is, the &lt;code class=&quot;language-text&quot;&gt;nix&lt;/code&gt; command). The command &lt;code class=&quot;language-text&quot;&gt;nix shell nixpkgs#firefox&lt;/code&gt; will create a cache entry for &lt;code class=&quot;language-text&quot;&gt;firefox&lt;/code&gt;, but not for
the dependencies of &lt;code class=&quot;language-text&quot;&gt;firefox&lt;/code&gt;; thus a subsequent &lt;code class=&quot;language-text&quot;&gt;nix shell nixpkgs#thunderbird&lt;/code&gt; won’t see a speed improvement even though it
shares most of its dependencies. So it would be nice if the evaluator
had knowledge of the evaluation cache. For example, the evaluation of
thunks that represent attributes like
&lt;code class=&quot;language-text&quot;&gt;nixpkgs.legacyPackages.x86_64-linux.&amp;lt;package name&amp;gt;&lt;/code&gt; could check and
update the cache.&lt;/p&gt;</description>
	<pubDate>Thu, 25 Jun 2020 00:00:00 +0000</pubDate>
</item>

</channel>
</rss>
