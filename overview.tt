[% WRAPPER layout.tt title="Overview" handlesLayout=1 %]

<div class="page-title">
  <h1>Overview</h1>
</div>

<section class="overview-description">
  Step on a journey to <strong>explore and learn</strong> why so many developers, system
  administrators and other enthusiasts use Nix and can not imagine the world
  without it.
</section>

<section class="overview-benefits">

  <div>
    <!-- sparkles, success, joy, for developers -->
    [% PROCESS svg path="site-styles/assets/gfx-overview-cloud.svg" %]
    <div>
      <h2>Always working development environment.</h2>
      <!--
      <h2>Never breaking development environment.</h2>
      <h2>Complete development environment.</h2>
      <h2>Complete and consistent development environment.</h2>
      -->
      <p>
        With Nix every developer will enter a
        <strong>complete and consistent development environment</strong>.
        Stop worrying how to install dependencies for your project.
      </p>
      <ul>
        <!-- TODO: this should be links to a more detailed explanation
                   in which we should explain how it works? and why it works
                   the way it is works?
        -->
        <li>complete dependencies</li>
        <li>build sandbox</li>
      </ul>
      <div>
        <p>
          Under Nix, a build process will only find resources that have been
          declared explicitly as dependencies. There is no way it can build
          until everything it needs has been correctly declared. If it builds,
          you will know you've provided a complete declaration.
        </p>
        <p>
          The same build process specification is than used to provide
          development environment. With successful build, we can guarantee that
          everything needed to build the project is available. Even more,
          additional development tools can be added to assist the development.
        </p>
        <p>
          Long are gone the days developers saying:
          <strong>But it works on my machine!</strong>
        </p>
      </div>
    </div>
  </div>

  <div>
    <!-- collaboration, sharing -->
    [% PROCESS svg path="site-styles/assets/gfx-overview-gears.svg" %]
    <div>
      <h2>
        <!-- TODO: missing the emotional part
        -->
        One tool, many languages.
      </h2>
      <p>
        With today's polyglot development environments, each language has its
        own way of building and testing. Encourage cross-team development by
        providing a single way of building everything.
      </p>
      <ul>
        <li>language agnostic</li>
        <li>portable</li>
      </ul>
      <div>
        <p>
          Keeping the project's installation instructions up to date is a never
          ending task. Nix allows you to specify your system dependencies
          alongside your project's dependencies in a declarative way.
        </p>
        <p>
          Instead of complicated installation instructions, with Nix the
          development environment is always only one command away. And that is
          without using any Docker or other vitalization.
        </p>
      </div>
    </div>
  </div>

  <div>
    [% PROCESS svg path="site-styles/assets/gfx-overview-looking.svg" %]
    <div>
      <h2>
        Either it works or fails - always in the same way.
      </h2>
      <p>
        With Nix there are two results: the code either works or fails always
        in the same way. This gives you the power to reproduce (and avoid) any
        build related bugs .
      </p>
      <ul>
        <li>reproducibility</li>
        <li>transparent source binary model</li>
        <li>nix language</li>
        <li>continuous integration</li>
      </ul>
      <div>
        <p>
          Trying to keep system dependencies of development environments in
          sync with continuous integration (CI) is a disaster waiting to
          happen. Being able to use the same environment locally or anywhere
          else is putting a developer back in control.
        </p>
        <p>
          Build instructions are written in Nix language, which allows you to
          extend or change existing build instruction in any way you wish. This
          makes Nix a powerful build tool that can be used in both simple and
          complex projects.
        </p>
      </div>
    </div>
  </div>
  <div>
    [% PROCESS svg path="site-styles/assets/gfx-overview-cloud.svg" %]
    <div>
      <h2>
        From zero to cloud.
      </h2>
      <p>
        Use the same tool to build one project or even one hundred projects,
        configure machines and deploy to the cloud.
      </p>
      <ul>
        <li>cloud images</li>
        <li>docker images</li>
        <li>devops</li>
      </ul>
      <div>
        <p>
          Use one tool to develop, test and build Amazon EC2, Google Cloud,
          Azure, Virtualbox, KVM and other images in a declarative way is a
          DevOps dream.
        </p>
        <p>
          Forget <code>Dockerfile</code> and
          have a peace of mind with declarative approach Nix gives you. Nix
          automatically calculates the optimal layer layout and only includes
          software needed.
          <strong>Nix and Docker is a match made in heaven.</strong>
        </p>
      </div>
    </div>
  </div>

  <div>
    [% PROCESS svg path="site-styles/assets/gfx-overview-gears.svg" %]
    <div>
      <h2>
        Previous version better? Rollback anytime.
      </h2>
      <p>
        Packages are never overwritten, and old versions are always stored.
        Rollback to any previous version within milliseconds.
      </p>
      <ul>
        <li>generations</li>
        <li>garbage collection</li>
        <li>atomic</li>
        <li>nix store</li>
      </ul>
      <div>
        <p>
          Since Nix never overwrites files in the Nix store, but just adds new
          versions in different paths, the upgrades are atomic. During an
          upgrade, there is no time window in which some files exists from the
          old version and some files from the new version - which would be bad
          because a program might crash if it's restarted during that period.
        </p>
        <p>
          And since nothing is overwritten, the old versions are still there
          after an upgrade. This means that you can rollback to the old
          version. Rollbacks are very fast: it doesn't involve lots of files
          having to be restored from copies.
        </p>
      </div>
    </div>
  </div>

  <div>
    <!-- hacking, fun, party -->
    [% PROCESS svg path="site-styles/assets/gfx-overview-gears.svg" %]
    <div>
      <h2>
        Experiment without fear.
      </h2>
      <ul>
        <li>generations</li>
        <li>nix store</li>
      </ul>
      <p>
        <!-- tODO: Explain fear and experiment -->
        Use tools that allow you to play with different software as
        you did when the job wasn't waiting for you the next day.
      </p>
      <div>
        <p>
          Install new software with no risk of breaking anything down. Nix
          prevents conflicts not only between multiple development environments,
          but also with the operating system. Your work environment will stay
          intact, but allow you to experiment in a safe way.
        </p>
        <p>
          No need to turn your system upside down just because you want to test
          some experimental and bleeding edge versions of software.
        </p>
      </div>
    </div>
  </div>

  <div>
    [% PROCESS svg path="site-styles/assets/gfx-overview-gears.svg" %]
    <div>
      <h2>
        No surprises. Trust in your deployments.
      </h2>
      <p>
        Surprises only belong to birthdays, not deployments. With Nix there
        are only two possible outcomes. Your system was successfully upgraded
        or upgrade did not happen.
      </p>
      <ul>
        <li>nixos</li>
        <li>atomic</li>
        <li>generations</li>
      </ul>
      <div>
        <p>
          Nix will never leave your system in an unknown state. It puts you in
          a complete control. The upgrade to new version of the system is
          atomic, meaning that there is no point in time where your system
          could be in a broken state. Some call it magic, Nix users call it the
          thing that they can not live without.
        </p>
      </div>
    </div>
  </div>

  <div>
    [% PROCESS svg path="site-styles/assets/gfx-overview-gears.svg" %]
    <div>
      <h2>
        Contributing is only a pull request away.
      </h2>
      <p>
        Community is at the core of Nix. Collaboration is encouraged by
        providing a low barrier to contribute and bots to guide contributors
        through the process.
      </p>
      <ul>
        <li>community</li>
        <li>contribute</li>
        <li>github</li>
      </ul>
      <div>
        <p>
          Development of Nix, the Nix packages collection and the NixOS Linux
          distribution happens on GitHub. To contribute to any of the Nix
          projects, just open a pull request on GitHub. The bots and
          community members will guide you further to through the process to
          ensure quality.
        </p>
      </div>
    </div>
  </div>

</section>

[% END %]
